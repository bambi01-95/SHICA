/* A recursive-descent parser generated by peg 0.1.18 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define YYRULECOUNT 83
#line 1 "code.leg"
;
/*
TODO:  Do it later
FIXME: Known bugs
HACK:  It's not pretty, it's not smart.
XXX:     Proble
*/
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>
#include <stdarg.h>
#include <time.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/select.h>
#include <termios.h>

FILE* SOURCE_FILE;
#define getchar() fgetc(SOURCE_FILE)

#define TEST 1


#define user_error(COND,MSG,LINE) ({ \
    if(COND){ \
        if(TEST==1)printf("[VM LINE %d]",__LINE__); \
        fprintf(stderr,"line %d: %s\n",LINE,MSG); \
        exit(1); \
    } \
})

void fatal(char *msg, ...)
{
    va_list ap;
    va_start(ap, msg);
    fprintf(stderr, "\n");
    vfprintf(stderr, msg, ap);
    fprintf(stderr, "\n");
    va_end(ap);
    exit(1);
}

#define out(A) printf("line %4d: %s\n",__LINE__,A)
#define line() printf("         line %4d: ",__LINE__)
union Object;
typedef union Object Object;
typedef Object *oop;


typedef oop (*Func)(oop);

typedef union VarData VarData;
typedef VarData *VD;

oop nil   = 0;
oop sys_false = 0;
oop sys_true  = 0;
oop none  = 0;
oop entry_sym = 0;

enum Type {
    Undefined,
    Operator,
    Integer, 
    Float, 
    String,
    List_d1,
    Key,    
    Symbol,  
    Function, 
    Event,
    State, 

    Pair, 
    Assoc,
    Array,

    Binop, 
    Unyop,  

    GetVar, 
    SetVar,  
    SetVarG,
    SetVarL,
    SetArray,
    GetArray,
    Call,  
    Run,   

    Print, 
    If,       
    While, 
    For,
    Block,
    Continue,
    Break,
    Return,

    Primitive,
    EventFunc,

    _BasePoint,
    _Undefined,
    _Integer,
    _Long,
    _Float,
    _Double,
    _Char,
    _IntegerArray,
    Thread,
    END,   
};

char *TYPENAME[END+1] = {
"Undefined",
"Operator",
"Integer", 
"Float", 
"String",
    "List_d1",
"Key",    
"Symbol",  
"Function", 
"Event",
"State", 

"Pair", 
"Assoc",
"Array",

"Binop", 
"Unyop",  

"GetVar", 
"SetVar",  
"SetVarG",
"SetVarL",
    "SetArray",
    "GetArray",
"Call",  
"Run",   

"Print", 
"If",       
"While", 
"For",
"Block",
"Continue",
"Break",
"Return",

"Primitive",
"EventFunc",

"_BasePoint",
"_Undefined",
"_Integer",
"_Long",
"_Float",
"_Double",
"_Char",
"_IntegerArray",
"Thread",
"END",
};



enum binop { AND, OR, ADD, SUB, MUL, DIV, MOD, LT, LE, GE, GT, EQ, NE };
enum unyop { NEG, AINC, BINC, ADEC, BDEC};

struct Undefined { enum Type type; };
struct Operator  { enum Type type; char value;};    // for operator
struct Integer 	 { enum Type type;  char* number; int line; };
struct Float     { enum Type type;  char* number; int line;};
struct String    { enum Type type;  char *value; };
struct Key       { enum Type type;  char *pass; };
struct Symbol  	 { enum Type type;  char *name;  oop value; };
struct Function	 { enum Type type;  oop parameters, body;int position;enum Type kind;};
struct Event     { enum Type type; oop id, parameters, body; };
struct State     { enum Type type; oop *events; int size,index; };

struct Pair  	 { enum Type type;  oop a, b; };
struct Assoc     { enum Type type;  oop symbol; enum Type kind; int index; };
struct Array     { enum Type type;  oop *elements; int size,number; int capacity;};

struct Binop   	 { enum Type type;  enum binop op;  oop lhs, rhs;       int line;};
struct Unyop   	 { enum Type type;  enum unyop op;  oop rhs;            int line;};

struct GetVar  	 { enum Type type;  oop id;                             int line;};
struct SetVar  	 { enum Type type;  enum Type typeset; oop id; oop rhs; int line;};
struct SetVarG   { enum Type type;  enum Type typeset; oop id; oop rhs; int line;};
struct SetVarL   { enum Type type;  enum Type typeset; oop id; oop rhs; int line;};
struct Call 	 { enum Type type;  oop function, arguments;            int line;};
struct Run       { enum Type type; oop state; };

struct Print   	 { enum Type type;  oop argument; enum Type kind;};
struct If      	 { enum Type type;  oop condition, statement1, statement2; };
struct While   	 { enum Type type;  oop condition, statement; };
struct For       { enum Type type;  oop initstate, condition,  update, statement; };
struct Block   	 { enum Type type;  oop *statements;  int size; };
struct Continue  { enum Type type; };
struct Break     { enum Type type; };
struct Return    { enum Type type; oop value;};

struct END       { enum Type type; };

struct Primitive{    
    enum Type type;
    char  lib_num;
    char func_num;
    char* args_type_array;
    char  size_of_args_type_array;
    char  return_type;
};

struct EventFunc{
    enum Type type;
    char  lib_num;
    char  eve_num;
    char* args_type_array;
    char  size_of_args_type_array;
    char* pin_num;
    char  size_of_pin_num;
};

#define TAGINT	1			// tag bits value for Integer  ........1
#define TAGFLT	2			// tag bits value for Float    .......10
#define TAGCHA  3
#define TAGBITS 2			// how many bits to use for tag bits
#define TAGMASK ((1 << TAGBITS) - 1)	//.mask to extract just the tag bits

struct _BasePoint { enum Type type; int adress; };
struct _Undefined{ enum Type type; };
struct _Integer  { enum Type type; int _value; };
struct _Long     { enum Type type; long long int value; };
struct _Float    { enum Type type; float _value; };
struct _Double   { enum Type type; double value; };
struct _Char     { enum Type type; char _value; };

struct Default{
    unsigned int count;
};

struct VarI{
    int v_i1;
};

struct VarII{
    int v_i1;
    int v_i2;
};

struct VarF{
    float v_f1;
};

struct VarFF{
    float v_f1;
    float v_f2;
};

struct VarT{
    time_t v_t1;
};

struct VarTI{
    time_t v_t1;
    int    v_i1;
    int    v_i2;
};

union VarData{
    struct Default Default;
    struct VarI  VarI;
    struct VarII VarII;
    struct VarF  VarF; 
    struct VarFF VarFF;    
    struct VarT  VarT; 
    struct VarTI VarTI;
};



struct Thread{
    unsigned int pc,rbp,base;   
    char queue_head; 
    char queue_num; 
    char flag; 
    oop stack; 
    oop queue[5];  
    Func func;
    union VarData*  vd;
};

union Object {
    enum   Type     type;
    struct Operator Operator;
    struct Integer  Integer;
    struct Symbol   Symbol;
    struct String   String; 
    struct Key      Key;
    struct Float    Float;
    struct List_d1  { enum Type _type;enum Type Typeset; }List_d1;

    struct Pair     Pair;
    struct Function Function;
    struct Binop    Binop;
    struct Unyop    Unyop;
    struct GetVar   GetVar;
    struct SetVar   SetVar;
    struct SetVarG SetVarG;
    struct SetVarL SetVarL;
    //in progress
    struct GetArray	 { enum Type _type;enum Type typeset;  oop array, index; int line;}GetArray;
    struct SetArray	 { enum Type _type;enum Type typeset;  oop array, index, value; int line;}SetArray;

    struct Call     Call;
    struct Print    Print;
    struct If       If;
    struct While    While;
    struct For      For;
    struct Block    Block;

    struct Continue Continue;
    struct Break    Break;
    struct Return   Return;
    struct Assoc    Assoc;
    struct Run      Run;
    struct State    State;
    struct Event    Event;
    struct END      END;
    struct Array    Array;

    struct Primitive Primitive;
    struct EventFunc EventFunc;

    struct _BasePoint _BasePoint;
    struct _Undefined _Undefined;
    struct _Integer   _Integer  ;
    struct _Long      _Long     ;
    struct _Float     _Float    ;
    struct _Double    _Double   ;
    struct _Char      _Char     ;
    //in progress
    struct _IntegerArray {enum Type _type;oop* array; int size, capacity;}_IntegerArray;
    struct Thread     Thread;
};


int getType(oop o)
{
    if ((((intptr_t)o) & TAGMASK) == TAGINT) return _Integer;
    if ((((intptr_t)o) & TAGMASK) == TAGFLT) return _Float;
    if ((((intptr_t)o) & TAGMASK) == TAGFLT) return _Float;
    return o->type;
}





oop _check(oop node, enum Type type, char *file, int line)
{
    if (getType(node) != type) {
	fprintf(stderr, "\n%s:%d: expected type %d got type %d\n", file, line, type, getType(node));
		printf("%s but %s\n",TYPENAME[type],TYPENAME[getType(node)]);
    exit(1);
    }
    return node;
}

#define get(PTR, TYPE, FIELD)	(_check((PTR), TYPE, __FILE__, __LINE__)->TYPE.FIELD)

oop _newObject(size_t size, enum Type type)
{
    oop node = calloc(1, size);
    node->type = type;
    return node;
}

#define newObject(TYPE)	_newObject(sizeof(struct TYPE), TYPE)

/*---------------------------------------------*/
oop _newInteger(int value)
{
    return (oop)(((intptr_t)value << TAGBITS) | TAGINT);
}

oop _newCharInteger(char *number)
{
    int value = atoi(number);
    return (oop)(((intptr_t)value << TAGBITS) | TAGINT);
}

int _Integer_value(oop obj)
{
    assert(_Integer == getType(obj));
    return (intptr_t)obj >> TAGBITS;
}

oop _newLong(long long int value){
    oop node = newObject(_Long);
    node->_Long.value = value;
    return node;
}

oop _newCharLong(char* number){
    char *endptr;
    long long int value = strtoll(number,&endptr,10);
    return _newLong(value);
}

oop _newFloat(float value)
{
    union { double d;  intptr_t i; } u = { .d = (double)value };
    return (oop)(((intptr_t)u.i & ~TAGMASK) | TAGFLT);
}

oop _newCharFloat(char* number)
{
    double value = atof(number);
    union { double d;  intptr_t i; } u = { .d = value };
    return (oop)(((intptr_t)u.i & ~TAGMASK) | TAGFLT);
}

float _Float_value(oop obj)
{
    assert(_Float == getType(obj));
    union { intptr_t i;  double d; } u = { .i = (intptr_t)obj };
    return (float)u.d;
}

oop _newDouble(double value){
    oop node = newObject(_Double);
    node->_Double.value = value;
    return node;
}

oop _newCharDouble(char* number){
    char *endptr;
    double value = strtod(number, &endptr);
    return _newDouble(value);
}



/////////CHAR
// #define _newChar(A) (oop)(((intptr_t)A << TAGBITS) | TAGCHA)
oop _newChar(char value)
{
    return (oop)(((intptr_t)value << TAGBITS) | TAGCHA);
}

oop _newCharChar(char number)
{
    char value  = number;
    return (oop)(((intptr_t)value << TAGBITS) | TAGCHA);
}

oop _newStrChar(char* number)
{
    assert(strlen(number)==2);
    char value  = number[0];
    return (oop)(((intptr_t)value << TAGBITS) | TAGCHA);
}

#define _Char_value(A) (char)((intptr_t)A >> TAGBITS)
//FIXME: make segmentation error
// char _Char_value(oop obj)
// {
//     assert(_Char == getType(obj));
//     out("char value");
//     return (intptr_t)obj >> TAGBITS;
// }


// in progress
oop _newIntegerArray(int size){
    oop node = newObject(_IntegerArray);
    node->_IntegerArray.capacity = size;/*Free size*/
    node->_IntegerArray.size     = size;
    node->_IntegerArray.array    = calloc(size, sizeof(oop));
    return node;
}




oop newArray(int);



/*---------------------------------------------*/
// oop newOperator(char value){
//     oop node = newObject(Operator);
//     node->Operator.value = value;
//     return node;
// }


oop newInteger(char* number,int line)
{
    oop node = newObject(Integer);
    node->Integer.number = strdup(number);
    node->Integer.line   = line;
    return node;
}

oop newFloat(char* number, int line){
    oop node = newObject(Float);
    node->Float.number = strdup(number);
    node->Float.line = line;
    return node;
}

oop newString(char *value){
    oop node = newObject(String);
    node->String.value = strdup(value);
    return node;
}

oop newKey(char *pass){
    oop node = newObject(Key);
    // is it need here? pass length 8~12 or fix num?
    // in this time 8
    if(8!=strlen(pass)){
        fprintf(stderr,"Key length shoud be 8\n");
        exit(1);
    }
    node->Key.pass = strdup(pass);
    return node;
}

oop newSymbol(char *name)
{
    oop sym = newObject(Symbol);
    sym->Symbol.name  = strdup(name);
    sym->Symbol.value = sys_false;
    return sym;
}

oop *symbols = 0;
int nsymbols = 0;

oop intern(char *name)
{
    // binary search for existing symbol
    int lo = 0, hi = nsymbols - 1;
    while (lo <= hi) {
	int mid = (lo + hi) / 2;
	int cmp = strcmp(name, get(symbols[mid], Symbol,name));
	if      (cmp < 0) hi = mid - 1;
	else if (cmp > 0) lo = mid + 1;
	else    return symbols[mid];
    }
    symbols   = realloc(symbols,   sizeof(*symbols)   * (nsymbols + 1));
    memmove(symbols + lo + 1,
	    symbols + lo,
	    sizeof(*symbols) * (nsymbols++ - lo));
    return symbols[lo] = newSymbol(name);
}

oop newList_d1(enum Type t){
    oop node = newObject(List_d1);
    node->List_d1.Typeset = t;
    return node;
}

void printlnObject(oop node, int indent);
oop newPair(oop a, oop b)
{
    oop obj = newObject(Pair);
    obj->Pair.a = a;
    obj->Pair.b = b;
    return obj;
}

oop newFunction(oop parameters, oop body)
{
    oop node = newObject(Function);
    // * type need here *//
    node->Function.parameters = parameters;
    node->Function.body       = body;
    node->Function.position   = 0;
    node->Function.kind       = Undefined;
    return node;
}

oop newBinop(enum binop op, oop lhs, oop rhs,int line)
{
    oop node = newObject(Binop);
    node->Binop.op  = op;
    node->Binop.lhs = lhs;
    node->Binop.rhs = rhs;
    node->Binop.line = line;
    return node;
}

oop newUnyop(enum unyop op, oop rhs,int line)
{
    oop node = newObject(Unyop);
    node->Unyop.op  = op;
    node->Unyop.rhs = rhs;
    node->Unyop.line = line;
    return node;
}

oop newGetVar(oop id,int line)
{
    oop node = newObject(GetVar);
    node->GetVar.id = id;
    node->GetVar.line = line;
    return node;
}

oop newSetVar(oop typeset, oop id, oop rhs,int line)
{
    oop node = newObject(SetVar);
    node->SetVar.id  = id;
    node->SetVar.typeset = getType(typeset);
    node->SetVar.rhs = rhs;
    node->SetVar.line = line;
    return node;
}

oop newSetVarG(oop typeset, oop id, oop rhs,int line)
{
    oop node = newObject(SetVarG);
    node->SetVarG.id  = id;
    node->SetVarG.typeset = getType(typeset);
    node->SetVarG.rhs = rhs;
    node->SetVarG.line = line;
    return node;
}

oop newSetVarL(oop typeset, oop id, oop rhs,int line)
{
    oop node = newObject(SetVarL);
    node->SetVarL.id  = id;
    node->SetVarL.typeset = getType(typeset);
    node->SetVarL.rhs = rhs;
    node->SetVarL.line = line;
    return node;
}

//in progress
oop newSetArray(oop typeset,oop array, oop index, oop value,int line)
{
    oop node = newObject(SetArray);
    node->SetArray.typeset = getType(typeset);
    node->SetArray.array = array;
    node->SetArray.index = index;
    node->SetArray.value = value;
    node->SetArray.line  = line;
    return node;
}

oop newGetArray(oop array, oop index,int line)
{
    oop node = newObject(GetArray);
    node->GetArray.array = array;
    node->GetArray.index = index;
    node->SetArray.line  = line;
    return node;
}

oop newCall(oop arguments, oop function,int line)
{
    oop node = newObject(Call);
    node->Call.arguments = arguments;
    node->Call.function  = function;
    node->Call.line = line;
    return node;
}

oop newPrint(oop argument,oop kind)
{
    oop node = newObject(Print);
    node->Print.argument = argument;
    node->Print.kind     = kind->type;
    return node;
}

oop newIf(oop condition, oop s1, oop s2)
{
    oop node = newObject(If);
    node->If.condition = condition;
    node->If.statement1 = s1;
    node->If.statement2 = s2;
    return node;
}

oop newWhile(oop condition, oop s)
{
    oop node = newObject(While);
    node->While.condition = condition;
    node->While.statement = s;
    return node;
}

oop newFor(oop initstate,oop condition,oop updata,oop statement){
    oop node = newObject(For);
    node->For.initstate = initstate;
    node->For.condition = condition;
    node->For.update    = updata;
    node->For.statement = statement;
    return node;
}

oop newBlock(void)
{
    oop node = newObject(Block);
    node->Block.statements = 0;
    node->Block.size = 0;
    return node;
}

void Block_append(oop b, oop s)
{
    oop *ss = get(b, Block,statements);
    int  sz = get(b, Block,size);
    ss = realloc(ss, sizeof(oop) * (sz + 1));
    ss[sz++] = s;
    get(b, Block,statements) = ss;
    get(b, Block,size) = sz;
}
// leg 9
oop newContinue(){
    return newObject(Continue);
}
oop newBreak(){
    return newObject(Break);
}
oop newReturn(oop value){
    oop node =  newObject(Return);
    node->Return.value = value;
    return node;
}

oop newRun(oop s){
    oop node = newObject(Run);
    node->Run.state = s;
    return node;
}

oop newState(void)
{
    oop node = newObject(State);
    node->State.events = 0;
    node->State.size   = 0;
    return node;
}

oop newEvent(oop id,oop params,oop body){
    oop node = newObject(Event);
    node->Event.id = id;
    node->Event.parameters = params;
    node->Event.body   = body;
    return node;
}

void State_append(oop s, oop e)
{
    oop *ss = get(s, State,events);
    int  sz = get(s, State,size);
    ss = realloc(ss, sizeof(oop) * (sz + 1));
    ss[sz++] = e;
    get(s, State,events) = ss;
    get(s, State,size)   = sz;
}

oop newEND(void){
    oop node = newObject(END);
    return node;
}

oop new_Basepoint(int adress){
    oop node = newObject(_BasePoint);
    node->_BasePoint.adress = adress;
    return node;
}

oop newAssoc(oop symbol,enum Type kind,int index){
    oop node = newObject(Assoc);
    node->Assoc.symbol = symbol;
    node->Assoc.kind   = kind;
    node->Assoc.index  = index;
    return node;
}


oop newArray(int capacity){
    oop obj = newObject(Array);
    obj->Array.size = 0;
    obj->Array.number = 0;
    obj->Array.capacity = capacity;
    obj->Array.elements = calloc(capacity, sizeof(oop));
    return obj;
}

int Array_size(oop obj){
    assert(getType(obj)==Array);
    return obj->Array.size;
}

int Array_number(oop obj){
    assert(getType(obj)==Array);
    return obj->Array.number;
}

oop Array_put(oop obj,unsigned int index,oop element)
{
    assert(getType(obj)==Array);
    if(index >obj->Array.capacity){
        obj->Array.elements= realloc(obj->Array.elements,(index+1)*sizeof(oop));
        obj->Array.capacity=index + 1;
    }
    while(obj->Array.size<(index+1)){
        obj->Array.elements[obj->Array.size++]=nil;
        obj->Array.number++;
    }
    return obj->Array.elements[index]=element;
}

oop Array_get(oop obj, unsigned int index){
    assert(getType(obj)==Array);
    if(index < obj->Array.size)
		return obj->Array.elements[index];
	return nil;
};

oop Array_push(oop obj,oop element){
    assert(getType(obj)==Array);
    if(obj->Array.size >= obj->Array.capacity){
		obj->Array.elements = realloc(obj->Array.elements,(obj->Array.size + 1) * sizeof(oop));
		obj->Array.capacity += 1;
    }
    obj->Array.number++;
    obj->Array.elements[obj->Array.size++] = element;
    return obj;
};

oop Array_pop(oop obj){
    assert(getType(obj)==Array);
	if(obj->Array.size <= 0){
		fprintf(stderr,"Array is empty [array_pop]\n");
		exit(1);
	}
    oop element = obj->Array.elements[--obj->Array.size];
    obj->Array.elements[obj->Array.size] = nil;
    return element;
};


// ライブラリ用のプログラミングコード
oop _newPrimitive(oop name,char lib_num,char func_num,char* args_type_array,char size_of_args_type_array,char return_type){
    oop prim = newObject(Primitive);
    prim->Primitive.lib_num   = lib_num;
    prim->Primitive.func_num  = func_num;
    prim->Primitive.return_type = return_type;
    prim->Primitive.args_type_array = args_type_array;
    prim->Primitive.size_of_args_type_array  = size_of_args_type_array;
    name->Symbol.value = prim;
    return prim;
}

#define newPrimitive(name, lib_num, func_num, return_type, size_of_args_type_array,  ...) ({ \
    static char name##__[size_of_args_type_array] = {__VA_ARGS__}; \
    _newPrimitive(intern(#name), lib_num, func_num,name##__, size_of_args_type_array , return_type);\
})




// ---------　イベント用の関数　---------------

#define list(...)  {__VA_ARGS__}

oop _newEventFunc(oop name,char lib_num,char eve_num,char* args_type_array,char size_of_args_type_array,char * pin_num,char  size_of_pin_num){
    oop prim = newObject(EventFunc);
    prim->EventFunc.lib_num   = lib_num;
    prim->EventFunc.eve_num  = eve_num;
    prim->EventFunc.args_type_array = args_type_array;
    prim->EventFunc.size_of_args_type_array  = size_of_args_type_array;
    prim->EventFunc.pin_num = pin_num;
    prim->EventFunc.size_of_pin_num = size_of_pin_num;
    name->Symbol.value = prim;
    return prim;
}



#define newEventFunc(name, lib_num, eve_num, size_of_args_type_array, args_type_array,size_of_pins,pins) ({ \
    static char name##__[size_of_args_type_array] = args_type_array; \
    static char name##__p[size_of_pins] =  pins ; \
    if(name##__[0]==Undefined){ \
        _newEventFunc(intern(#name), lib_num, eve_num,0,0,0,0);\
    } \
    else if(name##__p[0] == Undefined) _newEventFunc(intern(#name), lib_num, eve_num, name##__,size_of_args_type_array,0, 0 );\
    else _newEventFunc(intern(#name), lib_num, eve_num, name##__,size_of_args_type_array, name##__p, size_of_pins); \
})


// ----------- 関数の定義: Event function definition.----------------

typedef enum {
    STDLIB,
    USERLIB,
} LIB;

enum STDLIB_E{
    LOOP_E,
    TIMERSEC_E,
    KEYGET_E,
};

enum STDLIB_P{
    OUTPUT_P,
    ITOC_P,
    APPENDCHAR_P,
    EXIT_P,
};


void setting_stdlib(){
    //Primitive Function
    /*  (name, lib_num, func_num, return_type, size_of_args_type_array,  args_type )  */
    newPrimitive(output, STDLIB,OUTPUT_P,Undefined ,1,_Integer);
    newPrimitive(itoc  ,STDLIB, ITOC_P  ,_Char     ,1,_Integer);
    newPrimitive(exit,  STDLIB, EXIT_P  ,Undefined ,1,_Integer);
    newPrimitive(appendchar,  STDLIB, APPENDCHAR_P  , String ,2,_Char,String);
    //Event Function
                /*関数名,   libnum, funcnum, num_args, args_type, num_of_pin,　pin_value */
/*
    call_e lib func pin
    event(int k) 
*/
    newEventFunc(loop,     STDLIB, LOOP_E    ,1,list(Undefined),1,list(Undefined));
    newEventFunc(timer_sec,STDLIB, TIMERSEC_E,1,list(_Integer),1,list(Operator)); /*FIXME: Operater should be 1*/
    newEventFunc(keyget,   STDLIB, KEYGET_E  ,1,list(_Integer),1,list(Undefined));
    return;
}




void printlnObject(oop node, int indent)
{
    printf("%*s", indent*2, "");
    switch (getType(node)) {
	case Undefined:	printf("nil\n");				break;
	case Integer:	printf("%s\n", get(node, Integer,number));	break;
	case Symbol :	printf("%s\n", get(node, Symbol,name));		break;
    case Float :    printf("%s\n",get(node,   Float,number));     break;
    case String :   printf("%s\n", get(node, String, value));   break;// c5
    case Key:       printf("%s\n", get(node, Key,    pass));    break;
	case Pair: {
	    printf("Pair\n");
	    printlnObject(get(node, Pair,a), indent+1);
	    printlnObject(get(node, Pair,b), indent+1);
	    break;
	}
	case Function: {
	    printf("function()\n");
	    printlnObject(get(node, Function,parameters), indent+2);
	    printlnObject(get(node, Function,body), indent+1);
	    break;
	}
	case Binop: {
	    switch (get(node, Binop,op)) {
		case NE:  printf("NE\n"); break;
		case EQ:  printf("EQ\n"); break;
		case LT:  printf("LT\n"); break;
		case LE:  printf("LE\n"); break;
		case GE:  printf("GE\n"); break;
		case GT:  printf("GT\n"); break;
		case ADD: printf("ADD\n"); break;
		case SUB: printf("SUB\n"); break;
		case MUL: printf("MUL\n"); break;
		case DIV: printf("DIV\n"); break;
		case MOD: printf("MOD\n"); break;
		default:  assert(!"this cannot happen binop");
	    }
	    printlnObject(get(node, Binop,lhs), indent+1);
	    printlnObject(get(node, Binop,rhs), indent+1);
	    break;
	}
	case Unyop: {
	    switch (get(node, Unyop,op)) {
		case NEG: printf("NEG\n"); break;
		default:  assert(!"this cannot happen unyop");
	    }
	    printlnObject(get(node, Unyop,rhs), indent+1);
	    break;
	}
	case GetVar: {
	    printf("GetVar %s\n", get(get(node, GetVar,id), Symbol,name));
	    break;
	}
	case SetVar: {
	    printf("SetVar %s\n", get(get(node, SetVar,id), Symbol,name));
	    printlnObject(get(node, SetVar,rhs), indent+1);
	    break;
	}
	case Call: {
	    printf("Call\n");
	    printlnObject(get(node, Call,function), indent+1);
	    printlnObject(get(node, Call,arguments), indent+1);
	    break;
	}
	case Print: {
	    printf("Print\n");
	    printlnObject(get(node, Print,argument), indent+1);
	    break;
	}
	case If: {
	    printf("If\n");
	    printlnObject(get(node, If,condition), indent+1);
	    printlnObject(get(node, If,statement1), indent+1);
	    printlnObject(get(node, If,statement2), indent+1);
	    break;
	}
	case While: {
	    printf("While\n");
	    printlnObject(get(node, While,condition), indent+1);
	    printlnObject(get(node, While,statement), indent+1);
	    break;
	}
	case Block: {
	    printf("Block...\n");
	    break;
	}
    case Event:{
        printf("Event\n");
        break;
    }
    case State:{
        printf("State\n");
        break;
    }
    case Run:{
        printf("Run\n");
        break;
    }
    case Continue:{
        printf("Continue\n");
        break;
    }
    case Break:{
        printf("Break\n");
        break;
    }
    case Return:{
        printf("Return\n");
        break;
    }
    case END:{
        printf("END\n");
        break;
    }
    case Array:{
        int size = node->Array.size;
        printf("Array\n");
        for(int i = 0;i<size;i++){
            printlnObject(node->Array.elements[i],indent+1);
        }
        break;
    }
    case Assoc:{
        printf("type %2d, index %3d",node->Assoc.kind,node->Assoc.index);
        printlnObject(node->Assoc.symbol,indent);
        break;
    }
    case _Integer:printf("%d\n",_Integer_value(node));break;
    case _Long:   printf("%lld\n",get(node,_Long,value));break;
    case _Float:  printf("%f\n",_Float_value(node));break;
    case _Double: printf("%lf\n",get(node,_Double,value));break;
	default:	printf("%s\n",TYPENAME[node->type]);assert(!"this cannot happen print");			break;
    }
}







#define YYSTYPE oop

YYSTYPE result;

int newline = 1;


#ifndef YY_MALLOC
#define YY_MALLOC(C, N)		malloc(N)
#endif
#ifndef YY_REALLOC
#define YY_REALLOC(C, P, N)	realloc(P, N)
#endif
#ifndef YY_FREE
#define YY_FREE(C, P)		free(P)
#endif
#ifndef YY_LOCAL
#define YY_LOCAL(T)	static T
#endif
#ifndef YY_ACTION
#define YY_ACTION(T)	static T
#endif
#ifndef YY_RULE
#define YY_RULE(T)	static T
#endif
#ifndef YY_PARSE
#define YY_PARSE(T)	T
#endif
#ifndef YYPARSE
#define YYPARSE		yyparse
#endif
#ifndef YYPARSEFROM
#define YYPARSEFROM	yyparsefrom
#endif
#ifndef YYRELEASE
#define YYRELEASE	yyrelease
#endif
#ifndef YY_BEGIN
#define YY_BEGIN	( yy->__begin= yy->__pos, 1)
#endif
#ifndef YY_END
#define YY_END		( yy->__end= yy->__pos, 1)
#endif
#ifdef YY_DEBUG
# define yyprintf(args)	fprintf args
#else
# define yyprintf(args)
#endif
#ifndef YYSTYPE
#define YYSTYPE	int
#endif
#ifndef YY_STACK_SIZE
#define YY_STACK_SIZE 128
#endif

#ifndef YY_BUFFER_SIZE
#define YY_BUFFER_SIZE 1024
#endif

#ifndef YY_PART

typedef struct _yycontext yycontext;
typedef void (*yyaction)(yycontext *yy, char *yytext, int yyleng);
typedef struct _yythunk { int begin, end;  yyaction  action;  struct _yythunk *next; } yythunk;

struct _yycontext {
  char     *__buf;
  int       __buflen;
  int       __pos;
  int       __limit;
  char     *__text;
  int       __textlen;
  int       __begin;
  int       __end;
  int       __textmax;
  yythunk  *__thunks;
  int       __thunkslen;
  int       __thunkpos;
  YYSTYPE   __;
  YYSTYPE  *__val;
  YYSTYPE  *__vals;
  int       __valslen;
#ifdef YY_CTX_MEMBERS
  YY_CTX_MEMBERS
#endif
};

#ifdef YY_CTX_LOCAL
#define YY_CTX_PARAM_	yycontext *yyctx,
#define YY_CTX_PARAM	yycontext *yyctx
#define YY_CTX_ARG_	yyctx,
#define YY_CTX_ARG	yyctx
#ifndef YY_INPUT
#define YY_INPUT(yy, buf, result, max_size)		\
  {							\
    int yyc= getchar();					\
    result= (EOF == yyc) ? 0 : (*(buf)= yyc, 1);	\
    yyprintf((stderr, "<%c>", yyc));			\
  }
#endif
#else
#define YY_CTX_PARAM_
#define YY_CTX_PARAM
#define YY_CTX_ARG_
#define YY_CTX_ARG
yycontext _yyctx= { 0, 0 };
yycontext *yyctx= &_yyctx;
#ifndef YY_INPUT
#define YY_INPUT(buf, result, max_size)			\
  {							\
    int yyc= getchar();					\
    result= (EOF == yyc) ? 0 : (*(buf)= yyc, 1);	\
    yyprintf((stderr, "<%c>", yyc));			\
  }
#endif
#endif

YY_LOCAL(int) yyrefill(yycontext *yy)
{
  int yyn;
  while (yy->__buflen - yy->__pos < 512)
    {
      yy->__buflen *= 2;
      yy->__buf= (char *)YY_REALLOC(yy, yy->__buf, yy->__buflen);
    }
#ifdef YY_CTX_LOCAL
  YY_INPUT(yy, (yy->__buf + yy->__pos), yyn, (yy->__buflen - yy->__pos));
#else
  YY_INPUT((yy->__buf + yy->__pos), yyn, (yy->__buflen - yy->__pos));
#endif
  if (!yyn) return 0;
  yy->__limit += yyn;
  return 1;
}

YY_LOCAL(int) yymatchDot(yycontext *yy)
{
  if (yy->__pos >= yy->__limit && !yyrefill(yy)) return 0;
  ++yy->__pos;
  return 1;
}

YY_LOCAL(int) yymatchChar(yycontext *yy, int c)
{
  if (yy->__pos >= yy->__limit && !yyrefill(yy)) return 0;
  if ((unsigned char)yy->__buf[yy->__pos] == c)
    {
      ++yy->__pos;
      yyprintf((stderr, "  ok   yymatchChar(yy, %c) @ %s\n", c, yy->__buf+yy->__pos));
      return 1;
    }
  yyprintf((stderr, "  fail yymatchChar(yy, %c) @ %s\n", c, yy->__buf+yy->__pos));
  return 0;
}

YY_LOCAL(int) yymatchString(yycontext *yy, const char *s)
{
  int yysav= yy->__pos;
  while (*s)
    {
      if (yy->__pos >= yy->__limit && !yyrefill(yy)) return 0;
      if (yy->__buf[yy->__pos] != *s)
        {
          yy->__pos= yysav;
          return 0;
        }
      ++s;
      ++yy->__pos;
    }
  return 1;
}

YY_LOCAL(int) yymatchClass(yycontext *yy, unsigned char *bits)
{
  int c;
  if (yy->__pos >= yy->__limit && !yyrefill(yy)) return 0;
  c= (unsigned char)yy->__buf[yy->__pos];
  if (bits[c >> 3] & (1 << (c & 7)))
    {
      ++yy->__pos;
      yyprintf((stderr, "  ok   yymatchClass @ %s\n", yy->__buf+yy->__pos));
      return 1;
    }
  yyprintf((stderr, "  fail yymatchClass @ %s\n", yy->__buf+yy->__pos));
  return 0;
}

YY_LOCAL(void) yyDo(yycontext *yy, yyaction action, int begin, int end)
{
  while (yy->__thunkpos >= yy->__thunkslen)
    {
      yy->__thunkslen *= 2;
      yy->__thunks= (yythunk *)YY_REALLOC(yy, yy->__thunks, sizeof(yythunk) * yy->__thunkslen);
    }
  yy->__thunks[yy->__thunkpos].begin=  begin;
  yy->__thunks[yy->__thunkpos].end=    end;
  yy->__thunks[yy->__thunkpos].action= action;
  ++yy->__thunkpos;
}

YY_LOCAL(int) yyText(yycontext *yy, int begin, int end)
{
  int yyleng= end - begin;
  if (yyleng <= 0)
    yyleng= 0;
  else
    {
      while (yy->__textlen < (yyleng + 1))
	{
	  yy->__textlen *= 2;
	  yy->__text= (char *)YY_REALLOC(yy, yy->__text, yy->__textlen);
	}
      memcpy(yy->__text, yy->__buf + begin, yyleng);
    }
  yy->__text[yyleng]= '\0';
  return yyleng;
}

YY_LOCAL(void) yyDone(yycontext *yy)
{
  int pos;
  for (pos= 0;  pos < yy->__thunkpos;  ++pos)
    {
      yythunk *thunk= &yy->__thunks[pos];
      int yyleng= thunk->end ? yyText(yy, thunk->begin, thunk->end) : thunk->begin;
      yyprintf((stderr, "DO [%d] %p %s\n", pos, thunk->action, yy->__text));
      thunk->action(yy, yy->__text, yyleng);
    }
  yy->__thunkpos= 0;
}

YY_LOCAL(void) yyCommit(yycontext *yy)
{
  if ((yy->__limit -= yy->__pos))
    {
      memmove(yy->__buf, yy->__buf + yy->__pos, yy->__limit);
    }
  yy->__begin -= yy->__pos;
  yy->__end -= yy->__pos;
  yy->__pos= yy->__thunkpos= 0;
}

YY_LOCAL(int) yyAccept(yycontext *yy, int tp0)
{
  if (tp0)
    {
      fprintf(stderr, "accept denied at %d\n", tp0);
      return 0;
    }
  else
    {
      yyDone(yy);
      yyCommit(yy);
    }
  return 1;
}

YY_LOCAL(void) yyPush(yycontext *yy, char *text, int count)
{
  yy->__val += count;
  while (yy->__valslen <= yy->__val - yy->__vals)
    {
      long offset= yy->__val - yy->__vals;
      yy->__valslen *= 2;
      yy->__vals= (YYSTYPE *)YY_REALLOC(yy, yy->__vals, sizeof(YYSTYPE) * yy->__valslen);
      yy->__val= yy->__vals + offset;
    }
}
YY_LOCAL(void) yyPop(yycontext *yy, char *text, int count)   { yy->__val -= count; }
YY_LOCAL(void) yySet(yycontext *yy, char *text, int count)   { yy->__val[count]= yy->__; }

#endif /* YY_PART */

#define	YYACCEPT	yyAccept(yy, yythunkpos0)

YY_RULE(int) yy_blank(yycontext *yy); /* 83 */
YY_RULE(int) yy_space(yycontext *yy); /* 82 */
YY_RULE(int) yy_alnum(yycontext *yy); /* 81 */
YY_RULE(int) yy_alpha(yycontext *yy); /* 80 */
YY_RULE(int) yy_expnt(yycontext *yy); /* 79 */
YY_RULE(int) yy_integer(yycontext *yy); /* 78 */
YY_RULE(int) yy_float_(yycontext *yy); /* 77 */
YY_RULE(int) yy_string(yycontext *yy); /* 76 */
YY_RULE(int) yy_DQUOTE(yycontext *yy); /* 75 */
YY_RULE(int) yy_character(yycontext *yy); /* 74 */
YY_RULE(int) yy_QUOTE(yycontext *yy); /* 73 */
YY_RULE(int) yy_args(yycontext *yy); /* 72 */
YY_RULE(int) yy_postfix(yycontext *yy); /* 71 */
YY_RULE(int) yy_DECRE(yycontext *yy); /* 70 */
YY_RULE(int) yy_INCRE(yycontext *yy); /* 69 */
YY_RULE(int) yy_value(yycontext *yy); /* 68 */
YY_RULE(int) yy_PCENT(yycontext *yy); /* 67 */
YY_RULE(int) yy_SLASH(yycontext *yy); /* 66 */
YY_RULE(int) yy_STAR(yycontext *yy); /* 65 */
YY_RULE(int) yy_prefix(yycontext *yy); /* 64 */
YY_RULE(int) yy_MINUS(yycontext *yy); /* 63 */
YY_RULE(int) yy_PLURS(yycontext *yy); /* 62 */
YY_RULE(int) yy_mul(yycontext *yy); /* 61 */
YY_RULE(int) yy_LESS(yycontext *yy); /* 60 */
YY_RULE(int) yy_LESSEQ(yycontext *yy); /* 59 */
YY_RULE(int) yy_GREATEQ(yycontext *yy); /* 58 */
YY_RULE(int) yy_GREATER(yycontext *yy); /* 57 */
YY_RULE(int) yy_add(yycontext *yy); /* 56 */
YY_RULE(int) yy_NOTEQ(yycontext *yy); /* 55 */
YY_RULE(int) yy_EQUAL(yycontext *yy); /* 54 */
YY_RULE(int) yy_ineq(yycontext *yy); /* 53 */
YY_RULE(int) yy_LOGAND(yycontext *yy); /* 52 */
YY_RULE(int) yy_eqop(yycontext *yy); /* 51 */
YY_RULE(int) yy_LOGOR(yycontext *yy); /* 50 */
YY_RULE(int) yy_logmul(yycontext *yy); /* 49 */
YY_RULE(int) yy_logadd(yycontext *yy); /* 48 */
YY_RULE(int) yy_RSQP(yycontext *yy); /* 47 */
YY_RULE(int) yy_LSQP(yycontext *yy); /* 46 */
YY_RULE(int) yy_func(yycontext *yy); /* 45 */
YY_RULE(int) yy_DIVEQU(yycontext *yy); /* 44 */
YY_RULE(int) yy_MULEQU(yycontext *yy); /* 43 */
YY_RULE(int) yy_SUBEQU(yycontext *yy); /* 42 */
YY_RULE(int) yy_ADDEQU(yycontext *yy); /* 41 */
YY_RULE(int) yy_assign(yycontext *yy); /* 40 */
YY_RULE(int) yy_mkBlock(yycontext *yy); /* 39 */
YY_RULE(int) yy_block(yycontext *yy); /* 38 */
YY_RULE(int) yy__(yycontext *yy); /* 37 */
YY_RULE(int) yy_RETURN(yycontext *yy); /* 36 */
YY_RULE(int) yy_BREAK(yycontext *yy); /* 35 */
YY_RULE(int) yy_CONTINUE(yycontext *yy); /* 34 */
YY_RULE(int) yy_SEMI(yycontext *yy); /* 33 */
YY_RULE(int) yy_mkNil(yycontext *yy); /* 32 */
YY_RULE(int) yy_expr(yycontext *yy); /* 31 */
YY_RULE(int) yy_FOR(yycontext *yy); /* 30 */
YY_RULE(int) yy_WHILE(yycontext *yy); /* 29 */
YY_RULE(int) yy_ELSE(yycontext *yy); /* 28 */
YY_RULE(int) yy_IF(yycontext *yy); /* 27 */
YY_RULE(int) yy_RPAR(yycontext *yy); /* 26 */
YY_RULE(int) yy_COMMA(yycontext *yy); /* 25 */
YY_RULE(int) yy_LPAR(yycontext *yy); /* 24 */
YY_RULE(int) yy_PRINT(yycontext *yy); /* 23 */
YY_RULE(int) yy_stmt(yycontext *yy); /* 22 */
YY_RULE(int) yy_NLINE(yycontext *yy); /* 21 */
YY_RULE(int) yy_list(yycontext *yy); /* 20 */
YY_RULE(int) yy_blocks(yycontext *yy); /* 19 */
YY_RULE(int) yy_event(yycontext *yy); /* 18 */
YY_RULE(int) yy_RBRACE(yycontext *yy); /* 17 */
YY_RULE(int) yy_mkState(yycontext *yy); /* 16 */
YY_RULE(int) yy_LBRACE(yycontext *yy); /* 15 */
YY_RULE(int) yy_eol(yycontext *yy); /* 14 */
YY_RULE(int) yy_RUN(yycontext *yy); /* 13 */
YY_RULE(int) yy_exp(yycontext *yy); /* 12 */
YY_RULE(int) yy_ASSIGN(yycontext *yy); /* 11 */
YY_RULE(int) yy_stmtbl(yycontext *yy); /* 10 */
YY_RULE(int) yy_params(yycontext *yy); /* 9 */
YY_RULE(int) yy_TYPE(yycontext *yy); /* 8 */
YY_RULE(int) yy_bracket(yycontext *yy); /* 7 */
YY_RULE(int) yy_state(yycontext *yy); /* 6 */
YY_RULE(int) yy_id(yycontext *yy); /* 5 */
YY_RULE(int) yy_STATE(yycontext *yy); /* 4 */
YY_RULE(int) yy_define(yycontext *yy); /* 3 */
YY_RULE(int) yy_bln(yycontext *yy); /* 2 */
YY_RULE(int) yy_start(yycontext *yy); /* 1 */

YY_ACTION(void) yy_1_STATE(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_STATE\n"));
  {
#line 1328
   __ = newObject(State) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_7_TYPE(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_7_TYPE\n"));
  {
#line 1286
   __ = newObject(Key)     ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_6_TYPE(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_6_TYPE\n"));
  {
#line 1285
   __ = newObject(String)  ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_5_TYPE(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_5_TYPE\n"));
  {
#line 1284
   __ = newObject(_Char)   ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_4_TYPE(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_4_TYPE\n"));
  {
#line 1283
   __ = newObject(_Float)  ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_3_TYPE(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_TYPE\n"));
  {
#line 1282
   __ = newObject(_Double) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_2_TYPE(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_TYPE\n"));
  {
#line 1281
   __ = newObject(_Long)   ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_TYPE(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_TYPE\n"));
  {
#line 1280
   __ = newObject(_Integer);
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_NLINE(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_NLINE\n"));
  {
#line 1275
   ++newline ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_id(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_id\n"));
  {
#line 1259
   __ = intern(yytext);  ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_integer(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_integer\n"));
  {
#line 1258
   __ = newInteger(yytext,newline) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_character(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_character\n"));
  {
#line 1257
   __ = _newStrChar(yytext);
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_string(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_string\n"));
  {
#line 1256
   __ = newString(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_float_(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_float_\n"));
  {
#line 1252
   __ = newFloat(yytext,newline) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_2_value(yycontext *yy, char *yytext, int yyleng)
{
#define i yy->__val[-1]
#define lhs yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_value\n"));
  {
#line 1246
   __ = newGetVar(i,newline) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef i
#undef lhs
}
YY_ACTION(void) yy_1_value(yycontext *yy, char *yytext, int yyleng)
{
#define i yy->__val[-1]
#define lhs yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_value\n"));
  {
#line 1241
   __ = lhs ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef i
#undef lhs
}
YY_ACTION(void) yy_3_args(yycontext *yy, char *yytext, int yyleng)
{
#define i yy->__val[-1]
#define a yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_args\n"));
  {
#line 1239
   __ = a ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef i
#undef a
}
YY_ACTION(void) yy_2_args(yycontext *yy, char *yytext, int yyleng)
{
#define i yy->__val[-1]
#define a yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_args\n"));
  {
#line 1236
   a = newPair(i, a) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef i
#undef a
}
YY_ACTION(void) yy_1_args(yycontext *yy, char *yytext, int yyleng)
{
#define i yy->__val[-1]
#define a yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_args\n"));
  {
#line 1235
   a = newPair(i, a) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef i
#undef a
}
YY_ACTION(void) yy_1_func(yycontext *yy, char *yytext, int yyleng)
{
#define a yy->__val[-1]
#define i yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_func\n"));
  {
#line 1232
   __ = newCall(a, i, newline); ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef a
#undef i
}
YY_ACTION(void) yy_2_postfix(yycontext *yy, char *yytext, int yyleng)
{
#define i yy->__val[-1]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_postfix\n"));
  {
#line 1227
   __ = newUnyop(ADEC, newGetVar(i,newline),newline) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef i
}
YY_ACTION(void) yy_1_postfix(yycontext *yy, char *yytext, int yyleng)
{
#define i yy->__val[-1]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_postfix\n"));
  {
#line 1226
   __ = newUnyop(AINC, newGetVar(i,newline),newline) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef i
}
YY_ACTION(void) yy_3_prefix(yycontext *yy, char *yytext, int yyleng)
{
#define i yy->__val[-1]
#define x yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_prefix\n"));
  {
#line 1223
   __ = newUnyop(BDEC, newGetVar(i,newline),newline) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef i
#undef x
}
YY_ACTION(void) yy_2_prefix(yycontext *yy, char *yytext, int yyleng)
{
#define i yy->__val[-1]
#define x yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_prefix\n"));
  {
#line 1222
   __ = newUnyop(BINC, newGetVar(i,newline),newline) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef i
#undef x
}
YY_ACTION(void) yy_1_prefix(yycontext *yy, char *yytext, int yyleng)
{
#define i yy->__val[-1]
#define x yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_prefix\n"));
  {
#line 1221
   __ = newUnyop(NEG, x,newline) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef i
#undef x
}
YY_ACTION(void) yy_4_mul(yycontext *yy, char *yytext, int yyleng)
{
#define rhs yy->__val[-1]
#define lhs yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_4_mul\n"));
  {
#line 1219
   __ = lhs ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef rhs
#undef lhs
}
YY_ACTION(void) yy_3_mul(yycontext *yy, char *yytext, int yyleng)
{
#define rhs yy->__val[-1]
#define lhs yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_mul\n"));
  {
#line 1218
   lhs = newBinop(MOD, lhs, rhs,newline) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef rhs
#undef lhs
}
YY_ACTION(void) yy_2_mul(yycontext *yy, char *yytext, int yyleng)
{
#define rhs yy->__val[-1]
#define lhs yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_mul\n"));
  {
#line 1217
   lhs = newBinop(DIV, lhs, rhs,newline) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef rhs
#undef lhs
}
YY_ACTION(void) yy_1_mul(yycontext *yy, char *yytext, int yyleng)
{
#define rhs yy->__val[-1]
#define lhs yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_mul\n"));
  {
#line 1216
   lhs = newBinop(MUL, lhs, rhs,newline) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef rhs
#undef lhs
}
YY_ACTION(void) yy_3_add(yycontext *yy, char *yytext, int yyleng)
{
#define rhs yy->__val[-1]
#define lhs yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_add\n"));
  {
#line 1213
   __ = lhs ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef rhs
#undef lhs
}
YY_ACTION(void) yy_2_add(yycontext *yy, char *yytext, int yyleng)
{
#define rhs yy->__val[-1]
#define lhs yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_add\n"));
  {
#line 1212
   lhs = newBinop(SUB, lhs, rhs,newline) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef rhs
#undef lhs
}
YY_ACTION(void) yy_1_add(yycontext *yy, char *yytext, int yyleng)
{
#define rhs yy->__val[-1]
#define lhs yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_add\n"));
  {
#line 1211
   lhs = newBinop(ADD, lhs, rhs,newline) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef rhs
#undef lhs
}
YY_ACTION(void) yy_5_ineq(yycontext *yy, char *yytext, int yyleng)
{
#define rhs yy->__val[-1]
#define lhs yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_5_ineq\n"));
  {
#line 1208
   __ = lhs ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef rhs
#undef lhs
}
YY_ACTION(void) yy_4_ineq(yycontext *yy, char *yytext, int yyleng)
{
#define rhs yy->__val[-1]
#define lhs yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_4_ineq\n"));
  {
#line 1207
   lhs = newBinop(LT, lhs, rhs,newline) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef rhs
#undef lhs
}
YY_ACTION(void) yy_3_ineq(yycontext *yy, char *yytext, int yyleng)
{
#define rhs yy->__val[-1]
#define lhs yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_ineq\n"));
  {
#line 1206
   lhs = newBinop(LE, lhs, rhs,newline) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef rhs
#undef lhs
}
YY_ACTION(void) yy_2_ineq(yycontext *yy, char *yytext, int yyleng)
{
#define rhs yy->__val[-1]
#define lhs yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_ineq\n"));
  {
#line 1205
   lhs = newBinop(GE, lhs, rhs,newline) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef rhs
#undef lhs
}
YY_ACTION(void) yy_1_ineq(yycontext *yy, char *yytext, int yyleng)
{
#define rhs yy->__val[-1]
#define lhs yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_ineq\n"));
  {
#line 1204
   lhs = newBinop(GT, lhs, rhs,newline) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef rhs
#undef lhs
}
YY_ACTION(void) yy_3_eqop(yycontext *yy, char *yytext, int yyleng)
{
#define rhs yy->__val[-1]
#define lhs yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_eqop\n"));
  {
#line 1202
   __ = lhs ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef rhs
#undef lhs
}
YY_ACTION(void) yy_2_eqop(yycontext *yy, char *yytext, int yyleng)
{
#define rhs yy->__val[-1]
#define lhs yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_eqop\n"));
  {
#line 1201
   lhs = newBinop(NE, lhs, rhs,newline) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef rhs
#undef lhs
}
YY_ACTION(void) yy_1_eqop(yycontext *yy, char *yytext, int yyleng)
{
#define rhs yy->__val[-1]
#define lhs yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_eqop\n"));
  {
#line 1200
   lhs = newBinop(EQ, lhs, rhs,newline) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef rhs
#undef lhs
}
YY_ACTION(void) yy_2_logmul(yycontext *yy, char *yytext, int yyleng)
{
#define rhs yy->__val[-1]
#define lhs yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_logmul\n"));
  {
#line 1197
   __ = lhs ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef rhs
#undef lhs
}
YY_ACTION(void) yy_1_logmul(yycontext *yy, char *yytext, int yyleng)
{
#define rhs yy->__val[-1]
#define lhs yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_logmul\n"));
  {
#line 1197
   lhs = newBinop(AND,lhs,rhs,newline) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef rhs
#undef lhs
}
YY_ACTION(void) yy_2_logadd(yycontext *yy, char *yytext, int yyleng)
{
#define rhs yy->__val[-1]
#define lhs yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_logadd\n"));
  {
#line 1195
   __ = lhs ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef rhs
#undef lhs
}
YY_ACTION(void) yy_1_logadd(yycontext *yy, char *yytext, int yyleng)
{
#define rhs yy->__val[-1]
#define lhs yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_logadd\n"));
  {
#line 1195
   lhs = newBinop(OR,lhs,rhs,newline) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef rhs
#undef lhs
}
YY_ACTION(void) yy_1_mkNil(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_mkNil\n"));
  {
#line 1193
   __ = nil ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_3_params(yycontext *yy, char *yytext, int yyleng)
{
#define i yy->__val[-1]
#define t yy->__val[-2]
#define p yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_params\n"));
  {
#line 1191
   __ = p ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef i
#undef t
#undef p
}
YY_ACTION(void) yy_2_params(yycontext *yy, char *yytext, int yyleng)
{
#define i yy->__val[-1]
#define t yy->__val[-2]
#define p yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_params\n"));
  {
#line 1188
   p = newPair(newPair(t,i), p) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef i
#undef t
#undef p
}
YY_ACTION(void) yy_1_params(yycontext *yy, char *yytext, int yyleng)
{
#define i yy->__val[-1]
#define t yy->__val[-2]
#define p yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_params\n"));
  {
#line 1187
   p = newPair(newPair(t,i), p) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef i
#undef t
#undef p
}
YY_ACTION(void) yy_3_list(yycontext *yy, char *yytext, int yyleng)
{
#define s yy->__val[-1]
#define b yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_list\n"));
  {
#line 1179
   __ = b ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef s
#undef b
}
YY_ACTION(void) yy_2_list(yycontext *yy, char *yytext, int yyleng)
{
#define s yy->__val[-1]
#define b yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_list\n"));
  {
#line 1176
   Block_append(b, s) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef s
#undef b
}
YY_ACTION(void) yy_1_list(yycontext *yy, char *yytext, int yyleng)
{
#define s yy->__val[-1]
#define b yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_list\n"));
  {
#line 1175
   Block_append(b, s) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef s
#undef b
}
YY_ACTION(void) yy_1_bracket(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_bracket\n"));
  {
#line 1168
   printf("[]\n");__ = e ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
}
YY_ACTION(void) yy_6_assign(yycontext *yy, char *yytext, int yyleng)
{
#define b yy->__val[-1]
#define x yy->__val[-2]
#define i yy->__val[-3]
#define t yy->__val[-4]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_6_assign\n"));
  {
#line 1162
   __ = newSetArray(t, i,b, x,newline);;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef b
#undef x
#undef i
#undef t
}
YY_ACTION(void) yy_5_assign(yycontext *yy, char *yytext, int yyleng)
{
#define b yy->__val[-1]
#define x yy->__val[-2]
#define i yy->__val[-3]
#define t yy->__val[-4]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_5_assign\n"));
  {
#line 1160
   __ = newSetVar(t, i, newBinop(DIV,x,newGetVar(i,newline),newline),newline);
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef b
#undef x
#undef i
#undef t
}
YY_ACTION(void) yy_4_assign(yycontext *yy, char *yytext, int yyleng)
{
#define b yy->__val[-1]
#define x yy->__val[-2]
#define i yy->__val[-3]
#define t yy->__val[-4]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_4_assign\n"));
  {
#line 1159
   __ = newSetVar(t, i, newBinop(MUL,x,newGetVar(i,newline),newline),newline);
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef b
#undef x
#undef i
#undef t
}
YY_ACTION(void) yy_3_assign(yycontext *yy, char *yytext, int yyleng)
{
#define b yy->__val[-1]
#define x yy->__val[-2]
#define i yy->__val[-3]
#define t yy->__val[-4]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_assign\n"));
  {
#line 1158
   __ = newSetVar(t, i, newBinop(SUB,x,newGetVar(i,newline),newline),newline);
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef b
#undef x
#undef i
#undef t
}
YY_ACTION(void) yy_2_assign(yycontext *yy, char *yytext, int yyleng)
{
#define b yy->__val[-1]
#define x yy->__val[-2]
#define i yy->__val[-3]
#define t yy->__val[-4]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_assign\n"));
  {
#line 1157
   __ = newSetVar(t, i, newBinop(ADD,x,newGetVar(i,newline),newline),newline);
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef b
#undef x
#undef i
#undef t
}
YY_ACTION(void) yy_1_assign(yycontext *yy, char *yytext, int yyleng)
{
#define b yy->__val[-1]
#define x yy->__val[-2]
#define i yy->__val[-3]
#define t yy->__val[-4]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_assign\n"));
  {
#line 1156
   __ = newSetVar(t, i, x,newline);;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef b
#undef x
#undef i
#undef t
}
YY_ACTION(void) yy_1_mkBlock(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_mkBlock\n"));
  {
#line 1152
   __ = newBlock() ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_2_block(yycontext *yy, char *yytext, int yyleng)
{
#define s yy->__val[-1]
#define b yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_block\n"));
  {
#line 1150
   __ = b ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef s
#undef b
}
YY_ACTION(void) yy_1_block(yycontext *yy, char *yytext, int yyleng)
{
#define s yy->__val[-1]
#define b yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_block\n"));
  {
#line 1148
   Block_append(b, s) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef s
#undef b
}
YY_ACTION(void) yy_2_blocks(yycontext *yy, char *yytext, int yyleng)
{
#define bx yy->__val[-1]
#define b yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_blocks\n"));
  {
#line 1143
  __ = b;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef bx
#undef b
}
YY_ACTION(void) yy_1_blocks(yycontext *yy, char *yytext, int yyleng)
{
#define bx yy->__val[-1]
#define b yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_blocks\n"));
  {
#line 1143
  Block_append(b, bx);
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef bx
#undef b
}
YY_ACTION(void) yy_12_stmt(yycontext *yy, char *yytext, int yyleng)
{
#define u yy->__val[-1]
#define e yy->__val[-2]
#define i yy->__val[-3]
#define s yy->__val[-4]
#define c yy->__val[-5]
#define x yy->__val[-6]
#define t yy->__val[-7]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_12_stmt\n"));
  {
#line 1138
   fatal("line %d syntax error: [%s]",newline, yytext); ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef u
#undef e
#undef i
#undef s
#undef c
#undef x
#undef t
}
YY_ACTION(void) yy_11_stmt(yycontext *yy, char *yytext, int yyleng)
{
#define u yy->__val[-1]
#define e yy->__val[-2]
#define i yy->__val[-3]
#define s yy->__val[-4]
#define c yy->__val[-5]
#define x yy->__val[-6]
#define t yy->__val[-7]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_11_stmt\n"));
  {
#line 1137
   __ = nil ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef u
#undef e
#undef i
#undef s
#undef c
#undef x
#undef t
}
YY_ACTION(void) yy_10_stmt(yycontext *yy, char *yytext, int yyleng)
{
#define u yy->__val[-1]
#define e yy->__val[-2]
#define i yy->__val[-3]
#define s yy->__val[-4]
#define c yy->__val[-5]
#define x yy->__val[-6]
#define t yy->__val[-7]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_10_stmt\n"));
  {
#line 1136
   __ = x  ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef u
#undef e
#undef i
#undef s
#undef c
#undef x
#undef t
}
YY_ACTION(void) yy_9_stmt(yycontext *yy, char *yytext, int yyleng)
{
#define u yy->__val[-1]
#define e yy->__val[-2]
#define i yy->__val[-3]
#define s yy->__val[-4]
#define c yy->__val[-5]
#define x yy->__val[-6]
#define t yy->__val[-7]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_9_stmt\n"));
  {
#line 1135
   __ = newRun(i) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef u
#undef e
#undef i
#undef s
#undef c
#undef x
#undef t
}
YY_ACTION(void) yy_8_stmt(yycontext *yy, char *yytext, int yyleng)
{
#define u yy->__val[-1]
#define e yy->__val[-2]
#define i yy->__val[-3]
#define s yy->__val[-4]
#define c yy->__val[-5]
#define x yy->__val[-6]
#define t yy->__val[-7]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_8_stmt\n"));
  {
#line 1134
   __ = newReturn(e) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef u
#undef e
#undef i
#undef s
#undef c
#undef x
#undef t
}
YY_ACTION(void) yy_7_stmt(yycontext *yy, char *yytext, int yyleng)
{
#define u yy->__val[-1]
#define e yy->__val[-2]
#define i yy->__val[-3]
#define s yy->__val[-4]
#define c yy->__val[-5]
#define x yy->__val[-6]
#define t yy->__val[-7]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_7_stmt\n"));
  {
#line 1133
    __ = newBreak() ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef u
#undef e
#undef i
#undef s
#undef c
#undef x
#undef t
}
YY_ACTION(void) yy_6_stmt(yycontext *yy, char *yytext, int yyleng)
{
#define u yy->__val[-1]
#define e yy->__val[-2]
#define i yy->__val[-3]
#define s yy->__val[-4]
#define c yy->__val[-5]
#define x yy->__val[-6]
#define t yy->__val[-7]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_6_stmt\n"));
  {
#line 1132
   __ = newContinue() ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef u
#undef e
#undef i
#undef s
#undef c
#undef x
#undef t
}
YY_ACTION(void) yy_5_stmt(yycontext *yy, char *yytext, int yyleng)
{
#define u yy->__val[-1]
#define e yy->__val[-2]
#define i yy->__val[-3]
#define s yy->__val[-4]
#define c yy->__val[-5]
#define x yy->__val[-6]
#define t yy->__val[-7]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_5_stmt\n"));
  {
#line 1131
   __ = newFor(i,e,u,s) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef u
#undef e
#undef i
#undef s
#undef c
#undef x
#undef t
}
YY_ACTION(void) yy_4_stmt(yycontext *yy, char *yytext, int yyleng)
{
#define u yy->__val[-1]
#define e yy->__val[-2]
#define i yy->__val[-3]
#define s yy->__val[-4]
#define c yy->__val[-5]
#define x yy->__val[-6]
#define t yy->__val[-7]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_4_stmt\n"));
  {
#line 1130
   __ = newWhile(c, s) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef u
#undef e
#undef i
#undef s
#undef c
#undef x
#undef t
}
YY_ACTION(void) yy_3_stmt(yycontext *yy, char *yytext, int yyleng)
{
#define u yy->__val[-1]
#define e yy->__val[-2]
#define i yy->__val[-3]
#define s yy->__val[-4]
#define c yy->__val[-5]
#define x yy->__val[-6]
#define t yy->__val[-7]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_stmt\n"));
  {
#line 1129
   __ = newIf(c, s, sys_false) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef u
#undef e
#undef i
#undef s
#undef c
#undef x
#undef t
}
YY_ACTION(void) yy_2_stmt(yycontext *yy, char *yytext, int yyleng)
{
#define u yy->__val[-1]
#define e yy->__val[-2]
#define i yy->__val[-3]
#define s yy->__val[-4]
#define c yy->__val[-5]
#define x yy->__val[-6]
#define t yy->__val[-7]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_stmt\n"));
  {
#line 1128
   __ = newIf(c, s, t) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef u
#undef e
#undef i
#undef s
#undef c
#undef x
#undef t
}
YY_ACTION(void) yy_1_stmt(yycontext *yy, char *yytext, int yyleng)
{
#define u yy->__val[-1]
#define e yy->__val[-2]
#define i yy->__val[-3]
#define s yy->__val[-4]
#define c yy->__val[-5]
#define x yy->__val[-6]
#define t yy->__val[-7]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_stmt\n"));
  {
#line 1126
   __ =  newPrint(x,t); ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef u
#undef e
#undef i
#undef s
#undef c
#undef x
#undef t
}
YY_ACTION(void) yy_3_event(yycontext *yy, char *yytext, int yyleng)
{
#define x yy->__val[-1]
#define t yy->__val[-2]
#define b yy->__val[-3]
#define p yy->__val[-4]
#define i yy->__val[-5]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_event\n"));
  {
#line 1124
   __ = newSetArray(t,i,b,x,newline); ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef x
#undef t
#undef b
#undef p
#undef i
}
YY_ACTION(void) yy_2_event(yycontext *yy, char *yytext, int yyleng)
{
#define x yy->__val[-1]
#define t yy->__val[-2]
#define b yy->__val[-3]
#define p yy->__val[-4]
#define i yy->__val[-5]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_event\n"));
  {
#line 1123
   __ = newSetVar(t, i, x,newline);;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef x
#undef t
#undef b
#undef p
#undef i
}
YY_ACTION(void) yy_1_event(yycontext *yy, char *yytext, int yyleng)
{
#define x yy->__val[-1]
#define t yy->__val[-2]
#define b yy->__val[-3]
#define p yy->__val[-4]
#define i yy->__val[-5]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_event\n"));
  {
#line 1122
   __ = newEvent(i,p,b) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef x
#undef t
#undef b
#undef p
#undef i
}
YY_ACTION(void) yy_1_mkState(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_mkState\n"));
  {
#line 1120
   __ = newState() ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_2_state(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define s yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_state\n"));
  {
#line 1118
   __ = s ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef s
}
YY_ACTION(void) yy_1_state(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define s yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_state\n"));
  {
#line 1116
   State_append(s, e) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef s
}
YY_ACTION(void) yy_7_define(yycontext *yy, char *yytext, int yyleng)
{
#define x yy->__val[-1]
#define p yy->__val[-2]
#define d yy->__val[-3]
#define s yy->__val[-4]
#define i yy->__val[-5]
#define t yy->__val[-6]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_7_define\n"));
  {
#line 1111
   fatal("line %d syntax error: [%s]",newline, yytext); ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef x
#undef p
#undef d
#undef s
#undef i
#undef t
}
YY_ACTION(void) yy_6_define(yycontext *yy, char *yytext, int yyleng)
{
#define x yy->__val[-1]
#define p yy->__val[-2]
#define d yy->__val[-3]
#define s yy->__val[-4]
#define i yy->__val[-5]
#define t yy->__val[-6]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_6_define\n"));
  {
#line 1110
   __ = newEND() ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef x
#undef p
#undef d
#undef s
#undef i
#undef t
}
YY_ACTION(void) yy_5_define(yycontext *yy, char *yytext, int yyleng)
{
#define x yy->__val[-1]
#define p yy->__val[-2]
#define d yy->__val[-3]
#define s yy->__val[-4]
#define i yy->__val[-5]
#define t yy->__val[-6]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_5_define\n"));
  {
#line 1109
   __ = newRun(newGetVar(i,newline)) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef x
#undef p
#undef d
#undef s
#undef i
#undef t
}
YY_ACTION(void) yy_4_define(yycontext *yy, char *yytext, int yyleng)
{
#define x yy->__val[-1]
#define p yy->__val[-2]
#define d yy->__val[-3]
#define s yy->__val[-4]
#define i yy->__val[-5]
#define t yy->__val[-6]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_4_define\n"));
  {
#line 1108
   __ = newSetVarG(t, i, x,newline);;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef x
#undef p
#undef d
#undef s
#undef i
#undef t
}
YY_ACTION(void) yy_3_define(yycontext *yy, char *yytext, int yyleng)
{
#define x yy->__val[-1]
#define p yy->__val[-2]
#define d yy->__val[-3]
#define s yy->__val[-4]
#define i yy->__val[-5]
#define t yy->__val[-6]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_define\n"));
  {
#line 1107
   __ = newSetVar(t,i,newFunction(p,s),newline) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef x
#undef p
#undef d
#undef s
#undef i
#undef t
}
YY_ACTION(void) yy_2_define(yycontext *yy, char *yytext, int yyleng)
{
#define x yy->__val[-1]
#define p yy->__val[-2]
#define d yy->__val[-3]
#define s yy->__val[-4]
#define i yy->__val[-5]
#define t yy->__val[-6]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_define\n"));
  {
#line 1106
   result = d ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef x
#undef p
#undef d
#undef s
#undef i
#undef t
}
YY_ACTION(void) yy_1_define(yycontext *yy, char *yytext, int yyleng)
{
#define x yy->__val[-1]
#define p yy->__val[-2]
#define d yy->__val[-3]
#define s yy->__val[-4]
#define i yy->__val[-5]
#define t yy->__val[-6]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_define\n"));
  {
#line 1105
   __ = newSetVar(t,i,s,newline)  ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef x
#undef p
#undef d
#undef s
#undef i
#undef t
}
YY_ACTION(void) yy_1_start(yycontext *yy, char *yytext, int yyleng)
{
#define d yy->__val[-1]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_start\n"));
  {
#line 1103
   result = d ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef d
}

YY_RULE(int) yy_blank(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "blank"));
  {  int yypos2= yy->__pos, yythunkpos2= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\042\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l3;  goto l2;
  l3:;	  yy->__pos= yypos2; yy->__thunkpos= yythunkpos2;  if (!yy_NLINE(yy)) goto l4;  goto l2;
  l4:;	  yy->__pos= yypos2; yy->__thunkpos= yythunkpos2;  if (!yymatchString(yy, "//")) goto l1;
  l5:;	
  {  int yypos6= yy->__pos, yythunkpos6= yy->__thunkpos;
  {  int yypos7= yy->__pos, yythunkpos7= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\044\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l7;  goto l6;
  l7:;	  yy->__pos= yypos7; yy->__thunkpos= yythunkpos7;
  }  if (!yymatchDot(yy)) goto l6;  goto l5;
  l6:;	  yy->__pos= yypos6; yy->__thunkpos= yythunkpos6;
  }
  }
  l2:;	
  yyprintf((stderr, "  ok   %s @ %s\n", "blank", yy->__buf+yy->__pos));
  return 1;
  l1:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "blank", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_space(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "space"));
  {  int yypos9= yy->__pos, yythunkpos9= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\002\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l10;  goto l9;
  l10:;	  yy->__pos= yypos9; yy->__thunkpos= yythunkpos9;  if (!yymatchString(yy, "//")) goto l8;
  l11:;	
  {  int yypos12= yy->__pos, yythunkpos12= yy->__thunkpos;
  {  int yypos13= yy->__pos, yythunkpos13= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\044\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l13;  goto l12;
  l13:;	  yy->__pos= yypos13; yy->__thunkpos= yythunkpos13;
  }  if (!yymatchDot(yy)) goto l12;  goto l11;
  l12:;	  yy->__pos= yypos12; yy->__thunkpos= yythunkpos12;
  }
  }
  l9:;	
  yyprintf((stderr, "  ok   %s @ %s\n", "space", yy->__buf+yy->__pos));
  return 1;
  l8:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "space", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_alnum(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "alnum"));
  {  int yypos15= yy->__pos, yythunkpos15= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\376\377\377\207\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l16;  goto l15;
  l16:;	  yy->__pos= yypos15; yy->__thunkpos= yythunkpos15;  if (!yymatchChar(yy, '_')) goto l14;
  }
  l15:;	
  yyprintf((stderr, "  ok   %s @ %s\n", "alnum", yy->__buf+yy->__pos));
  return 1;
  l14:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "alnum", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_alpha(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "alpha"));  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\000\000\376\377\377\207\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l17;
  yyprintf((stderr, "  ok   %s @ %s\n", "alpha", yy->__buf+yy->__pos));
  return 1;
  l17:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "alpha", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_expnt(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "expnt"));  if (!yymatchChar(yy, 'e')) goto l18;
  {  int yypos19= yy->__pos, yythunkpos19= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\050\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l19;  goto l20;
  l19:;	  yy->__pos= yypos19; yy->__thunkpos= yythunkpos19;
  }
  l20:;	  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l18;
  l21:;	
  {  int yypos22= yy->__pos, yythunkpos22= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l22;  goto l21;
  l22:;	  yy->__pos= yypos22; yy->__thunkpos= yythunkpos22;
  }
  yyprintf((stderr, "  ok   %s @ %s\n", "expnt", yy->__buf+yy->__pos));
  return 1;
  l18:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "expnt", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_integer(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "integer"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l23;
#undef yytext
#undef yyleng
  }  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l23;
  l24:;	
  {  int yypos25= yy->__pos, yythunkpos25= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l25;  goto l24;
  l25:;	  yy->__pos= yypos25; yy->__thunkpos= yythunkpos25;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l23;
#undef yytext
#undef yyleng
  }  if (!yy__(yy)) goto l23;  yyDo(yy, yy_1_integer, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "integer", yy->__buf+yy->__pos));
  return 1;
  l23:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "integer", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_float_(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "float_"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l26;
#undef yytext
#undef yyleng
  }
  {  int yypos27= yy->__pos, yythunkpos27= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l28;
  l29:;	
  {  int yypos30= yy->__pos, yythunkpos30= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l30;  goto l29;
  l30:;	  yy->__pos= yypos30; yy->__thunkpos= yythunkpos30;
  }  if (!yy_expnt(yy)) goto l28;  goto l27;
  l28:;	  yy->__pos= yypos27; yy->__thunkpos= yythunkpos27;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l31;
  l32:;	
  {  int yypos33= yy->__pos, yythunkpos33= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l33;  goto l32;
  l33:;	  yy->__pos= yypos33; yy->__thunkpos= yythunkpos33;
  }  if (!yymatchChar(yy, '.')) goto l31;
  l34:;	
  {  int yypos35= yy->__pos, yythunkpos35= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l35;  goto l34;
  l35:;	  yy->__pos= yypos35; yy->__thunkpos= yythunkpos35;
  }
  {  int yypos36= yy->__pos, yythunkpos36= yy->__thunkpos;  if (!yy_expnt(yy)) goto l36;  goto l37;
  l36:;	  yy->__pos= yypos36; yy->__thunkpos= yythunkpos36;
  }
  l37:;	  goto l27;
  l31:;	  yy->__pos= yypos27; yy->__thunkpos= yythunkpos27;
  l38:;	
  {  int yypos39= yy->__pos, yythunkpos39= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l39;  goto l38;
  l39:;	  yy->__pos= yypos39; yy->__thunkpos= yythunkpos39;
  }  if (!yymatchChar(yy, '.')) goto l26;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l26;
  l40:;	
  {  int yypos41= yy->__pos, yythunkpos41= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l41;  goto l40;
  l41:;	  yy->__pos= yypos41; yy->__thunkpos= yythunkpos41;
  }
  {  int yypos42= yy->__pos, yythunkpos42= yy->__thunkpos;  if (!yy_expnt(yy)) goto l42;  goto l43;
  l42:;	  yy->__pos= yypos42; yy->__thunkpos= yythunkpos42;
  }
  l43:;	
  }
  l27:;	  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l26;
#undef yytext
#undef yyleng
  }  if (!yy__(yy)) goto l26;  yyDo(yy, yy_1_float_, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "float_", yy->__buf+yy->__pos));
  return 1;
  l26:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "float_", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_string(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "string"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l44;
#undef yytext
#undef yyleng
  }
  l45:;	
  {  int yypos46= yy->__pos, yythunkpos46= yy->__thunkpos;
  {  int yypos47= yy->__pos, yythunkpos47= yy->__thunkpos;  if (!yymatchChar(yy, '\"')) goto l47;  goto l46;
  l47:;	  yy->__pos= yypos47; yy->__thunkpos= yythunkpos47;
  }  if (!yymatchDot(yy)) goto l46;  goto l45;
  l46:;	  yy->__pos= yypos46; yy->__thunkpos= yythunkpos46;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l44;
#undef yytext
#undef yyleng
  }  if (!yy__(yy)) goto l44;  yyDo(yy, yy_1_string, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "string", yy->__buf+yy->__pos));
  return 1;
  l44:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "string", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_DQUOTE(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "DQUOTE"));  if (!yymatchChar(yy, '\"')) goto l48;
  yyprintf((stderr, "  ok   %s @ %s\n", "DQUOTE", yy->__buf+yy->__pos));
  return 1;
  l48:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "DQUOTE", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_character(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "character"));  if (!yy_alpha(yy)) goto l49;  yyDo(yy, yy_1_character, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "character", yy->__buf+yy->__pos));
  return 1;
  l49:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "character", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_QUOTE(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "QUOTE"));  if (!yymatchChar(yy, '\'')) goto l50;
  yyprintf((stderr, "  ok   %s @ %s\n", "QUOTE", yy->__buf+yy->__pos));
  return 1;
  l50:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "QUOTE", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_args(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 2, 0);
  yyprintf((stderr, "%s\n", "args"));  if (!yy_LPAR(yy)) goto l51;  if (!yy_mkNil(yy)) goto l51;  yyDo(yy, yySet, -2, 0);
  {  int yypos52= yy->__pos, yythunkpos52= yy->__thunkpos;  if (!yy_exp(yy)) goto l52;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_args, yy->__begin, yy->__end);
  l54:;	
  {  int yypos55= yy->__pos, yythunkpos55= yy->__thunkpos;  if (!yy_COMMA(yy)) goto l55;  if (!yy_exp(yy)) goto l55;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_2_args, yy->__begin, yy->__end);  goto l54;
  l55:;	  yy->__pos= yypos55; yy->__thunkpos= yythunkpos55;
  }  goto l53;
  l52:;	  yy->__pos= yypos52; yy->__thunkpos= yythunkpos52;
  }
  l53:;	  if (!yy_RPAR(yy)) goto l51;  yyDo(yy, yy_3_args, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "args", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 2, 0);
  return 1;
  l51:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "args", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_postfix(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 1, 0);
  yyprintf((stderr, "%s\n", "postfix"));
  {  int yypos57= yy->__pos, yythunkpos57= yy->__thunkpos;  if (!yy_id(yy)) goto l58;  yyDo(yy, yySet, -1, 0);  if (!yy_INCRE(yy)) goto l58;  if (!yy__(yy)) goto l58;  yyDo(yy, yy_1_postfix, yy->__begin, yy->__end);  goto l57;
  l58:;	  yy->__pos= yypos57; yy->__thunkpos= yythunkpos57;  if (!yy_id(yy)) goto l59;  yyDo(yy, yySet, -1, 0);  if (!yy_DECRE(yy)) goto l59;  if (!yy__(yy)) goto l59;  yyDo(yy, yy_2_postfix, yy->__begin, yy->__end);  goto l57;
  l59:;	  yy->__pos= yypos57; yy->__thunkpos= yythunkpos57;  if (!yy_func(yy)) goto l60;  goto l57;
  l60:;	  yy->__pos= yypos57; yy->__thunkpos= yythunkpos57;  if (!yy_value(yy)) goto l56;
  }
  l57:;	
  yyprintf((stderr, "  ok   %s @ %s\n", "postfix", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 1, 0);
  return 1;
  l56:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "postfix", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_DECRE(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "DECRE"));  if (!yymatchString(yy, "--")) goto l61;
  yyprintf((stderr, "  ok   %s @ %s\n", "DECRE", yy->__buf+yy->__pos));
  return 1;
  l61:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "DECRE", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_INCRE(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "INCRE"));  if (!yymatchString(yy, "++")) goto l62;
  yyprintf((stderr, "  ok   %s @ %s\n", "INCRE", yy->__buf+yy->__pos));
  return 1;
  l62:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "INCRE", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_value(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 2, 0);
  yyprintf((stderr, "%s\n", "value"));
  {  int yypos64= yy->__pos, yythunkpos64= yy->__thunkpos;  if (!yy_LPAR(yy)) goto l65;  if (!yy_add(yy)) goto l65;  yyDo(yy, yySet, -2, 0);  if (!yy_RPAR(yy)) goto l65;  yyDo(yy, yy_1_value, yy->__begin, yy->__end);  goto l64;
  l65:;	  yy->__pos= yypos64; yy->__thunkpos= yythunkpos64;  if (!yy_QUOTE(yy)) goto l66;  if (!yy_character(yy)) goto l66;  if (!yy_QUOTE(yy)) goto l66;  if (!yy__(yy)) goto l66;  goto l64;
  l66:;	  yy->__pos= yypos64; yy->__thunkpos= yythunkpos64;  if (!yy_DQUOTE(yy)) goto l67;  if (!yy_string(yy)) goto l67;  if (!yy_DQUOTE(yy)) goto l67;  if (!yy__(yy)) goto l67;  goto l64;
  l67:;	  yy->__pos= yypos64; yy->__thunkpos= yythunkpos64;  if (!yy_float_(yy)) goto l68;  goto l64;
  l68:;	  yy->__pos= yypos64; yy->__thunkpos= yythunkpos64;  if (!yy_integer(yy)) goto l69;  goto l64;
  l69:;	  yy->__pos= yypos64; yy->__thunkpos= yythunkpos64;  if (!yy_id(yy)) goto l63;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_2_value, yy->__begin, yy->__end);
  }
  l64:;	
  yyprintf((stderr, "  ok   %s @ %s\n", "value", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 2, 0);
  return 1;
  l63:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "value", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_PCENT(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "PCENT"));  if (!yymatchChar(yy, '%')) goto l70;  if (!yy__(yy)) goto l70;
  yyprintf((stderr, "  ok   %s @ %s\n", "PCENT", yy->__buf+yy->__pos));
  return 1;
  l70:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "PCENT", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_SLASH(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "SLASH"));  if (!yymatchChar(yy, '/')) goto l71;  if (!yy__(yy)) goto l71;
  yyprintf((stderr, "  ok   %s @ %s\n", "SLASH", yy->__buf+yy->__pos));
  return 1;
  l71:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "SLASH", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_STAR(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "STAR"));  if (!yymatchChar(yy, '*')) goto l72;  if (!yy__(yy)) goto l72;
  yyprintf((stderr, "  ok   %s @ %s\n", "STAR", yy->__buf+yy->__pos));
  return 1;
  l72:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "STAR", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_prefix(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 2, 0);
  yyprintf((stderr, "%s\n", "prefix"));
  {  int yypos74= yy->__pos, yythunkpos74= yy->__thunkpos;  if (!yy_MINUS(yy)) goto l75;  if (!yy_value(yy)) goto l75;  yyDo(yy, yySet, -2, 0);  yyDo(yy, yy_1_prefix, yy->__begin, yy->__end);  goto l74;
  l75:;	  yy->__pos= yypos74; yy->__thunkpos= yythunkpos74;  if (!yy_INCRE(yy)) goto l76;  if (!yy_id(yy)) goto l76;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_2_prefix, yy->__begin, yy->__end);  goto l74;
  l76:;	  yy->__pos= yypos74; yy->__thunkpos= yythunkpos74;  if (!yy_DECRE(yy)) goto l77;  if (!yy_id(yy)) goto l77;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_3_prefix, yy->__begin, yy->__end);  goto l74;
  l77:;	  yy->__pos= yypos74; yy->__thunkpos= yythunkpos74;  if (!yy_postfix(yy)) goto l73;
  }
  l74:;	
  yyprintf((stderr, "  ok   %s @ %s\n", "prefix", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 2, 0);
  return 1;
  l73:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "prefix", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_MINUS(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "MINUS"));  if (!yymatchChar(yy, '-')) goto l78;  if (!yy__(yy)) goto l78;
  yyprintf((stderr, "  ok   %s @ %s\n", "MINUS", yy->__buf+yy->__pos));
  return 1;
  l78:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "MINUS", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_PLURS(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "PLURS"));  if (!yymatchChar(yy, '+')) goto l79;  if (!yy__(yy)) goto l79;
  yyprintf((stderr, "  ok   %s @ %s\n", "PLURS", yy->__buf+yy->__pos));
  return 1;
  l79:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "PLURS", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_mul(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 2, 0);
  yyprintf((stderr, "%s\n", "mul"));  if (!yy_prefix(yy)) goto l80;  yyDo(yy, yySet, -2, 0);
  l81:;	
  {  int yypos82= yy->__pos, yythunkpos82= yy->__thunkpos;
  {  int yypos83= yy->__pos, yythunkpos83= yy->__thunkpos;  if (!yy_STAR(yy)) goto l84;  if (!yy_prefix(yy)) goto l84;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_mul, yy->__begin, yy->__end);  goto l83;
  l84:;	  yy->__pos= yypos83; yy->__thunkpos= yythunkpos83;  if (!yy_SLASH(yy)) goto l85;  if (!yy_prefix(yy)) goto l85;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_2_mul, yy->__begin, yy->__end);  goto l83;
  l85:;	  yy->__pos= yypos83; yy->__thunkpos= yythunkpos83;  if (!yy_PCENT(yy)) goto l82;  if (!yy_prefix(yy)) goto l82;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_3_mul, yy->__begin, yy->__end);
  }
  l83:;	  goto l81;
  l82:;	  yy->__pos= yypos82; yy->__thunkpos= yythunkpos82;
  }  yyDo(yy, yy_4_mul, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "mul", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 2, 0);
  return 1;
  l80:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "mul", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_LESS(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "LESS"));  if (!yymatchChar(yy, '<')) goto l86;
  {  int yypos87= yy->__pos, yythunkpos87= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\000\060\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l87;  goto l86;
  l87:;	  yy->__pos= yypos87; yy->__thunkpos= yythunkpos87;
  }  if (!yy__(yy)) goto l86;
  yyprintf((stderr, "  ok   %s @ %s\n", "LESS", yy->__buf+yy->__pos));
  return 1;
  l86:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "LESS", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_LESSEQ(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "LESSEQ"));  if (!yymatchString(yy, "<=")) goto l88;  if (!yy__(yy)) goto l88;
  yyprintf((stderr, "  ok   %s @ %s\n", "LESSEQ", yy->__buf+yy->__pos));
  return 1;
  l88:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "LESSEQ", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_GREATEQ(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "GREATEQ"));  if (!yymatchString(yy, ">=")) goto l89;  if (!yy__(yy)) goto l89;
  yyprintf((stderr, "  ok   %s @ %s\n", "GREATEQ", yy->__buf+yy->__pos));
  return 1;
  l89:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "GREATEQ", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_GREATER(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "GREATER"));  if (!yymatchChar(yy, '>')) goto l90;
  {  int yypos91= yy->__pos, yythunkpos91= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\000\140\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l91;  goto l90;
  l91:;	  yy->__pos= yypos91; yy->__thunkpos= yythunkpos91;
  }  if (!yy__(yy)) goto l90;
  yyprintf((stderr, "  ok   %s @ %s\n", "GREATER", yy->__buf+yy->__pos));
  return 1;
  l90:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "GREATER", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_add(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 2, 0);
  yyprintf((stderr, "%s\n", "add"));  if (!yy_mul(yy)) goto l92;  yyDo(yy, yySet, -2, 0);
  l93:;	
  {  int yypos94= yy->__pos, yythunkpos94= yy->__thunkpos;
  {  int yypos95= yy->__pos, yythunkpos95= yy->__thunkpos;  if (!yy_PLURS(yy)) goto l96;  if (!yy_mul(yy)) goto l96;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_add, yy->__begin, yy->__end);  goto l95;
  l96:;	  yy->__pos= yypos95; yy->__thunkpos= yythunkpos95;  if (!yy_MINUS(yy)) goto l94;  if (!yy_mul(yy)) goto l94;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_2_add, yy->__begin, yy->__end);
  }
  l95:;	  goto l93;
  l94:;	  yy->__pos= yypos94; yy->__thunkpos= yythunkpos94;
  }  yyDo(yy, yy_3_add, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "add", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 2, 0);
  return 1;
  l92:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "add", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_NOTEQ(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "NOTEQ"));  if (!yymatchString(yy, "!=")) goto l97;  if (!yy__(yy)) goto l97;
  yyprintf((stderr, "  ok   %s @ %s\n", "NOTEQ", yy->__buf+yy->__pos));
  return 1;
  l97:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "NOTEQ", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_EQUAL(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "EQUAL"));  if (!yymatchString(yy, "==")) goto l98;  if (!yy__(yy)) goto l98;
  yyprintf((stderr, "  ok   %s @ %s\n", "EQUAL", yy->__buf+yy->__pos));
  return 1;
  l98:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "EQUAL", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_ineq(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 2, 0);
  yyprintf((stderr, "%s\n", "ineq"));  if (!yy_add(yy)) goto l99;  yyDo(yy, yySet, -2, 0);
  l100:;	
  {  int yypos101= yy->__pos, yythunkpos101= yy->__thunkpos;
  {  int yypos102= yy->__pos, yythunkpos102= yy->__thunkpos;  if (!yy_GREATER(yy)) goto l103;  if (!yy_add(yy)) goto l103;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_ineq, yy->__begin, yy->__end);  goto l102;
  l103:;	  yy->__pos= yypos102; yy->__thunkpos= yythunkpos102;  if (!yy_GREATEQ(yy)) goto l104;  if (!yy_add(yy)) goto l104;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_2_ineq, yy->__begin, yy->__end);  goto l102;
  l104:;	  yy->__pos= yypos102; yy->__thunkpos= yythunkpos102;  if (!yy_LESSEQ(yy)) goto l105;  if (!yy_add(yy)) goto l105;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_3_ineq, yy->__begin, yy->__end);  goto l102;
  l105:;	  yy->__pos= yypos102; yy->__thunkpos= yythunkpos102;  if (!yy_LESS(yy)) goto l101;  if (!yy_add(yy)) goto l101;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_4_ineq, yy->__begin, yy->__end);
  }
  l102:;	  goto l100;
  l101:;	  yy->__pos= yypos101; yy->__thunkpos= yythunkpos101;
  }  yyDo(yy, yy_5_ineq, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "ineq", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 2, 0);
  return 1;
  l99:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "ineq", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_LOGAND(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "LOGAND"));  if (!yymatchString(yy, "&&")) goto l106;  if (!yy__(yy)) goto l106;
  yyprintf((stderr, "  ok   %s @ %s\n", "LOGAND", yy->__buf+yy->__pos));
  return 1;
  l106:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "LOGAND", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_eqop(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 2, 0);
  yyprintf((stderr, "%s\n", "eqop"));  if (!yy_ineq(yy)) goto l107;  yyDo(yy, yySet, -2, 0);
  l108:;	
  {  int yypos109= yy->__pos, yythunkpos109= yy->__thunkpos;
  {  int yypos110= yy->__pos, yythunkpos110= yy->__thunkpos;  if (!yy_EQUAL(yy)) goto l111;  if (!yy_ineq(yy)) goto l111;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_eqop, yy->__begin, yy->__end);  goto l110;
  l111:;	  yy->__pos= yypos110; yy->__thunkpos= yythunkpos110;  if (!yy_NOTEQ(yy)) goto l109;  if (!yy_ineq(yy)) goto l109;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_2_eqop, yy->__begin, yy->__end);
  }
  l110:;	  goto l108;
  l109:;	  yy->__pos= yypos109; yy->__thunkpos= yythunkpos109;
  }  yyDo(yy, yy_3_eqop, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "eqop", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 2, 0);
  return 1;
  l107:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "eqop", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_LOGOR(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "LOGOR"));  if (!yymatchString(yy, "||")) goto l112;  if (!yy__(yy)) goto l112;
  yyprintf((stderr, "  ok   %s @ %s\n", "LOGOR", yy->__buf+yy->__pos));
  return 1;
  l112:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "LOGOR", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_logmul(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 2, 0);
  yyprintf((stderr, "%s\n", "logmul"));  if (!yy_eqop(yy)) goto l113;  yyDo(yy, yySet, -2, 0);
  l114:;	
  {  int yypos115= yy->__pos, yythunkpos115= yy->__thunkpos;  if (!yy_LOGAND(yy)) goto l115;  if (!yy_eqop(yy)) goto l115;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_logmul, yy->__begin, yy->__end);  goto l114;
  l115:;	  yy->__pos= yypos115; yy->__thunkpos= yythunkpos115;
  }  yyDo(yy, yy_2_logmul, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "logmul", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 2, 0);
  return 1;
  l113:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "logmul", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_logadd(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 2, 0);
  yyprintf((stderr, "%s\n", "logadd"));  if (!yy_logmul(yy)) goto l116;  yyDo(yy, yySet, -2, 0);
  l117:;	
  {  int yypos118= yy->__pos, yythunkpos118= yy->__thunkpos;  if (!yy_LOGOR(yy)) goto l118;  if (!yy_logmul(yy)) goto l118;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_logadd, yy->__begin, yy->__end);  goto l117;
  l118:;	  yy->__pos= yypos118; yy->__thunkpos= yythunkpos118;
  }  yyDo(yy, yy_2_logadd, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "logadd", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 2, 0);
  return 1;
  l116:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "logadd", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_RSQP(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "RSQP"));  if (!yymatchChar(yy, ']')) goto l119;  if (!yy__(yy)) goto l119;
  yyprintf((stderr, "  ok   %s @ %s\n", "RSQP", yy->__buf+yy->__pos));
  return 1;
  l119:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "RSQP", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_LSQP(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "LSQP"));  if (!yymatchChar(yy, '[')) goto l120;  if (!yy__(yy)) goto l120;
  yyprintf((stderr, "  ok   %s @ %s\n", "LSQP", yy->__buf+yy->__pos));
  return 1;
  l120:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "LSQP", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_func(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 2, 0);
  yyprintf((stderr, "%s\n", "func"));  if (!yy_id(yy)) goto l121;  yyDo(yy, yySet, -2, 0);  if (!yy_args(yy)) goto l121;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_func, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "func", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 2, 0);
  return 1;
  l121:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "func", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_DIVEQU(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "DIVEQU"));  if (!yymatchString(yy, "/=")) goto l122;  if (!yy__(yy)) goto l122;
  yyprintf((stderr, "  ok   %s @ %s\n", "DIVEQU", yy->__buf+yy->__pos));
  return 1;
  l122:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "DIVEQU", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_MULEQU(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "MULEQU"));  if (!yymatchString(yy, "*=")) goto l123;  if (!yy__(yy)) goto l123;
  yyprintf((stderr, "  ok   %s @ %s\n", "MULEQU", yy->__buf+yy->__pos));
  return 1;
  l123:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "MULEQU", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_SUBEQU(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "SUBEQU"));  if (!yymatchString(yy, "-=")) goto l124;  if (!yy__(yy)) goto l124;
  yyprintf((stderr, "  ok   %s @ %s\n", "SUBEQU", yy->__buf+yy->__pos));
  return 1;
  l124:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "SUBEQU", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_ADDEQU(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "ADDEQU"));  if (!yymatchString(yy, "+=")) goto l125;  if (!yy__(yy)) goto l125;
  yyprintf((stderr, "  ok   %s @ %s\n", "ADDEQU", yy->__buf+yy->__pos));
  return 1;
  l125:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "ADDEQU", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_assign(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 4, 0);
  yyprintf((stderr, "%s\n", "assign"));
  {  int yypos127= yy->__pos, yythunkpos127= yy->__thunkpos;
  {  int yypos129= yy->__pos, yythunkpos129= yy->__thunkpos;  if (!yy_TYPE(yy)) goto l130;  yyDo(yy, yySet, -4, 0);  goto l129;
  l130:;	  yy->__pos= yypos129; yy->__thunkpos= yythunkpos129;  if (!yy_mkNil(yy)) goto l128;  yyDo(yy, yySet, -4, 0);
  }
  l129:;	  if (!yy_id(yy)) goto l128;  yyDo(yy, yySet, -3, 0);
  {  int yypos131= yy->__pos, yythunkpos131= yy->__thunkpos;  if (!yy_ASSIGN(yy)) goto l132;  if (!yy_exp(yy)) goto l132;  yyDo(yy, yySet, -2, 0);  yyDo(yy, yy_1_assign, yy->__begin, yy->__end);  goto l131;
  l132:;	  yy->__pos= yypos131; yy->__thunkpos= yythunkpos131;  if (!yy_ADDEQU(yy)) goto l133;  if (!yy_exp(yy)) goto l133;  yyDo(yy, yySet, -2, 0);  yyDo(yy, yy_2_assign, yy->__begin, yy->__end);  goto l131;
  l133:;	  yy->__pos= yypos131; yy->__thunkpos= yythunkpos131;  if (!yy_SUBEQU(yy)) goto l134;  if (!yy_exp(yy)) goto l134;  yyDo(yy, yySet, -2, 0);  yyDo(yy, yy_3_assign, yy->__begin, yy->__end);  goto l131;
  l134:;	  yy->__pos= yypos131; yy->__thunkpos= yythunkpos131;  if (!yy_MULEQU(yy)) goto l135;  if (!yy_exp(yy)) goto l135;  yyDo(yy, yySet, -2, 0);  yyDo(yy, yy_4_assign, yy->__begin, yy->__end);  goto l131;
  l135:;	  yy->__pos= yypos131; yy->__thunkpos= yythunkpos131;  if (!yy_DIVEQU(yy)) goto l128;  if (!yy_exp(yy)) goto l128;  yyDo(yy, yySet, -2, 0);  yyDo(yy, yy_5_assign, yy->__begin, yy->__end);
  }
  l131:;	  goto l127;
  l128:;	  yy->__pos= yypos127; yy->__thunkpos= yythunkpos127;
  {  int yypos137= yy->__pos, yythunkpos137= yy->__thunkpos;  if (!yy_TYPE(yy)) goto l138;  yyDo(yy, yySet, -4, 0);  goto l137;
  l138:;	  yy->__pos= yypos137; yy->__thunkpos= yythunkpos137;  if (!yy_mkNil(yy)) goto l136;  yyDo(yy, yySet, -4, 0);
  }
  l137:;	  if (!yy_id(yy)) goto l136;  yyDo(yy, yySet, -3, 0);  if (!yy_bracket(yy)) goto l136;  yyDo(yy, yySet, -1, 0);  if (!yy_ASSIGN(yy)) goto l136;
  {  int yypos139= yy->__pos, yythunkpos139= yy->__thunkpos;  if (!yy_list(yy)) goto l140;  yyDo(yy, yySet, -2, 0);  goto l139;
  l140:;	  yy->__pos= yypos139; yy->__thunkpos= yythunkpos139;  if (!yy_exp(yy)) goto l136;  yyDo(yy, yySet, -2, 0);
  }
  l139:;	  yyDo(yy, yy_6_assign, yy->__begin, yy->__end);  goto l127;
  l136:;	  yy->__pos= yypos127; yy->__thunkpos= yythunkpos127;  if (!yy_func(yy)) goto l126;
  }
  l127:;	
  yyprintf((stderr, "  ok   %s @ %s\n", "assign", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 4, 0);
  return 1;
  l126:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "assign", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_mkBlock(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "mkBlock"));  yyDo(yy, yy_1_mkBlock, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "mkBlock", yy->__buf+yy->__pos));
  return 1;
  l141:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "mkBlock", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_block(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 2, 0);
  yyprintf((stderr, "%s\n", "block"));  if (!yy_LBRACE(yy)) goto l142;  if (!yy_mkBlock(yy)) goto l142;  yyDo(yy, yySet, -2, 0);  if (!yy_bln(yy)) goto l142;
  {  int yypos145= yy->__pos, yythunkpos145= yy->__thunkpos;  if (!yy_RBRACE(yy)) goto l145;  goto l142;
  l145:;	  yy->__pos= yypos145; yy->__thunkpos= yythunkpos145;
  }  if (!yy_stmt(yy)) goto l142;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_block, yy->__begin, yy->__end);
  l143:;	
  {  int yypos144= yy->__pos, yythunkpos144= yy->__thunkpos;  if (!yy_bln(yy)) goto l144;
  {  int yypos146= yy->__pos, yythunkpos146= yy->__thunkpos;  if (!yy_RBRACE(yy)) goto l146;  goto l144;
  l146:;	  yy->__pos= yypos146; yy->__thunkpos= yythunkpos146;
  }  if (!yy_stmt(yy)) goto l144;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_block, yy->__begin, yy->__end);  goto l143;
  l144:;	  yy->__pos= yypos144; yy->__thunkpos= yythunkpos144;
  }  if (!yy_bln(yy)) goto l142;  if (!yy_RBRACE(yy)) goto l142;  yyDo(yy, yy_2_block, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "block", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 2, 0);
  return 1;
  l142:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "block", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy__(yycontext *yy)
{
  yyprintf((stderr, "%s\n", "_"));
  l148:;	
  {  int yypos149= yy->__pos, yythunkpos149= yy->__thunkpos;  if (!yy_space(yy)) goto l149;  goto l148;
  l149:;	  yy->__pos= yypos149; yy->__thunkpos= yythunkpos149;
  }
  yyprintf((stderr, "  ok   %s @ %s\n", "_", yy->__buf+yy->__pos));
  return 1;
}
YY_RULE(int) yy_RETURN(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "RETURN"));  if (!yymatchString(yy, "return")) goto l150;
  yyprintf((stderr, "  ok   %s @ %s\n", "RETURN", yy->__buf+yy->__pos));
  return 1;
  l150:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "RETURN", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_BREAK(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "BREAK"));  if (!yymatchString(yy, "break")) goto l151;
  yyprintf((stderr, "  ok   %s @ %s\n", "BREAK", yy->__buf+yy->__pos));
  return 1;
  l151:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "BREAK", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_CONTINUE(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "CONTINUE"));  if (!yymatchString(yy, "continue")) goto l152;
  yyprintf((stderr, "  ok   %s @ %s\n", "CONTINUE", yy->__buf+yy->__pos));
  return 1;
  l152:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "CONTINUE", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_SEMI(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "SEMI"));  if (!yymatchChar(yy, ';')) goto l153;  if (!yy__(yy)) goto l153;
  yyprintf((stderr, "  ok   %s @ %s\n", "SEMI", yy->__buf+yy->__pos));
  return 1;
  l153:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "SEMI", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_mkNil(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "mkNil"));  yyDo(yy, yy_1_mkNil, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "mkNil", yy->__buf+yy->__pos));
  return 1;
  l154:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "mkNil", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_expr(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "expr"));  if (!yy_assign(yy)) goto l155;
  yyprintf((stderr, "  ok   %s @ %s\n", "expr", yy->__buf+yy->__pos));
  return 1;
  l155:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "expr", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_FOR(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "FOR"));  if (!yymatchString(yy, "for")) goto l156;
  {  int yypos157= yy->__pos, yythunkpos157= yy->__thunkpos;  if (!yy_alnum(yy)) goto l157;  goto l156;
  l157:;	  yy->__pos= yypos157; yy->__thunkpos= yythunkpos157;
  }  if (!yy__(yy)) goto l156;
  yyprintf((stderr, "  ok   %s @ %s\n", "FOR", yy->__buf+yy->__pos));
  return 1;
  l156:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "FOR", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_WHILE(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "WHILE"));  if (!yymatchString(yy, "while")) goto l158;
  {  int yypos159= yy->__pos, yythunkpos159= yy->__thunkpos;  if (!yy_alnum(yy)) goto l159;  goto l158;
  l159:;	  yy->__pos= yypos159; yy->__thunkpos= yythunkpos159;
  }  if (!yy__(yy)) goto l158;
  yyprintf((stderr, "  ok   %s @ %s\n", "WHILE", yy->__buf+yy->__pos));
  return 1;
  l158:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "WHILE", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_ELSE(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "ELSE"));  if (!yymatchString(yy, "else")) goto l160;
  {  int yypos161= yy->__pos, yythunkpos161= yy->__thunkpos;  if (!yy_alnum(yy)) goto l161;  goto l160;
  l161:;	  yy->__pos= yypos161; yy->__thunkpos= yythunkpos161;
  }  if (!yy__(yy)) goto l160;
  yyprintf((stderr, "  ok   %s @ %s\n", "ELSE", yy->__buf+yy->__pos));
  return 1;
  l160:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "ELSE", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_IF(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "IF"));  if (!yymatchString(yy, "if")) goto l162;
  {  int yypos163= yy->__pos, yythunkpos163= yy->__thunkpos;  if (!yy_alnum(yy)) goto l163;  goto l162;
  l163:;	  yy->__pos= yypos163; yy->__thunkpos= yythunkpos163;
  }  if (!yy__(yy)) goto l162;
  yyprintf((stderr, "  ok   %s @ %s\n", "IF", yy->__buf+yy->__pos));
  return 1;
  l162:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "IF", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_RPAR(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "RPAR"));  if (!yymatchChar(yy, ')')) goto l164;  if (!yy__(yy)) goto l164;
  yyprintf((stderr, "  ok   %s @ %s\n", "RPAR", yy->__buf+yy->__pos));
  return 1;
  l164:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "RPAR", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_COMMA(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "COMMA"));  if (!yymatchChar(yy, ',')) goto l165;  if (!yy__(yy)) goto l165;
  yyprintf((stderr, "  ok   %s @ %s\n", "COMMA", yy->__buf+yy->__pos));
  return 1;
  l165:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "COMMA", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_LPAR(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "LPAR"));  if (!yymatchChar(yy, '(')) goto l166;  if (!yy__(yy)) goto l166;
  yyprintf((stderr, "  ok   %s @ %s\n", "LPAR", yy->__buf+yy->__pos));
  return 1;
  l166:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "LPAR", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_PRINT(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "PRINT"));  if (!yymatchString(yy, "print")) goto l167;
  {  int yypos168= yy->__pos, yythunkpos168= yy->__thunkpos;  if (!yy_alnum(yy)) goto l168;  goto l167;
  l168:;	  yy->__pos= yypos168; yy->__thunkpos= yythunkpos168;
  }  if (!yy__(yy)) goto l167;
  yyprintf((stderr, "  ok   %s @ %s\n", "PRINT", yy->__buf+yy->__pos));
  return 1;
  l167:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "PRINT", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_stmt(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 7, 0);
  yyprintf((stderr, "%s\n", "stmt"));
  {  int yypos170= yy->__pos, yythunkpos170= yy->__thunkpos;  if (!yy_PRINT(yy)) goto l171;  if (!yy_LPAR(yy)) goto l171;  if (!yy_TYPE(yy)) goto l171;  yyDo(yy, yySet, -7, 0);  if (!yy_COMMA(yy)) goto l171;  if (!yy_exp(yy)) goto l171;  yyDo(yy, yySet, -6, 0);  if (!yy_RPAR(yy)) goto l171;  if (!yy_NLINE(yy)) goto l171;  yyDo(yy, yy_1_stmt, yy->__begin, yy->__end);  goto l170;
  l171:;	  yy->__pos= yypos170; yy->__thunkpos= yythunkpos170;  if (!yy_IF(yy)) goto l172;  if (!yy_LPAR(yy)) goto l172;  if (!yy_exp(yy)) goto l172;  yyDo(yy, yySet, -5, 0);  if (!yy_RPAR(yy)) goto l172;  if (!yy_stmtbl(yy)) goto l172;  yyDo(yy, yySet, -4, 0);  if (!yy_bln(yy)) goto l172;  if (!yy_ELSE(yy)) goto l172;  if (!yy_stmtbl(yy)) goto l172;  yyDo(yy, yySet, -7, 0);  yyDo(yy, yy_2_stmt, yy->__begin, yy->__end);  goto l170;
  l172:;	  yy->__pos= yypos170; yy->__thunkpos= yythunkpos170;  if (!yy_IF(yy)) goto l173;  if (!yy_LPAR(yy)) goto l173;  if (!yy_exp(yy)) goto l173;  yyDo(yy, yySet, -5, 0);  if (!yy_RPAR(yy)) goto l173;  if (!yy_stmtbl(yy)) goto l173;  yyDo(yy, yySet, -4, 0);  yyDo(yy, yy_3_stmt, yy->__begin, yy->__end);  goto l170;
  l173:;	  yy->__pos= yypos170; yy->__thunkpos= yythunkpos170;  if (!yy_WHILE(yy)) goto l174;  if (!yy_LPAR(yy)) goto l174;  if (!yy_exp(yy)) goto l174;  yyDo(yy, yySet, -5, 0);  if (!yy_RPAR(yy)) goto l174;  if (!yy_stmtbl(yy)) goto l174;  yyDo(yy, yySet, -4, 0);  yyDo(yy, yy_4_stmt, yy->__begin, yy->__end);  goto l170;
  l174:;	  yy->__pos= yypos170; yy->__thunkpos= yythunkpos170;  if (!yy_FOR(yy)) goto l175;  if (!yy_LPAR(yy)) goto l175;
  {  int yypos176= yy->__pos, yythunkpos176= yy->__thunkpos;  if (!yy_expr(yy)) goto l177;  yyDo(yy, yySet, -3, 0);  goto l176;
  l177:;	  yy->__pos= yypos176; yy->__thunkpos= yythunkpos176;  if (!yy_mkNil(yy)) goto l175;  yyDo(yy, yySet, -3, 0);
  }
  l176:;	  if (!yy_SEMI(yy)) goto l175;
  {  int yypos178= yy->__pos, yythunkpos178= yy->__thunkpos;  if (!yy_exp(yy)) goto l179;  yyDo(yy, yySet, -2, 0);  goto l178;
  l179:;	  yy->__pos= yypos178; yy->__thunkpos= yythunkpos178;  if (!yy_mkNil(yy)) goto l175;  yyDo(yy, yySet, -2, 0);
  }
  l178:;	  if (!yy_SEMI(yy)) goto l175;
  {  int yypos180= yy->__pos, yythunkpos180= yy->__thunkpos;  if (!yy_expr(yy)) goto l181;  yyDo(yy, yySet, -1, 0);  goto l180;
  l181:;	  yy->__pos= yypos180; yy->__thunkpos= yythunkpos180;  if (!yy_mkNil(yy)) goto l175;  yyDo(yy, yySet, -1, 0);
  }
  l180:;	  if (!yy_RPAR(yy)) goto l175;  if (!yy_stmtbl(yy)) goto l175;  yyDo(yy, yySet, -4, 0);  yyDo(yy, yy_5_stmt, yy->__begin, yy->__end);  goto l170;
  l175:;	  yy->__pos= yypos170; yy->__thunkpos= yythunkpos170;  if (!yy_CONTINUE(yy)) goto l182;  if (!yy_NLINE(yy)) goto l182;  yyDo(yy, yy_6_stmt, yy->__begin, yy->__end);  goto l170;
  l182:;	  yy->__pos= yypos170; yy->__thunkpos= yythunkpos170;  if (!yy_BREAK(yy)) goto l183;  if (!yy_NLINE(yy)) goto l183;  yyDo(yy, yy_7_stmt, yy->__begin, yy->__end);  goto l170;
  l183:;	  yy->__pos= yypos170; yy->__thunkpos= yythunkpos170;  if (!yy_RETURN(yy)) goto l184;  if (!yy__(yy)) goto l184;  if (!yy_exp(yy)) goto l184;  yyDo(yy, yySet, -2, 0);  yyDo(yy, yy_8_stmt, yy->__begin, yy->__end);  goto l170;
  l184:;	  yy->__pos= yypos170; yy->__thunkpos= yythunkpos170;  if (!yy_STATE(yy)) goto l185;  if (!yy_id(yy)) goto l185;  yyDo(yy, yySet, -3, 0);  if (!yy_NLINE(yy)) goto l185;  yyDo(yy, yy_9_stmt, yy->__begin, yy->__end);  goto l170;
  l185:;	  yy->__pos= yypos170; yy->__thunkpos= yythunkpos170;  if (!yy_expr(yy)) goto l186;  yyDo(yy, yySet, -6, 0);  if (!yy_NLINE(yy)) goto l186;  yyDo(yy, yy_10_stmt, yy->__begin, yy->__end);  goto l170;
  l186:;	  yy->__pos= yypos170; yy->__thunkpos= yythunkpos170;
  {  int yypos188= yy->__pos, yythunkpos188= yy->__thunkpos;  if (!yymatchDot(yy)) goto l188;  goto l187;
  l188:;	  yy->__pos= yypos188; yy->__thunkpos= yythunkpos188;
  }  yyDo(yy, yy_11_stmt, yy->__begin, yy->__end);  goto l170;
  l187:;	  yy->__pos= yypos170; yy->__thunkpos= yythunkpos170;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l169;
#undef yytext
#undef yyleng
  }
  l189:;	
  {  int yypos190= yy->__pos, yythunkpos190= yy->__thunkpos;
  {  int yypos191= yy->__pos, yythunkpos191= yy->__thunkpos;  if (!yy_eol(yy)) goto l191;  goto l190;
  l191:;	  yy->__pos= yypos191; yy->__thunkpos= yythunkpos191;
  }
  {  int yypos192= yy->__pos, yythunkpos192= yy->__thunkpos;  if (!yymatchDot(yy)) goto l190;  yy->__pos= yypos192; yy->__thunkpos= yythunkpos192;
  }  if (!yymatchDot(yy)) goto l190;  goto l189;
  l190:;	  yy->__pos= yypos190; yy->__thunkpos= yythunkpos190;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l169;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_12_stmt, yy->__begin, yy->__end);
  }
  l170:;	
  yyprintf((stderr, "  ok   %s @ %s\n", "stmt", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 7, 0);
  return 1;
  l169:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "stmt", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_NLINE(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "NLINE"));  if (!yymatchChar(yy, '\n')) goto l193;  yyDo(yy, yy_1_NLINE, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "NLINE", yy->__buf+yy->__pos));
  return 1;
  l193:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "NLINE", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_list(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 2, 0);
  yyprintf((stderr, "%s\n", "list"));  if (!yy_LBRACE(yy)) goto l194;  if (!yy_mkBlock(yy)) goto l194;  yyDo(yy, yySet, -2, 0);  if (!yy_bln(yy)) goto l194;  if (!yy_exp(yy)) goto l194;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_list, yy->__begin, yy->__end);
  l197:;	
  {  int yypos198= yy->__pos, yythunkpos198= yy->__thunkpos;  if (!yy_bln(yy)) goto l198;  if (!yy_COMMA(yy)) goto l198;  if (!yy_bln(yy)) goto l198;  if (!yy_exp(yy)) goto l198;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_2_list, yy->__begin, yy->__end);  goto l197;
  l198:;	  yy->__pos= yypos198; yy->__thunkpos= yythunkpos198;
  }
  l195:;	
  {  int yypos196= yy->__pos, yythunkpos196= yy->__thunkpos;  if (!yy_exp(yy)) goto l196;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_list, yy->__begin, yy->__end);
  l199:;	
  {  int yypos200= yy->__pos, yythunkpos200= yy->__thunkpos;  if (!yy_bln(yy)) goto l200;  if (!yy_COMMA(yy)) goto l200;  if (!yy_bln(yy)) goto l200;  if (!yy_exp(yy)) goto l200;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_2_list, yy->__begin, yy->__end);  goto l199;
  l200:;	  yy->__pos= yypos200; yy->__thunkpos= yythunkpos200;
  }  goto l195;
  l196:;	  yy->__pos= yypos196; yy->__thunkpos= yythunkpos196;
  }  if (!yy_bln(yy)) goto l194;  if (!yy_RBRACE(yy)) goto l194;  yyDo(yy, yy_3_list, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "list", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 2, 0);
  return 1;
  l194:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "list", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_blocks(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 2, 0);
  yyprintf((stderr, "%s\n", "blocks"));  if (!yy_mkBlock(yy)) goto l201;  yyDo(yy, yySet, -2, 0);  if (!yy_block(yy)) goto l201;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_blocks, yy->__begin, yy->__end);
  l202:;	
  {  int yypos203= yy->__pos, yythunkpos203= yy->__thunkpos;  if (!yy_block(yy)) goto l203;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_blocks, yy->__begin, yy->__end);  goto l202;
  l203:;	  yy->__pos= yypos203; yy->__thunkpos= yythunkpos203;
  }  yyDo(yy, yy_2_blocks, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "blocks", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 2, 0);
  return 1;
  l201:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "blocks", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_event(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 5, 0);
  yyprintf((stderr, "%s\n", "event"));
  {  int yypos205= yy->__pos, yythunkpos205= yy->__thunkpos;  if (!yy_id(yy)) goto l206;  yyDo(yy, yySet, -5, 0);  if (!yy_params(yy)) goto l206;  yyDo(yy, yySet, -4, 0);  if (!yy_blocks(yy)) goto l206;  yyDo(yy, yySet, -3, 0);  yyDo(yy, yy_1_event, yy->__begin, yy->__end);  goto l205;
  l206:;	  yy->__pos= yypos205; yy->__thunkpos= yythunkpos205;  if (!yy_TYPE(yy)) goto l207;  yyDo(yy, yySet, -2, 0);  if (!yy_id(yy)) goto l207;  yyDo(yy, yySet, -5, 0);  if (!yy_ASSIGN(yy)) goto l207;  if (!yy_exp(yy)) goto l207;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_2_event, yy->__begin, yy->__end);  goto l205;
  l207:;	  yy->__pos= yypos205; yy->__thunkpos= yythunkpos205;  if (!yy_TYPE(yy)) goto l204;  yyDo(yy, yySet, -2, 0);  if (!yy_id(yy)) goto l204;  yyDo(yy, yySet, -5, 0);  if (!yy_bracket(yy)) goto l204;  yyDo(yy, yySet, -3, 0);  if (!yy_ASSIGN(yy)) goto l204;  if (!yy_list(yy)) goto l204;  yyDo(yy, yySet, -1, 0);  if (!yy_NLINE(yy)) goto l204;  yyDo(yy, yy_3_event, yy->__begin, yy->__end);
  }
  l205:;	
  yyprintf((stderr, "  ok   %s @ %s\n", "event", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 5, 0);
  return 1;
  l204:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "event", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_RBRACE(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "RBRACE"));  if (!yymatchChar(yy, '}')) goto l208;  if (!yy__(yy)) goto l208;
  yyprintf((stderr, "  ok   %s @ %s\n", "RBRACE", yy->__buf+yy->__pos));
  return 1;
  l208:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "RBRACE", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_mkState(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "mkState"));  yyDo(yy, yy_1_mkState, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "mkState", yy->__buf+yy->__pos));
  return 1;
  l209:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "mkState", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_LBRACE(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "LBRACE"));  if (!yymatchChar(yy, '{')) goto l210;  if (!yy__(yy)) goto l210;
  yyprintf((stderr, "  ok   %s @ %s\n", "LBRACE", yy->__buf+yy->__pos));
  return 1;
  l210:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "LBRACE", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_eol(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "eol"));  if (!yymatchClass(yy, (unsigned char *)"\000\044\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l211;
  yyprintf((stderr, "  ok   %s @ %s\n", "eol", yy->__buf+yy->__pos));
  return 1;
  l211:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "eol", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_RUN(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "RUN"));  if (!yymatchString(yy, "run")) goto l212;
  {  int yypos213= yy->__pos, yythunkpos213= yy->__thunkpos;  if (!yy_alnum(yy)) goto l213;  goto l212;
  l213:;	  yy->__pos= yypos213; yy->__thunkpos= yythunkpos213;
  }  if (!yy__(yy)) goto l212;
  yyprintf((stderr, "  ok   %s @ %s\n", "RUN", yy->__buf+yy->__pos));
  return 1;
  l212:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "RUN", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_exp(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "exp"));  if (!yy_logadd(yy)) goto l214;
  yyprintf((stderr, "  ok   %s @ %s\n", "exp", yy->__buf+yy->__pos));
  return 1;
  l214:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "exp", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_ASSIGN(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "ASSIGN"));  if (!yymatchChar(yy, '=')) goto l215;
  {  int yypos216= yy->__pos, yythunkpos216= yy->__thunkpos;  if (!yymatchChar(yy, '=')) goto l216;  goto l215;
  l216:;	  yy->__pos= yypos216; yy->__thunkpos= yythunkpos216;
  }  if (!yy__(yy)) goto l215;
  yyprintf((stderr, "  ok   %s @ %s\n", "ASSIGN", yy->__buf+yy->__pos));
  return 1;
  l215:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "ASSIGN", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_stmtbl(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "stmtbl"));
  {  int yypos218= yy->__pos, yythunkpos218= yy->__thunkpos;  if (!yy_block(yy)) goto l219;  goto l218;
  l219:;	  yy->__pos= yypos218; yy->__thunkpos= yythunkpos218;  if (!yy_stmt(yy)) goto l217;
  }
  l218:;	
  yyprintf((stderr, "  ok   %s @ %s\n", "stmtbl", yy->__buf+yy->__pos));
  return 1;
  l217:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "stmtbl", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_params(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 3, 0);
  yyprintf((stderr, "%s\n", "params"));  if (!yy_LPAR(yy)) goto l220;  if (!yy_mkNil(yy)) goto l220;  yyDo(yy, yySet, -3, 0);
  {  int yypos221= yy->__pos, yythunkpos221= yy->__thunkpos;  if (!yy_TYPE(yy)) goto l221;  yyDo(yy, yySet, -2, 0);  if (!yy_id(yy)) goto l221;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_params, yy->__begin, yy->__end);
  l223:;	
  {  int yypos224= yy->__pos, yythunkpos224= yy->__thunkpos;  if (!yy_COMMA(yy)) goto l224;  if (!yy_TYPE(yy)) goto l224;  yyDo(yy, yySet, -2, 0);  if (!yy_id(yy)) goto l224;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_2_params, yy->__begin, yy->__end);  goto l223;
  l224:;	  yy->__pos= yypos224; yy->__thunkpos= yythunkpos224;
  }  goto l222;
  l221:;	  yy->__pos= yypos221; yy->__thunkpos= yythunkpos221;
  }
  l222:;	  if (!yy_RPAR(yy)) goto l220;  yyDo(yy, yy_3_params, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "params", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 3, 0);
  return 1;
  l220:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "params", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_TYPE(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "TYPE"));
  {  int yypos226= yy->__pos, yythunkpos226= yy->__thunkpos;  if (!yymatchString(yy, "int")) goto l227;  if (!yy__(yy)) goto l227;  yyDo(yy, yy_1_TYPE, yy->__begin, yy->__end);  goto l226;
  l227:;	  yy->__pos= yypos226; yy->__thunkpos= yythunkpos226;  if (!yymatchString(yy, "long")) goto l228;  if (!yy__(yy)) goto l228;  yyDo(yy, yy_2_TYPE, yy->__begin, yy->__end);  goto l226;
  l228:;	  yy->__pos= yypos226; yy->__thunkpos= yythunkpos226;  if (!yymatchString(yy, "dou")) goto l229;  if (!yy__(yy)) goto l229;  yyDo(yy, yy_3_TYPE, yy->__begin, yy->__end);  goto l226;
  l229:;	  yy->__pos= yypos226; yy->__thunkpos= yythunkpos226;  if (!yymatchString(yy, "flo")) goto l230;  if (!yy__(yy)) goto l230;  yyDo(yy, yy_4_TYPE, yy->__begin, yy->__end);  goto l226;
  l230:;	  yy->__pos= yypos226; yy->__thunkpos= yythunkpos226;  if (!yymatchString(yy, "cha")) goto l231;  if (!yy__(yy)) goto l231;  yyDo(yy, yy_5_TYPE, yy->__begin, yy->__end);  goto l226;
  l231:;	  yy->__pos= yypos226; yy->__thunkpos= yythunkpos226;  if (!yymatchString(yy, "str")) goto l232;  if (!yy__(yy)) goto l232;  yyDo(yy, yy_6_TYPE, yy->__begin, yy->__end);  goto l226;
  l232:;	  yy->__pos= yypos226; yy->__thunkpos= yythunkpos226;  if (!yymatchString(yy, "key")) goto l225;  if (!yy__(yy)) goto l225;  yyDo(yy, yy_7_TYPE, yy->__begin, yy->__end);
  }
  l226:;	
  yyprintf((stderr, "  ok   %s @ %s\n", "TYPE", yy->__buf+yy->__pos));
  return 1;
  l225:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "TYPE", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_bracket(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 1, 0);
  yyprintf((stderr, "%s\n", "bracket"));  if (!yy_LSQP(yy)) goto l233;  if (!yy_exp(yy)) goto l233;  yyDo(yy, yySet, -1, 0);  if (!yy_RSQP(yy)) goto l233;  yyDo(yy, yy_1_bracket, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "bracket", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 1, 0);
  return 1;
  l233:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "bracket", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_state(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 2, 0);
  yyprintf((stderr, "%s\n", "state"));  if (!yy_LBRACE(yy)) goto l234;  if (!yy_mkState(yy)) goto l234;  yyDo(yy, yySet, -2, 0);  if (!yy_bln(yy)) goto l234;
  {  int yypos237= yy->__pos, yythunkpos237= yy->__thunkpos;  if (!yy_RBRACE(yy)) goto l237;  goto l234;
  l237:;	  yy->__pos= yypos237; yy->__thunkpos= yythunkpos237;
  }  if (!yy_event(yy)) goto l234;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_state, yy->__begin, yy->__end);
  l235:;	
  {  int yypos236= yy->__pos, yythunkpos236= yy->__thunkpos;  if (!yy_bln(yy)) goto l236;
  {  int yypos238= yy->__pos, yythunkpos238= yy->__thunkpos;  if (!yy_RBRACE(yy)) goto l238;  goto l236;
  l238:;	  yy->__pos= yypos238; yy->__thunkpos= yythunkpos238;
  }  if (!yy_event(yy)) goto l236;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_state, yy->__begin, yy->__end);  goto l235;
  l236:;	  yy->__pos= yypos236; yy->__thunkpos= yythunkpos236;
  }  if (!yy_bln(yy)) goto l234;  if (!yy_RBRACE(yy)) goto l234;  yyDo(yy, yy_2_state, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "state", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 2, 0);
  return 1;
  l234:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "state", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_id(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "id"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l239;
#undef yytext
#undef yyleng
  }  if (!yy_alpha(yy)) goto l239;
  l240:;	
  {  int yypos241= yy->__pos, yythunkpos241= yy->__thunkpos;  if (!yy_alnum(yy)) goto l241;  goto l240;
  l241:;	  yy->__pos= yypos241; yy->__thunkpos= yythunkpos241;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l239;
#undef yytext
#undef yyleng
  }  if (!yy__(yy)) goto l239;  yyDo(yy, yy_1_id, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "id", yy->__buf+yy->__pos));
  return 1;
  l239:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "id", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_STATE(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "STATE"));  if (!yymatchString(yy, "state")) goto l242;
  {  int yypos243= yy->__pos, yythunkpos243= yy->__thunkpos;  if (!yy_alnum(yy)) goto l243;  goto l242;
  l243:;	  yy->__pos= yypos243; yy->__thunkpos= yythunkpos243;
  }  if (!yy__(yy)) goto l242;  yyDo(yy, yy_1_STATE, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "STATE", yy->__buf+yy->__pos));
  return 1;
  l242:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "STATE", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_define(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 6, 0);
  yyprintf((stderr, "%s\n", "define"));
  {  int yypos245= yy->__pos, yythunkpos245= yy->__thunkpos;  if (!yy_STATE(yy)) goto l246;  yyDo(yy, yySet, -6, 0);  if (!yy_id(yy)) goto l246;  yyDo(yy, yySet, -5, 0);  if (!yy_state(yy)) goto l246;  yyDo(yy, yySet, -4, 0);  yyDo(yy, yy_1_define, yy->__begin, yy->__end);  goto l245;
  l246:;	  yy->__pos= yypos245; yy->__thunkpos= yythunkpos245;  if (!yy_bracket(yy)) goto l247;  yyDo(yy, yySet, -3, 0);  yyDo(yy, yy_2_define, yy->__begin, yy->__end);  goto l245;
  l247:;	  yy->__pos= yypos245; yy->__thunkpos= yythunkpos245;  if (!yy_TYPE(yy)) goto l248;  yyDo(yy, yySet, -6, 0);  if (!yy_id(yy)) goto l248;  yyDo(yy, yySet, -5, 0);  if (!yy_params(yy)) goto l248;  yyDo(yy, yySet, -2, 0);  if (!yy_stmtbl(yy)) goto l248;  yyDo(yy, yySet, -4, 0);  yyDo(yy, yy_3_define, yy->__begin, yy->__end);  goto l245;
  l248:;	  yy->__pos= yypos245; yy->__thunkpos= yythunkpos245;  if (!yy_TYPE(yy)) goto l249;  yyDo(yy, yySet, -6, 0);  if (!yy_id(yy)) goto l249;  yyDo(yy, yySet, -5, 0);  if (!yy_ASSIGN(yy)) goto l249;  if (!yy_exp(yy)) goto l249;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_4_define, yy->__begin, yy->__end);  goto l245;
  l249:;	  yy->__pos= yypos245; yy->__thunkpos= yythunkpos245;  if (!yy_RUN(yy)) goto l250;  if (!yy_id(yy)) goto l250;  yyDo(yy, yySet, -5, 0);  yyDo(yy, yy_5_define, yy->__begin, yy->__end);  goto l245;
  l250:;	  yy->__pos= yypos245; yy->__thunkpos= yythunkpos245;
  {  int yypos252= yy->__pos, yythunkpos252= yy->__thunkpos;  if (!yymatchDot(yy)) goto l252;  goto l251;
  l252:;	  yy->__pos= yypos252; yy->__thunkpos= yythunkpos252;
  }  yyDo(yy, yy_6_define, yy->__begin, yy->__end);  goto l245;
  l251:;	  yy->__pos= yypos245; yy->__thunkpos= yythunkpos245;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l244;
#undef yytext
#undef yyleng
  }
  l253:;	
  {  int yypos254= yy->__pos, yythunkpos254= yy->__thunkpos;
  {  int yypos255= yy->__pos, yythunkpos255= yy->__thunkpos;  if (!yy_eol(yy)) goto l255;  goto l254;
  l255:;	  yy->__pos= yypos255; yy->__thunkpos= yythunkpos255;
  }
  {  int yypos256= yy->__pos, yythunkpos256= yy->__thunkpos;  if (!yymatchDot(yy)) goto l254;  yy->__pos= yypos256; yy->__thunkpos= yythunkpos256;
  }  if (!yymatchDot(yy)) goto l254;  goto l253;
  l254:;	  yy->__pos= yypos254; yy->__thunkpos= yythunkpos254;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l244;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_7_define, yy->__begin, yy->__end);
  }
  l245:;	
  yyprintf((stderr, "  ok   %s @ %s\n", "define", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 6, 0);
  return 1;
  l244:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "define", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_bln(yycontext *yy)
{
  yyprintf((stderr, "%s\n", "bln"));
  l258:;	
  {  int yypos259= yy->__pos, yythunkpos259= yy->__thunkpos;  if (!yy_blank(yy)) goto l259;  goto l258;
  l259:;	  yy->__pos= yypos259; yy->__thunkpos= yythunkpos259;
  }
  yyprintf((stderr, "  ok   %s @ %s\n", "bln", yy->__buf+yy->__pos));
  return 1;
}
YY_RULE(int) yy_start(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 1, 0);
  yyprintf((stderr, "%s\n", "start"));  if (!yy_bln(yy)) goto l260;  if (!yy_define(yy)) goto l260;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_start, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "start", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 1, 0);
  return 1;
  l260:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "start", yy->__buf+yy->__pos));
  return 0;
}

#ifndef YY_PART

typedef int (*yyrule)(yycontext *yy);

YY_PARSE(int) YYPARSEFROM(YY_CTX_PARAM_ yyrule yystart)
{
  int yyok;
  if (!yyctx->__buflen)
    {
      yyctx->__buflen= YY_BUFFER_SIZE;
      yyctx->__buf= (char *)YY_MALLOC(yyctx, yyctx->__buflen);
      yyctx->__textlen= YY_BUFFER_SIZE;
      yyctx->__text= (char *)YY_MALLOC(yyctx, yyctx->__textlen);
      yyctx->__thunkslen= YY_STACK_SIZE;
      yyctx->__thunks= (yythunk *)YY_MALLOC(yyctx, sizeof(yythunk) * yyctx->__thunkslen);
      yyctx->__valslen= YY_STACK_SIZE;
      yyctx->__vals= (YYSTYPE *)YY_MALLOC(yyctx, sizeof(YYSTYPE) * yyctx->__valslen);
      yyctx->__begin= yyctx->__end= yyctx->__pos= yyctx->__limit= yyctx->__thunkpos= 0;
    }
  yyctx->__begin= yyctx->__end= yyctx->__pos;
  yyctx->__thunkpos= 0;
  yyctx->__val= yyctx->__vals;
  yyok= yystart(yyctx);
  if (yyok) yyDone(yyctx);
  yyCommit(yyctx);
  return yyok;
}

YY_PARSE(int) YYPARSE(YY_CTX_PARAM)
{
  return YYPARSEFROM(YY_CTX_ARG_ yy_start);
}

YY_PARSE(yycontext *) YYRELEASE(yycontext *yyctx)
{
  if (yyctx->__buflen)
    {
      yyctx->__buflen= 0;
      YY_FREE(yyctx, yyctx->__buf);
      YY_FREE(yyctx, yyctx->__text);
      YY_FREE(yyctx, yyctx->__thunks);
      YY_FREE(yyctx, yyctx->__vals);
    }
  return yyctx;
}

#endif
#line 1338 "code.leg"
;

// https://programming-place.net/ppp/contents/c/appendix/operation.html
oop newBoolean(int flag) { return flag ? sys_true : sys_false; }
/*     0    1           2       3       4      5    6       7   8*/
enum instrac{
HALT,
i_load,/* value */
l_load,/* value */
f_load,/* value */
d_load,/* value */
c_load,/* value */
s_load,/* value */
k_load,/* value */
//in progress
il_load,/* vnt adress */
ll_load,/* vnt adress */
fl_load,/* vnt adress */
dl_load,/* vnt adress */

i_EQ,
i_NE,
i_LT,
i_LE,
i_GE,
i_GT,
i_AND,
i_OR,
i_ADD,
i_SUB,
i_MUL,
i_DIV,
i_MOD,
l_EQ,
l_NE,
l_LT,
l_LE,
l_GE,
l_GT,
l_ADD,
l_SUB,
l_MUL,
l_DIV,
l_MOD,
f_EQ,
f_NE,
f_LT,
f_LE,
f_GE,
f_GT,
f_ADD,
f_SUB,
f_MUL,
f_DIV,
d_EQ,
d_NE,
d_LT,
d_LE,
d_GE,
d_GT,
d_ADD,
d_SUB,
d_MUL,
d_DIV,

s_EQ,
s_NE,
s_LT,
s_LE,
s_GE,
s_GT,
s_AND,
s_OR,
s_ADD,
s_SUB,
s_MUL,
s_DIV,
s_MOD,


EOE,   /* end of event function*/
TRANS, /*transition: state change*/
THREAD,/* make thread for event */
SET_EVENT,
GLOBAL,
GLOBAL_END,
ENTRY,
/*don't change order start*/
GET,
GET_L,
GET_G,
DEFINE,
DEFINE_L, /* pos */
DEFINE_G, /* pos */
DEFINE_List,    /* vnt index */ //in progress
DEFINE_List_L,  /* vnt index */
DEFINE_List_G,  /* vnt index */
/*don't change order end*/
CALL,
CALL_P,
CALL_E,
SETQ,
RET,
MSUB,
MPOP,
MPICK,
MSET,//global value size settting
JUMP,
JUMPF,
i_PRINT,
l_PRINT,
f_PRINT,
d_PRINT,
c_PRINT,
s_PRINT,
};

char* INSTNAME[s_PRINT + 1] = {
"HALT",
"i_load",/* value */
"l_load",/* value */
"f_load",/* value */
"d_load",/* value */
"c_load",/* value */
"s_load",/* value */
"k_load",/* value */
//in progress
"il_load",/* vnt adress */
"ll_load",/* vnt adress */
"fl_load",/* vnt adress */
"dl_load",/* vnt adress */

"i_EQ",
"i_NE",
"i_LT",
"i_LE",
"i_GE",
"i_GT",
"i_AND",
"i_OR",
"i_ADD",
"i_SUB",
"i_MUL",
"i_DIV",
"i_MOD",
"l_EQ",
"l_NE",
"l_LT",
"l_LE",
"l_GE",
"l_GT",
"l_ADD",
"l_SUB",
"l_MUL",
"l_DIV",
"l_MOD",
"f_EQ",
"f_NE",
"f_LT",
"f_LE",
"f_GE",
"f_GT",
"f_ADD",
"f_SUB",
"f_MUL",
"f_DIV",
"d_EQ",
"d_NE",
"d_LT",
"d_LE",
"d_GE",
"d_GT",
"d_ADD",
"d_SUB",
"d_MUL",
"d_DIV",

"s_EQ",
"s_NE",
"s_LT",
"s_LE",
"s_GE",
"s_GT",
"s_AND",
"s_OR",
"s_ADD",
"s_SUB",
"s_MUL",
"s_DIV",
"s_MOD",

"EOE",   /* end of event function*/
"TRANS", /*transition: state change*/
"THREAD",/* make thread for event */
"SET_EVENT",
"GLOBAL",
"GLOBAL_END",
"ENTRY",
/*don't change order start*/
"GET",
"GET_L",
"GET_G",
"DEFINE",
"DEFINE_L", /* pos */
"DEFINE_G", /* pos */
"DEFINE_List",    /* vnt index */ //in progress
"DEFINE_List_L",  /* vnt index */
"DEFINE_List_G",  /* vnt index */
/*don't change order end*/
"CALL",
"CALL_P",
"CALL_E",
"SETQ",
"RET",
"MSUB",
"MPOP",
"MPICK",
"MSET",//global value size settting
"JUMP",
"JUMPF",
"i_PRINT",
"l_PRINT",
"f_PRINT",
"d_PRINT",
"c_PRINT",
"s_PRINT",
};






enum instrac Binop_oprand(enum Type type,enum binop binop,int line){
    switch(type){
        case _Integer:{
            switch(binop){
                case AND: return i_AND;
                case OR: return i_OR;
                case EQ: return i_EQ;
                case NE: return i_NE;
                case LT: return i_LT;
                case LE: return i_LE;
                case GE: return i_GE;               
                case GT: return i_GT;
                case ADD:return i_ADD;
                case SUB:return i_SUB;
                case MUL:return i_MUL;
                case DIV:return i_DIV;
                case MOD:return i_MOD;
                default: printf("this cannot happen in Binop_oprand Integer\n");
            }
            break;
        }
        case _Long:{
            switch(binop){
                case AND: fatal("line %d oprand error: logic and cannot apply Long type\n",line);
                case OR:  fatal("line %d oprand error: logic or cannot apply Long type\n",line);
                case EQ: return l_EQ; 
                case NE: return l_NE; 
                case LT: return l_LT; 
                case LE: return l_LE; 
                case GE: return l_GE;                  
                case GT: return l_GT; 
                case ADD:return l_ADD; 
                case SUB:return l_SUB; 
                case MUL:return l_MUL; 
                case DIV:return l_DIV; 
                case MOD:return l_MOD; 
                default: printf("this cannot happen Binop_oprand Long\n");
            }
            break;
        }
        case _Float:{
            switch(binop){
                case AND: fatal("line %d oprand error: logic and cannot apply Float type\n",line);
                case OR:  fatal("line %d oprand error: logic or cannot apply Float type\n",line);
                case EQ:  return f_EQ;
                case NE:  return f_NE;
                case LT:  return f_LT;
                case LE:  return f_LE;
                case GE:  return f_GE;                
                case GT:  return f_GT;
                case ADD: return f_ADD;
                case SUB: return f_SUB;
                case MUL: return f_MUL;
                case DIV: return f_DIV;
                case MOD: fatal("line %d oprand error: MOD cannot apply Float type\n",line);
                default: printf("this cannot happen Binop_oprand Float\n");
            }
            break;
        }
        case _Double:{
            switch(binop){
                case AND: fatal("line %d oprand error: logic and cannot apply Double type\n",line);
                case OR:  fatal("line %d oprand error: logic or cannot apply Double type\n",line);
                case EQ: return d_EQ; 
                case NE: return d_NE; 
                case LT: return d_LT; 
                case LE: return d_LE; 
                case GE: return d_GE;                  
                case GT: return d_GT; 
                case ADD:return d_ADD;
                case SUB:return d_SUB;
                case MUL:return d_MUL;
                case DIV:return d_DIV;
                case MOD: fatal("line %d oprand error: MOD cannot apply Double type\n",line);
                default: printf("this cannot happen Binop_oprand Double\n");
            }
            break;
        }
        case String:{            //now
            switch(binop){
                case AND: fatal("line %d oprand error: logic and cannot apply String type\n",line);
                case OR:  fatal("line %d oprand error: logic or cannot apply String type\n",line);
                case EQ: return s_EQ; 
                case NE: return s_NE; 
                case LT: return s_LT; 
                case LE: return s_LE; 
                case GE: return s_GE;                  
                case GT: return s_GT; 
                case ADD:return s_ADD;
                case SUB:fatal("line %d oprand error: logic or cannot apply String type\n",line);
                case MUL:fatal("line %d oprand error: logic or cannot apply String type\n",line);
                case DIV:fatal("line %d oprand error: logic or cannot apply String type\n",line);
                case MOD: fatal("line %d oprand error: MOD cannot apply Double type\n",line);
                default: printf("this cannot happen Binop_oprand Double\n");
            }
            break;
        }
        case _Char:{
            fprintf(stderr,"not yet\n");
            exit(1);
        }
        default:{
            fprintf(stderr,"%s has not been applied to calculations\n",TYPENAME[type]);
            exit(1);
        }
    }
    fprintf(stderr,"%s has not been applied MOD\n",TYPENAME[type]);
    exit(1);
    return 0;
}


/*
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                        compile code
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
*/

// break stack
int *b_stack = 0;
int   b_size = 0;
int   b_max  = 0;

void b_push(int i){
    // minus number is mark
    if(i>0 && b_size==0){
        fprintf(stderr,"break is defined outside loop\n");
        exit(1);
    }
    if(b_size >= b_max){
        b_stack = realloc(b_stack,sizeof(*b_stack) *( b_size + 1));
        b_max++;
    }
    b_stack[b_size++] = i;
}

int b_pop(){
    if(b_size==0){
        fprintf(stderr,"break out of stack\n");
        exit(1);
    }
    return b_stack[--b_size];
}

// continue stack
int *c_stack = 0;
int  c_size  = 0;
int  c_max   = 0;

void c_push(int i){
    // minus number is mark
    if(i>0 && c_size==0){
        fprintf(stderr,"continue is defined outside loop\n");
        exit(1);
    }
    if(c_size>=c_max){
        c_stack = realloc(c_stack,sizeof(*c_stack) *( c_size + 1));
    }
    c_stack[c_size++] = i;
}
int c_pop(){
    if(c_size==0){
        fprintf(stderr,"continue out of stack\n");
        exit(1);
    }
    return c_stack[--c_size];
}


//find key in the alist (variable name table).
oop assoc(oop key, oop alist)
{
    if (getType(alist) == Array) {
        int size = alist->Array.size;
        for(int i=0; i<size; i++){
            oop head = alist->Array.elements[i];
            if(head == nil)continue;
            if(head->Assoc.symbol == key) return head;
        }
    }
    return nil;
}

//remove assoc form end to size of vnt (variable name table)
oop kill_assoc(oop vnt,int end){
    assert(getType(vnt) == Array);
    int size = vnt->Array.size;
    for(int i=size-1; i==end;i--){
        vnt->Array.elements[i] = nil;
    }
    return nil;
}


void manage(oop program,enum Type type){
    int size  = 0;
    switch(type){
        case _Integer:
        case _Float:  program->Array.number += 3;break;
        case _Long:
        case _Double: program->Array.number += 7;break;
        default:
            fatal("manage error: unsupported type\n");
    }
    return;
}
/* array put - setnum*/
#define INTSIZE 4 
#define OPESIZE 1

oop compile(oop,oop,oop,enum Type);
#define emit(X)         Array_push(program,X)
#define emitI(A)        emit(_newInteger(A))
#define emitII(OP,A)    emitI(OP); emitI(A); manage(program,_Integer)
#define emitOII(OP,A,B) emitI(OP); emitI(A); manage(program,_Integer); emitI(B); manage(program,_Integer); 
#define emitOIII(OP,A,B,C) emitI(OP); emitI(A); manage(program,_Integer); emitI(B); manage(program,_Integer); emitI(C); manage(program,_Integer); 
#define emitIO(OP,A,T)  emitI(OP); emit(A);  manage(program,T);
#define emitIS(OP,A,S)  emitI(OP); emit(A);  program->Array.number+=S 

#define compO(O)    compile(program,O,vnt,Undefined)
#define compOT(O,T) compile(program,O,vnt,T)
#define compPara(O,L)    compileParams(program,O,vnt,L)

#define compStatement(A,T)({ \
    if(isEntry==0){ \
        size  = vnt->Array.size; \
        compOT(A,T);/* if */ \
        kill_assoc(vnt,size); \
    }else{ \
        size  = Local_VNT->Array.size; \
        compOT(A,T);/* if */ \
        kill_assoc(Local_VNT,size);/*kill*/ \
    } \
})
oop state_Pair = 0; //state (id index)
oop Global_VNT = 0; //Gloval variable name table
oop Local_VNT  = 0; //STATE Local variable name table
int isEntry    = 0; //if defining entry() event, it is 1, otherwise 0.



void compileParams(oop program,oop params,oop vnt,int line){
    int index = 0;
    while(getType(params) == Pair){
        oop para = params->Pair.a;
        if(assoc(para->Pair.b,vnt)!=nil)
            fatal("line %d type error: cannot apply same symbol in parameter\n",line);
        if(assoc(para->Pair.b,Global_VNT)!=nil)
            fatal("line %d variable error: %s parameter in Global variable\n",line,get(para->Pair.b,Symbol,name));
        /* LOCAL VNT */           
        oop ass  = newAssoc(para->Pair.b,getType(para->Pair.a),vnt->Array.size);
        Array_push(vnt,ass);
        /* +3: [stack]
        arg_num　
        ret_pc_num　
        rbp　
        */
        //†††
        emitOII(MPICK, index + 3, ass->Assoc.index);//rbp - (2:return adress & arg num)
        params = params->Pair.b;
        index++;
    }
}



int compArgs(oop program,oop params,oop args,oop vnt){
    if(params->type == Pair && args->type == Pair){
        int size = compArgs(program,params->Pair.b,args->Pair.b,vnt);
        oop para = params->Pair.a; 
        compOT(args->Pair.a,para->Pair.a->type);
        return size + 1;
    }
    if(params->type == Pair)fatal("argument error: too few argument");
    if(args->type == Pair)fatal("argument error: too many argument");
    return 0;
}



//Returns the leftmost type in the tree. (condition)
int child_type(oop exp,oop vnt){
    switch (getType(exp)) {
	case Integer:return Integer;
    case Float:return   Float;
	case Binop: {
        int l = child_type(get(exp,Binop,lhs),vnt);
        switch(l){
            case _Integer:
            case _Long:
            case _Float:
            case _Char:
            case String:
            case _Double:{
                return l;
            }
            default:break;
        }

        int r = child_type(get(exp,Binop,rhs),vnt);
        switch(l){
            case _Integer:
            case _Long:
            case _Float:
            case _Char:
            case String:
            case _Double:{
                return l;
            }
            default:break;
        }
        return l;
	}
	case GetVar:{
        oop sym = get(exp,GetVar,id);
        oop ass = assoc(sym,Global_VNT);
        if(ass==nil)ass = assoc(sym,Local_VNT);
        if(ass==nil)ass = assoc(sym,vnt);
        if(ass == nil){
            fatal("line %d variable error: Undefine variable, %s\n",exp->GetVar.line,sym->Symbol.name);
        }
        return ass->Assoc.kind;
    }

	case Call:{
        oop id = exp->Call.function;
        oop function = get(id,Symbol,value);
	    switch (getType(function)) {
            case Function:{
                return  get(function,Function,kind);
            }
            case Primitive:{
                return get(function,Primitive,return_type);
            }
            default:fatal("line %d HACK: this cannot happen call\n",exp->Call.line);
	    }
	    break;
    }
	default:{
        fatal("line %d HACK: this cannot happen chiled type");
    }
    }
    return Undefined;
}





struct Variable{
    int index;
    int variable_num;
    /*
    0:normal varialble
    1:STT local variable
    2:global varialbe
    */
};

struct Variable* newVariable(int i,int t){
    struct Variable *var = calloc(1,sizeof(struct Variable));
    var->variable_num = t;
    var->index = i;
    return var;
}

/* Find variable from global, local, normal variable name table.
    and then return global/local/vnt, and index where it is stored */
struct Variable* set_id_index(oop id,oop vnt){
    oop ass = assoc(id,Global_VNT); 
    if( ass                        !=nil)return newVariable(get(ass,Assoc,index),2);
    if((ass = assoc(id, Local_VNT))!=nil)return newVariable(get(ass,Assoc,index),1);
    if((ass = assoc(id,vnt))       !=nil)return newVariable(get(ass,Assoc,index),0);
    if(ass == nil)fatal("variable error: Undefined variable, %s",get(id,Symbol,name)); 
    return 0;
}


/// @brief 
/// @param program 
/// @param exp 
/// @param vnt 
/// @param  
/// @return 
oop compile(oop program,oop exp, oop vnt,enum Type type) //add enum Type type
{

    switch (getType(exp)) {
	case Undefined:
	case Integer:{
        switch(type){
            case _Integer:emitIO(i_load, _newCharInteger(get(exp,Integer,number)),_Integer);break;
            case _Long:   emitIO(l_load, _newCharLong(get(exp,Integer,number))   ,_Long);   break;
            case _Char:   emitIO(c_load, _newStrChar(get(exp,Integer,number))   ,_Char);   break;
            default:{
                fprintf(stderr,"line %d type error: %s but %s, ",exp->Integer.line ,TYPENAME[type],TYPENAME[getType(exp)]);
                printlnObject(exp,0);
                exit(1);
            }
        }
        break;
    }
    case Float:{
        switch(type){
            case _Float: emitIO(f_load,_newCharFloat(get(exp,Float,number)) ,_Float);break;
            case _Double:emitIO(d_load,_newCharDouble(get(exp,Float,number)),_Double);break;
            default:{
                fprintf(stderr,"line %d type error: %s but %s, ",exp->Float.line, TYPENAME[type],TYPENAME[getType(exp)]);
                printlnObject(exp,0);
                exit(1);
            }
        }
        break;
    }
    case String:{
        switch(type){
            case String:{
                int str_size = strlen(get(exp,String,value)) ;
                if(str_size > 255)fatal("line x type error: over 255 charactor \n");
                emitIS(s_load,exp,str_size);
                break;
            }
            default:{
                fatal("line x type error: %s but %s",TYPENAME[type],TYPENAME[getType(exp)]);
            }
        }
        break;
    } 
    case _Char:{
        switch(type){
            case _Char:   emitIO(c_load, exp   ,_Char);   break;
            default:{
                fatal("line x type error: %s but %s",TYPENAME[type],TYPENAME[getType(exp)]);
                printlnObject(exp,0);
                exit(1);
            }
        }
    } 
    case Key:{
        fprintf(stderr,"key and string does not allowed now\n");
        exit(1);
        break;
    }
	case Symbol:    break;
	case Pair:	    break;
	case Function:	break;
	case Binop: {
	    compOT(get(exp, Binop,lhs),type);
	    compOT(get(exp, Binop,rhs),type);
        emitI(Binop_oprand(type,get(exp,Binop,op),exp->Binop.line));
        break;
	}
	case Unyop:{
        compOT(get(exp, Unyop,rhs), type);
	    switch (get(exp, Unyop,op)){
            case NEG:{
                switch(type){
                    case _Integer: emitII(i_load,-1)           ;emitI(i_MUL);break;
                    case _Long:    emitIO(l_load,_newLong(-1)  ,_Long)  ;emitI(l_MUL);break;
                    case _Float:   emitIO(f_load,_newFloat(-1) ,_Float) ;emitI(f_MUL);break;
                    case _Double:  emitIO(d_load,_newDouble(-1),_Double);emitI(d_MUL);break;
                    default:fatal("line %d type error: %s type cannnot apply convert negative value\n",exp->Unyop.line,TYPENAME[type]);
                }
                break;
            }
            case BINC:{
                oop id = get(get(exp,Unyop,rhs),GetVar,id); 
                struct Variable *var =  set_id_index(id,vnt);
                switch(type){
                    case _Integer: emitII(i_load,1)          ;emitI(i_ADD);break;
                    case _Long:    emitIO(l_load,_newLong(1),_Long);emitI(l_ADD);break;
                    default: fatal("line %d type error: %s type cannot apply prefix increment, %s\n",exp->Unyop.line,TYPENAME[type],get(id,Symbol,name));
                }
                emitII(DEFINE+var->variable_num,var->index);emitII(GET+var->variable_num,var->index);
                break;
            }
            
            case BDEC:{
                oop id = get(get(exp,Unyop,rhs),GetVar,id); 
                struct Variable *var = set_id_index(id,vnt);
                switch(type){
                    case _Integer: emitII(i_load,1)          ;emitI(i_SUB);break;
                    case _Long:    emitIO(l_load,_newLong(1),_Long);emitI(l_SUB);break;
                    default: fatal("line %d type error: %s type cannot apply prefix decrement, %s\n",exp->Unyop.line,TYPENAME[type],get(id,Symbol,name));
                }
                emitII(DEFINE+var->variable_num,var->index);emitII(GET+var->variable_num,var->index);
                break;
            }
            case AINC:{
                oop id = get(get(exp,Unyop,rhs),GetVar,id); 
                struct Variable * var = set_id_index(id,vnt);
                emitII(GET+var->variable_num,var->index);
                switch(type){
                    case _Integer: emitII(i_load,         1) ;emitI(i_ADD);break;
                    case _Long:    emitIO(l_load,_newLong(1),_Long) ;emitI(l_ADD);break;
                    default: fatal("line %d type error: %s type cannot apply postfix increment, %s\n",exp->Unyop.line,TYPENAME[type],get(id,Symbol,name));
                }
                emitII(DEFINE+var->variable_num,var->index);
                break;
            }
            case ADEC:{
                oop id = get(get(exp,Unyop,rhs),GetVar,id); 
                struct Variable * var = set_id_index(id,vnt);
                emitII(GET+var->variable_num,var->index);
                switch(type){
                    case _Integer: emitII(i_load,         1) ;emitI(i_SUB);break;
                    case _Long:    emitIO(l_load,_newLong(1),_Long);emitI(l_SUB);break;
                    default: fatal("line %d type error: %s type cannot apply postfix decrement, %s\n",exp->Unyop.line,TYPENAME[type],get(id,Symbol,name));
                }
                emitII(DEFINE+var->variable_num,var->index);
                break;
            }
		    default:	assert(!"this cannot happen YNOP");
	    }
	    break;
    }

	case SetVar:{
        //int a = 10 or int add(int a,int b){return a + b} or state default{ event ... }
        int t     = get(exp,SetVar,typeset); //setting type of symbol
        oop id    = get(exp,SetVar,id);      //get symbol
        oop value = get(exp,SetVar,rhs);     //get value, = 10 or (int a,int b){return a + b}
        switch(getType(get(id,Symbol,value))){
            case Undefined:
            case _Integer:
            case _Float:
            case _Long:
            case _Double:break;
            case Function:{
                fatal("line %d definition error: function %s is already defined\n",exp->SetVar.line,get(id,Symbol,name));
                break;
            }
            case State:{
                fatal("line %d definition error: state %s is already defined\n",exp->SetVar.line,get(id,Symbol,name));
                break;
            }
            default:fatal("HACK SetVar");
        }
        switch(getType(value)){
            case Function:{
                get(value,Function,kind) = t;
                get(id,Symbol,value) = value;
                emitII(JUMP,0);             //First, when the code is loaded, the function is ignored (JUMP).
                vnt = newArray(0);          //Create symbol name table
                int jump = program->Array.number;
                int jump_i = program->Array.size;
                //CALL num: num is this number
                get(value,Function,position) = program->Array.number;
            emitII(MSUB,0);                 //rbp for variable
            int msub_loc = program->Array.size;
                oop para = get(value,Function,parameters);
                compPara(para,exp->SetVar.line);
                // vnt = args! check them!
                compOT(get(value,Function,body),t);
            int vnt_size = vnt->Array.size;
            Array_put(program,msub_loc  - 1, _newInteger(vnt_size));//change MSUB num
                int end  = program->Array.number;
                Array_put(program,jump_i - 1, _newInteger(end-jump));//change jump num
                break;
            }
            
            case State:{//†††
                int size = get(value,State,size);
                oop *events = get(value,State,events);
                int event_index[size];
                int Entry_bool = 0;

                // compile event
                int stt_val_c = 0;//for entry()
                for(int i=0;i<size; i++){
                    switch(getType(events[i])){
                        case SetArray:
                        case SetVar:{
                        //FIXME: 
                    /*
                        state s1{
                            e1{
                                ...
                            }
                            int a = 10;
                        }
                    */
                        isEntry = 1;
                        stt_val_c++;
                        compO(events[i]);
                        isEntry = 0;
                        break;
                        }
                        case Event:{
                            event_index[i] = program->Array.number;//where
                            if(get(events[i],Event,id)==entry_sym){
                                if(i-stt_val_c==0){
                                    Entry_bool = 1;
                                    isEntry = 1;
                                    compO(events[i]);
                                    isEntry = 0;
                                }
                                else{
                                    fprintf(stderr,"entry event should be defined first...\n");
                                    exit(1);
                                }
                            }
                            else {compO(events[i]);}
                            break;
                        }
                        default:fatal("line %d not apper\n",__LINE__);
                    }
                }
                
                // 状態遷移の位置
                int stt_loc = program->Array.number;
                value->State.index = stt_loc;


                if(Entry_bool==1){
                    emitII(ENTRY,event_index[stt_val_c] - (stt_loc));
                }
                emitII(THREAD,size - Entry_bool - stt_val_c);
                stt_loc = program->Array.number;

                                /*SIZE OP + SIZE INT */ //now
                // int d = stt_loc + (1 + INTSIZE)*size;
                for(int i=size;i>Entry_bool+stt_val_c;i--){
                                            // +5 => JUMP(1) num(4) => (size 5)
                    
                    oop eve1 = get(events[i-1],Event,id);
                    oop eve2 = get(eve1,Symbol,value);
                    if(getType(eve2)!=EventFunc){
                        fprintf(stderr,"this event is not define\n");
                        exit(1);
                    }
                    emitII(i_load,event_index[i-1] - stt_loc +(1 + INTSIZE));//d => stt_loc
                    for(int i=0;i<eve2->EventFunc.size_of_pin_num;i++){//gress, pin load
                        emitII(i_load,eve2->EventFunc.pin_num[i]);
                    }
                    emitOIII(CALL_E, eve2->EventFunc.lib_num, eve2->EventFunc.eve_num, eve2->EventFunc.size_of_pin_num)//now
                }

                get(id,Symbol,value) = value;
                Local_VNT = newArray(0);
                break;
            }

            default:{
                if(isEntry==0){
                    oop ass = assoc(id,Global_VNT);
                    if(ass!=nil){
                        if(t!=Undefined)fatal("line %d variable error: %s is defined in Global variable\n",exp->SetVar.line,get(id,Symbol,name));
                        compOT(value,ass->Assoc.kind);
                        emitII(DEFINE_G,ass->Assoc.index); 
                    }
                    else if((ass = assoc(id, Local_VNT))!=nil){
                        if(t!=Undefined)fatal("line %d variable error: %s is defined in Local variable\n",exp->SetVar.line,get(id,Symbol,name));
                        compOT(value,ass->Assoc.kind);
                        emitII(DEFINE_L,ass->Assoc.index); 
                    }
                    else{
                        ass = assoc(id,vnt);
                        if(ass == nil){
                            if(t==Undefined)//it is first time defining this symbol, indicate type.
                                fatal("line %d variable error: Undefined variable %s\n",exp->SetVar.line,get(exp, SetVar,id)->Symbol.name);
                            //define new symbol with type
                            ass = newAssoc(get(exp, SetVar,id),t,vnt->Array.size);
                            Array_push(vnt, ass);
                        }
                        else if(t!=Undefined){
                            fatal("line %d variable error:    %s\n",exp->SetVar.line,get(exp, SetVar,id)->Symbol.name);
                        }
                        compOT(value,ass->Assoc.kind);
                        emitII(DEFINE,ass->Assoc.index); 
                    }
                }else{// in the entry(){...}
                    oop ass = assoc(id,Global_VNT);
                    if(ass!=nil){
                        if(t!=Undefined)fatal("line %d variable error: %s is defined in Global variable\n",exp->SetVar.line,get(id,Symbol,name));
                        compOT(value,ass->Assoc.kind);
                        emitII(DEFINE_G,ass->Assoc.index); 
                    }
                    else{
                        ass = assoc(id, Local_VNT);
                        if(ass == nil){
                            if(t==Undefined)//it is first time defining this symbol, indicate type.
                                fatal("line %d variable error: Undefined variable %s\n",exp->SetVar.line,get(exp, SetVar,id)->Symbol.name);
                            //define new symbol with type
                            ass = newAssoc(get(exp, SetVar,id),t,Local_VNT->Array.size);
                            Array_push(Local_VNT, ass);
                        }
                        else if(t!=Undefined){
                            fatal("line %d variable error:    %s\n",exp->SetVar.line,get(exp, SetVar,id)->Symbol.name);
                        }
                        compOT(value,ass->Assoc.kind);
                        emitII(DEFINE_L,ass->Assoc.index); 
                    }
                }

            }
        }
	    break;
    }

    case SetVarG:{
        emitI(GLOBAL);
        int t     = get(exp,SetVarG,typeset); //setting type of symbol
        oop id    = get(exp,SetVarG,id);      //get symbol
        oop value = get(exp,SetVarG,rhs);     //get value, = 10 or (int a,int b){return a + b}
        oop ass = assoc(get(exp, SetVarG,id),Global_VNT);
        if(ass == nil){
            if(t==Undefined){//it is first time defining this symbol, indicate type.
                fatal("line %d variable error: Undefined variable %s\n",exp->SetVarG.line,get(exp, SetVarG,id)->Symbol.name);
            }
            //define new symbol with type
            ass = newAssoc(get(exp, SetVarG,id),t,Global_VNT->Array.size);
            Array_push(Global_VNT, ass);
        }
        t = ass->Assoc.kind;
        compOT(value,t);
        emitII(DEFINE_G,ass->Assoc.index);   
        emitI(GLOBAL_END);      
        break;
    }

	case GetVar:{
        oop id = get(exp,GetVar,id);
        oop ass = assoc(id,Global_VNT);
        if(ass!=nil){
            if(ass->Assoc.kind != type)//The requested type and symbol do not match
                fatal("line %d type error: requared [%s] type but [%s] type, global variable %s\n",exp->GetVar.line,TYPENAME[type],TYPENAME[ass->Assoc.kind],id->Symbol.name);
            emitII(GET_G,ass->Assoc.index);
        }
        else if((ass=assoc(id,Local_VNT))!=nil){
            if(ass->Assoc.kind!=type)
                fatal("line %d type error: requared %s type but %s type, local variable %s",exp->GetVar.line,TYPENAME[type],TYPENAME[ass->Assoc.kind],id->Symbol.name);
            emitII(GET_L,ass->Assoc.index);
        }
        else if((ass = assoc(id,vnt))!=nil){
            if(ass->Assoc.kind!=type)
                fatal("line %d type error: requared %s type but %s type, nomal variable %s",exp->GetVar.line,TYPENAME[type],TYPENAME[ass->Assoc.kind],id->Symbol.name);
            emitII(GET,ass->Assoc.index);
        }
        else{     //sym is not define
                fatal("line %d variable error: Undefine variable, %s\n",exp->GetVar.line,id->Symbol.name);
        }
        break;
    }
    // in progress
    case SetArray:{
        int t =      get(exp,SetArray,typeset);
        oop id =     get(exp,SetArray,array);
        oop values = get(exp,SetArray,value);
        oop index =  get(exp,SetArray,index);
        oop ass   = nil;
        printf("gt %2d\n",getType(Global_VNT));
        printf("lt %2d\n",getType(Local_VNT));
        printf("t  %2d\n",getType(vnt));
        if((ass = assoc(id,Global_VNT))==nil){
            if((ass = assoc(id,Local_VNT))==nil){
                if((ass = assoc(id,vnt))==nil){
                    if(t!=Undefined){
                        //in progress
                        user_error(getType(values)!=Block,"definitnion error: list\n",get(exp,SetArray,line));
                        oop value = newList_d1(_IntegerArray);
                        get(id,Symbol,value) = value;
                        ass = newAssoc(id,t,vnt->Array.size);
                        Array_push(vnt, ass);
                        int size = get(values,Block,size);
                        for(int i=0;i<size;i++){
                            compOT(values->Block.statements[i],t);
                        }
                        compOT(index,_Integer);
                        emitII(il_load,ass->Assoc.index);
                        return exp;
                    }else{
                        user_error(1,"definition error: Undefined variable\n",get(exp,SetArray,line));
                    }
                }
            }
        }
        //　要素の変更
        if(t==Undefined){
            user_error(getType(values)==Block,"definition error: not allow muti values",get(exp,SetArray,line));
            switch(get(ass,Assoc,kind)){
                case _Integer:{
                    compOT(values,ass->Assoc.kind);
                    compOT(index,ass->Assoc.kind);
                    emitII(DEFINE_List,ass->Assoc.index);
                    break;
                }
                case _Long:
                case _Double:
                case _Float:
                default:{
                    fprintf(stderr,"line %d: type error: not match\n",get(exp,SetArray,line));
                    exit(1);
                }
            }
        }else{
            fprintf(stderr,"line %d definition error: defined variable\n",get(exp,SetArray,line));
            exit(1);
        }
        break;
    }
    case GetArray:{
        int t =     get(exp,SetArray,typeset);
        oop id =    get(exp,SetArray,array);
        oop value = get(exp,SetArray,value);
        oop index = get(exp,SetArray,index);
    }

	case Call:{
        oop id = exp->Call.function;
        oop function = get(id,Symbol,value);
	    switch (getType(function)){
            case Function:{
                int t = get(function,Function,kind);
                if(type!=Undefined && type!=t){
                    fatal("line %d type error: %s type but %s type, function %s\n",exp->Call.line,TYPENAME[type],TYPENAME[t],id->Symbol.name);
                }
                oop args   = get(exp,Call,arguments);
                oop params = get(function, Function,parameters);
                int num = compArgs(program,params,args,vnt);//leg11
                int i = program->Array.number;
                            /*number of args*/ /*function location*/
                emitOII(CALL,num, get(function,Function,position) - i -(OPESIZE + INTSIZE*2));
                break;
            }
            case Primitive:{
                char t       = get(function,Primitive,return_type);
                if(type!=Undefined && type!=t){
                    fatal("line %d type error: %s type but %s type, function %s\n",exp->Call.line,TYPENAME[type],TYPENAME[t],id->Symbol.name);
                }
                char* para_t = get(function,Primitive,args_type_array);
                char para_s  = get(function,Primitive,size_of_args_type_array);
                oop   args   = get(exp,Call,arguments);
                for(int i=0; i<para_s ;i++){
                    if(args == nil){
                        fprintf(stderr,"error: PRIMITVE\n");
                        exit(1);
                    }
                    compOT(args->Pair.a, para_t[i]);
                    args = args->Pair.b;
                }
                emitOIII(CALL_P,get(function,Primitive, lib_num),get(function,Primitive,func_num),para_s);
                break;
            }
            case EventFunc:{
                // set pin or trigger conditino value.
                // in this here, not compile anything.
                if(isEntry!=1){
                    fprintf(stderr,"Definition Error: Event functions cannot be initialized except by the setup event function\n ");
                    exit(1);
                }
                oop args = get(exp,Call,arguments);
                char size = get(function,EventFunc,size_of_pin_num);
                for(int i=0; i< size;i++){//#
                    assert(getType(args->Pair.a)==Integer);
                    function->EventFunc.pin_num[i] =  atoi(args->Pair.a->Integer.number);
                    args = args->Pair.b;
                }
                break;
            }
            default:printlnObject(function,2);fatal("line %d HACK: this cannot happen CALL %s\n",exp->Call.line,TYPENAME[getType(function)]);
	    }
        
	    break;
    }

	case Print:{
        compOT(get(exp, Print,argument),get(exp,Print,kind));
        //TODO: make four type of print
        int k_type = get(exp,Print,kind);
        switch(k_type){
            case _Integer:emitI(i_PRINT);break;
            case _Long   :emitI(l_PRINT);break;
            case _Float  :emitI(f_PRINT);break;
            case _Double :emitI(d_PRINT);break;
            case String  :emitI(s_PRINT);break;
            case _Char   :emitI(c_PRINT);break;
        }
        break;
    }

	case If:{// ENTRY...
        int c_type = child_type(get(exp, If,condition),vnt);
        switch(c_type){
            case Integer: c_type = _Integer;break;
            case Float:   c_type = _Float;  break;
            default:break;
        }
        compOT(get(exp, If,condition),c_type);
        emitII(JUMPF,0);//->done or else
        int jump1 = program->Array.number;
        int jump1_i = program->Array.size;
        int size =0;
        compStatement(get(exp,If,statement1),type);
        // size  = vnt->Array.size;//kill
        // compOT(get(exp, If,statement1),type);/* if */
        // kill_assoc(vnt,size);//kill
        oop stmt2 = get(exp,If,statement2);
        //else
        if(stmt2 != sys_false){
            emitII(JUMP,0);//->done
            int jump2 = program->Array.number;
            int jump2_i = program->Array.size;
            
            int p_else = jump2; /* else */

            compStatement(stmt2,type);
            // size = vnt->Array.size;//kill
            // compOT(stmt2,type);
            // kill_assoc(vnt,size);//kill


            int p_done = program->Array.number;/* done */
            Array_put(program, jump1_i- 1, _newInteger(p_else - jump1));/* jumpf -> else */
            Array_put(program, jump2_i- 1, _newInteger(p_done - jump2));/* jump  -> done */
        }
        else{// not else
            Array_put(program, jump1_i- 1, _newInteger(program->Array.number - jump1));/* jumpf -> else */
        }
        break;
    }

	case While:{
        b_push(-1);//MEMO: negative value is mark for break
        c_push(-1);//MEMO: negative value is mark for continue
        int L1 = program->Array.number;/*cond*/
        int size = 0;
        compStatement(get(exp,While,condition),_Integer);
        // size = vnt->Array.size;//kill
        // compOT(get(exp, While,condition),_Integer);
        // kill_assoc(vnt,size);

        emitII(JUMPF,0);
        int L2 = program->Array.number;
        int L2_i = program->Array.size;
        

        compStatement(get(exp,While,statement),type);
        // size = vnt->Array.size;//kill
        // compOT(get(exp, While,statement),type);//err
        // kill_assoc(vnt,size);
        


        emitII(JUMP, 0);
        int L4 = program->Array.number;/*done*/
        int L4_i = program->Array.size;/*done*/
        Array_put(program,L2_i - 1,_newInteger(L4-L2));/* jumpf -> done */
        Array_put(program,L4_i - 1,_newInteger(L1-L4)); /* jump  -> cond */

        for(;;){
            int i = c_pop();
            if(i<0)break;
            Array_put(program,c_pop() - 1,_newInteger(L1 - i));
        }
        for(;;){
            int i = b_pop();
            if(i<0)break;
            Array_put(program,b_pop() - 1,_newInteger(L4 - i));
        }
        break;
    }

    case For:{//for(initstate,condition,updata){ statement }
        b_push(-1);//MEMO: negative value is mark for break
        c_push(-1);//MEMO: negative value is mark for continue
        int size = 0;
        if(isEntry==0) size  = vnt->Array.size; 
        else           size  = Local_VNT->Array.size; 
        
        if(get(exp,For,initstate)!=nil)
            compO(get(exp,For,initstate));//for(int i = 0,...)
        
        emitII(JUMP,0);//jump update
        int L1   = program->Array.number;
        int L1_s = program->Array.size;
        if(get(exp,For,update)!=nil)
            compOT(get(exp,For,update),Undefined);
        int L2 = program->Array.number;
        int L2_s = program->Array.size;
        if(get(exp,For,condition)!=nil)
            compOT(get(exp,For,condition),_Integer);
        else{emitII(i_load,1);}
        emitII(JUMPF,0);
        int jumpf = program->Array.number;
        int jumpf_s = program->Array.size;

        compOT(get(exp,For,statement),type);
        emitII(JUMP,0);
        int done    = program->Array.number;
        int done_s  = program->Array.size;

        if(isEntry==0)  kill_assoc(vnt,size); 
        else            kill_assoc(Local_VNT,size);
        
    Array_put(program,L1_s -1,_newInteger(L2 - L1));/* jump first update */
    Array_put(program,done_s -1,_newInteger(L1 - done));/*done -> update */
    Array_put(program,jumpf_s-1,_newInteger(done - jumpf)); /* jumf  -> done */
    kill_assoc(vnt,size);//kill env

        for(;;){
            int i = c_pop();
            if(i<0)break;
            Array_put(program,c_pop() - 1,_newInteger(L1 - i));
        }
        for(;;){
            int i = b_pop();
            if(i<0)break;
            Array_put(program,b_pop() - 1,_newInteger(done - i));
        }
        break;
        break;
    }
    case Break:{
        emitII(JUMP,0);
        b_push(program->Array.size);
        b_push(program->Array.number);
        break;
    }
    case Continue:{
        emitII(JUMP,0);
        c_push(program->Array.size);
        c_push(program->Array.number);
        break;
    }
    case Return:{
        compOT(get(exp,Return,value),type);
        emitI(RET);
        break;
    }
	case Block:{
        oop *statements = get(exp, Block,statements);
	    int  size       = get(exp, Block,size);
	    for (int i = 0;  i < size;  ++i){
            compOT(statements[i],type);
        }    
	    break;
    }
    case Event:{
        emitII(JUMP,0);
    int jump_i = program->Array.size;
    int jump = program->Array.number;

        oop id    = get(exp, Event, id);
        oop para  = get(exp, Event, parameters);
        oop block = get(exp, Event, body);
        vnt = newArray(0);
        int m_loc = program->Array.size;

        if(id!=entry_sym){//isEntry: assign should be define STT local
            oop eve   = get(id,Symbol, value);
            int args_s =  eve->EventFunc.size_of_args_type_array;
            char *args =  eve->EventFunc.args_type_array;
    //now: check parameter: e,g,. timer(int n) <= int n
            for(int i=0;i<args_s;i++){
                if(para==nil){fprintf(stderr,"event fuction args tatinai error\n");exit(1);}
                oop a = get(para,Pair,a);
                if(args[i]!=getType(a->Pair.a)){fprintf(stderr,"event fuction args[%s]!=para[%s] error\n",TYPENAME[args[i]],TYPENAME[getType(a->Pair.a)]);exit(1);}
                if(assoc(a->Pair.b,vnt)!=nil)
                    fatal("type error: cannot apply same symbol in parameter\n");
                if(assoc(a->Pair.b,Global_VNT)!=nil)
                    fatal("variable error: %s parameter in Global variable\n",get(para->Pair.b,Symbol,name));
                /* LOCAL VNT */           
                oop ass  = newAssoc(a->Pair.b,args[i],vnt->Array.size);
                Array_push(vnt,ass);
                para = para->Pair.b;
            }
        }
        compO(block);
    int m_size = vnt->Array.size;
    Array_put(program,m_loc -1, _newInteger(m_size));
        vnt = nil;
        isEntry = 0;//entry() 
        emitI(MPOP);
        emitI(EOE);
    Array_put(program,jump_i -1,_newInteger(program->Array.number - jump));// jump event 
        break;
    }

    case State:{
        printf("state\n");
        exit(0);
    }
    case Run:{
        oop id = get(exp,Run,state);
        emitII(TRANS,0);
        int L = program->Array.number;
        int L_i = program->Array.size;

        state_Pair = newPair(newPair(id,newPair(_newInteger(L_i),_newInteger(L))),state_Pair);
        break;
    }
    case END:{
        while(state_Pair->type == Pair){
            oop node = state_Pair->Pair.a;
            oop id = node->Pair.a;//state that is called
            int to_index = id->Symbol.value->State.index;//†††
            oop index = node->Pair.b;//index that state call
            int from_index_i = _Integer_value(index->Pair.a);
            int from_index = _Integer_value(index->Pair.b);
            //†††
            Array_put(program,from_index_i - 1,_newInteger(to_index - from_index));
            state_Pair = state_Pair->Pair.b;
        }
        return sys_false;
    }
	default:{
        printf("%s\n",TYPENAME[exp->type]);
        assert(!"this cannot happen compile");
    }
    
    }
    return exp;
}


/*
    begin memory
*/

void _error(char *msg, char *file, int line)
{
    fprintf(stderr, "\n%s(%d) ", file, line);
    perror(msg);
    exit(1);
}

#define error(X) _error(X, __FILE__, __LINE__)
typedef unsigned char byte;

byte   *memory  = 0;  // memory is a huge array of bytes
size_t  memsize = 0;  // this is the current size of data stored in memory
size_t  memcap  = 0;  // this is the maximum dize of data that memory can hold

void _genByte(byte b)  // append one byte the the memory
{
    if  (memsize >= memcap) { // memory is full, extend it
        memcap = memcap ? memcap * 2 : 1024;   // 1k, 2k, 4k, 8k, 16k, ...
        memory = realloc(memory, memcap);
    }
    assert(memsize < memcap);
    memory[memsize++] = b;
}

void memoryClear(void) // clear the contents of memory
{
    free(memory);
    memory  = 0;
    memsize = 0;
    memcap  = 0;
}

#define genByte(A,B) ({\
    for(int i=0;i<B;i++){\
        _genByte(A[i]);\
    }\
})

const unsigned int SIZE_INST   = sizeof(unsigned char);
const unsigned int SIZE_INT    = sizeof(int);            //size of int
const unsigned int SIZE_LONG   = sizeof(long long int);  //size of long long int
const unsigned int SIZE_FLOAT  = sizeof(float);          //size of float
const unsigned int SIZE_DOUBLE = sizeof(double);         //size of double

#define genData(S,D) ({ \
    unsigned char buffer[S]; \
    memcpy(buffer, &D, S); \
    genByte(buffer,S); \
})

void genOp(int data){
    _genByte((byte)data);
}

#define genChar(A) _genByte((byte)A)

void genInt(int data){
    genData(SIZE_INT,data);
}

void genLong(long long int data){
    genData(SIZE_LONG,data);
}

void genFloat(float data){
    genData(SIZE_FLOAT,data);
}

void genDouble(double data){
    genData(SIZE_DOUBLE,data);
}

void genString(char *data){
    genByte(data,strlen(data));
    _genByte('\0');
}


void memoryWrite(char *path) // write memory to a file
{
    FILE *fp = fopen(path, "w");
    if (!fp) error(path);
    if (memsize != fwrite(memory, 1, memsize, fp)) // write memory to file
	error(path);
    fclose(fp);
}

/* READ */



void memoryRead(char *path) // read memory from an external file
{
    struct stat buf;
    if (stat(path, &buf)) error(path); // get file information including size

    FILE *fp = fopen(path, "r");
    if (!fp) error(path);

    memsize = memcap = buf.st_size; // set memory size same as file size
    memory = malloc(memsize);       // allocate just the right amount of memory
    if (!memory) error("malloc");

    if (memsize != fread(memory, 1, memsize, fp)) // read memory from file
	error(path);
    fclose(fp);
}


/*
    end memory
*/


oop CodeWrite(oop program){
    int pc = 0;
    oop stack = newArray(10);
    for(;;){
#if TEST
        // printf("%3d\n",pc);
#endif
        oop inst = Array_get(program,pc++);
        if(getType(inst)!=_Integer){
            printf("[%s] ",TYPENAME[getType(inst)]);
            printlnObject(inst,0);
        }
        int op = _Integer_value(inst);
        genOp(op);
        switch(op){
            case TRANS: genInt(_Integer_value(Array_get(program,pc++)));continue;
            case i_load:genInt(_Integer_value(Array_get(program,pc++)));continue;
            case l_load:genLong(Array_get(program,pc++)->_Long.value);continue;
            case f_load: genFloat(_Float_value(Array_get(program,pc++)));continue;
            case d_load: genDouble(Array_get(program,pc++)->_Double.value);continue;
            case c_load: genChar(_Char_value(Array_get(program,pc++)));continue;
            case s_load: genString(Array_get(program,pc++)->String.value);continue;
            case il_load:genInt(_Integer_value(Array_get(program,pc++)));continue;
            case i_EQ:   continue; 
            case i_NE:   continue; 
            case i_LT:   continue; 
            case i_LE:   continue; 
            case i_GE:   continue; 
            case i_GT:   continue; 
            case i_ADD:  continue;
            case i_SUB:  continue;
            case i_MUL:  continue;
            case i_DIV:  continue;
            case i_MOD:  continue;
            case l_EQ:   continue; 
            case l_NE:   continue; 
            case l_LT:   continue; 
            case l_LE:   continue; 
            case l_GE:   continue; 
            case l_GT:   continue; 
            case l_ADD:  continue;
            case l_SUB:  continue;
            case l_MUL:  continue;
            case l_DIV:  continue;
            case l_MOD:  continue;
            case f_EQ:   continue; 
            case f_NE:   continue; 
            case f_LT:   continue; 
            case f_LE:   continue; 
            case f_GE:   continue; 
            case f_GT:   continue; 
            case f_ADD:  continue;
            case f_SUB:  continue;
            case f_MUL:  continue;
            case f_DIV:  continue;
            case d_EQ:   continue; 
            case d_NE:   continue; 
            case d_LT:   continue; 
            case d_LE:   continue; 
            case d_GE:   continue; 
            case d_GT:   continue; 
            case d_ADD:  continue;
            case d_SUB:  continue;
            case d_MUL:  continue;
            case d_DIV:  continue;

            case s_EQ:   continue; 
            case s_NE:   continue; 
            case s_LT:   continue; 
            case s_LE:   continue; 
            case s_GE:   continue; 
            case s_GT:   continue; 
            case s_ADD:  continue;

            case THREAD: genInt(_Integer_value(Array_get(program,pc++)));continue;
            case EOE:    continue;
            case CALL:{
                genInt(_Integer_value(Array_get(program,pc++)));
                genInt(_Integer_value(Array_get(program,pc++)));
                continue;
            }
            case CALL_P:{
                genInt(_Integer_value(Array_get(program,pc++)));
                genInt(_Integer_value(Array_get(program,pc++)));
                genInt(_Integer_value(Array_get(program,pc++)));
                continue;
            }
            case CALL_E:{
                genInt(_Integer_value(Array_get(program,pc++)));
                genInt(_Integer_value(Array_get(program,pc++)));
                genInt(_Integer_value(Array_get(program,pc++)));
                continue;         
            }
            case GET:{
                genInt(_Integer_value(Array_get(program,pc++)));
                continue;
            }
            case GET_L:{
                genInt(_Integer_value(Array_get(program,pc++)));
                continue;
            }
            case GET_G:{
                genInt(_Integer_value(Array_get(program,pc++)));
                continue;
            }
            case DEFINE:{
                genInt(_Integer_value(Array_get(program,pc++)));
                continue;
            }
            case DEFINE_L:{
                genInt(_Integer_value(Array_get(program,pc++)));
                continue;
            }
            case DEFINE_G:{
                genInt(_Integer_value(Array_get(program,pc++)));
                continue;
            }  
            case DEFINE_List:{
                genInt(_Integer_value(Array_get(program,pc++)));
                continue;
            }  
            case ENTRY:{
                genInt(_Integer_value(Array_get(program,pc++)));
                continue;
            }
            case GLOBAL:{
                continue;
            }
            case GLOBAL_END:{
                continue;
            }
            case SETQ:{
                continue;
            }
            case RET:{
                continue;
            }
            case MSUB:{
                genInt(_Integer_value(Array_get(program,pc++)));
                continue;
            }
            case MPOP:{
                continue;
            }
            case MPICK:{
                genInt(_Integer_value(Array_get(program,pc++)));
                genInt(_Integer_value(Array_get(program,pc++)));
                continue;
            }
            case MSET:{
                genInt(_Integer_value(Array_get(program,pc++)));
                continue;
            }
            case JUMPF:{
                genInt(_Integer_value(Array_get(program,pc++))); 
                continue;
            }
            case JUMP:{
                genInt(_Integer_value(Array_get(program,pc++))); 
                continue;       
            }
            case i_PRINT:{
                continue;
            }
            case l_PRINT:{
                continue;
            }
            case f_PRINT:{
                continue;
            }
            case d_PRINT:{
                continue;
            }
            case c_PRINT:{
                continue;
            }
            case s_PRINT:{
                continue;
            }
            case HALT:{
                return nil;
            }
        }
    }
}



















/*
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                    main code
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
*/

int has_txt_extension(const char *filename) {
    const char *ext = strrchr(filename, '.');  // ファイル名中の最後の'.'を探す
    if (ext != NULL && strcmp(ext, ".txt") == 0) {
        return 1;  // .txt拡張子がある場合は1を返す
    }
    return 0;      // それ以外の場合は0を返す
}



typedef enum {Default, VarI, VarII, VarF, VarFF, VarT, VarTI} VAR;

typedef enum {F_NONE, F_EOE, F_TRANS, F_ERROR} FLAG;
FLAG sub_execute(oop,oop);
void main_execute();
oop printCode(oop);
oop printByteCode();

#define ARRAY_DEF(name, size, ...) ({oop name##__ = intern("sss");})


int main(int argc, char const *argv[])
{
    // コマンドライン引数の確認
    if (argc == 2){

    // ファイル名の拡張子をチェック
    if (!has_txt_extension(argv[1])) {
        fprintf(stderr, "エラー: ファイルは .txt 拡張子でなければなりません\n");
        return 1;
    }

    // ファイルを読み込みモードで開く
    SOURCE_FILE = fopen(argv[1], "r");
    if (SOURCE_FILE == NULL) {
        perror("ファイルを開けませんでした");
        return 1;
    }

    setting_stdlib();
    nil   = newObject(Undefined);
    sys_false = _newInteger(0);
    sys_true  = _newInteger(1);
    none  = _newInteger(2);
    entry_sym = intern("entry");
    ARRAY_DEF(heke,1,2);
    newSymbol("exit");
    state_Pair = nil;
    oop program = newArray(0);
    Local_VNT   = newArray(0);
    Global_VNT  = newArray(0);
    
    printf("    compile     %d%s\n",argc,argv[0]);
    printf("\n \x1b[31m parsing ******************\x1b[0m\n\n");
    emitII(MSET,0);
    while (yyparse()) {
        // printlnObject(result, 0);
        if(sys_false == compile(program,result,nil,Undefined))break;
    }
    emitI(HALT);
    Array_put(program,1,_newInteger(Global_VNT->Array.size));
#if TEST
    printf("Successful\n");
    printf("\n \x1b[31m print code *********************\x1b[0m\n\n");
    printCode(program);
#endif
    printf("\n \x1b[31m write code *********************\x1b[0m\n\n");
    CodeWrite(program);
    memoryWrite("code.stt");
#if TEST
    printf("\n \x1b[31m print byte code after memory write ******************\x1b[0m\n\n");
    printByteCode();
#endif
    
#if TEST
    printf("\n \x1b[31m print byre code *********************\x1b[0m\n\n");
    printf("memory_size %zu\n",memsize);
#endif
    free(program);
    free(symbols);
    memoryClear();
}else if(argc == 1){
    printf("    execute     %d %s\n",argc,argv[0]);

    printf("\n \x1b[31m read code ******************\x1b[0m\n\n");
    struct timeval startTime, endTime;  // 構造体宣言
    clock_t startClock, endClock;       // clock_t型変数宣言
    
    gettimeofday(&startTime, NULL);     // 開始時刻取得
    startClock = clock();               // 開始時刻のcpu時間取得

    memoryRead("code.stt");
#if TEST
    printf("memory_size %zu\n",memsize);
#endif
    printf("\n \x1b[31m print byte code after memory read ******************\x1b[0m\n\n");
    printByteCode();
    printf("\n \x1b[31m main_execute code ******************\x1b[0m\n\n");
    main_execute();
    printf("\n \x1b[31m**************************\x1b[0m\n"); 
    gettimeofday(&endTime, NULL);       // 開始時刻取得
    endClock = clock();                 // 開始時刻のcpu時間取得
    
    time_t diffsec = difftime(endTime.tv_sec, startTime.tv_sec);    // 秒数の差分を計算
    suseconds_t diffsub = endTime.tv_usec - startTime.tv_usec;      // マイクロ秒部分の差分を計算
    //以下の処理は不要(15/10/28)
    //if (diffsub < 0) {                                              // マイクロ秒が負になったとき
    //    diffsec -= 1;                                               // 秒部分を繰り下げ
    //    diffsub = 1000000 + diffsub;                                // 1秒との差
    //}
    double realsec = diffsec+diffsub*1e-6;                          // 実時間を計算
    double cpusec = (endClock - startClock)/(double)CLOCKS_PER_SEC; // cpu時間を計算
    printf("%f\n",realsec);
    printf("%f\n",cpusec);
    double percent = 100.0*cpusec/realsec;                          // 使用率を100分率で計算
    printf("CPU使用率%f %%\n", percent);                            // 表示
    }else{
        fprintf(stderr, "使用方法: %s <ファイル名>\n", argv[0]);
        return 1;
    }
    return 0;
}

/*
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                        print  code
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
*/


oop printCode(oop program){
    int pc = 0;
    oop stack = newArray(10);
    for(;;){
        printf("%3d ",pc);
        oop inst = Array_get(program,pc++);
        if(getType(inst)!=_Integer){
            printf("[%s] ",TYPENAME[getType(inst)]);
            printlnObject(inst,0);
        }
        switch(_Integer_value(inst)){
            case TRANS:  printf("TRANS     %3d\n",_Integer_value(Array_get(program,pc++)));continue;
            case i_load: printf("i_load    %3d\n",_Integer_value(Array_get(program,pc++)));continue;
            case l_load: printf("l_load    %3lld\n",Array_get(program,pc++)->_Long.value);continue;
            case f_load: printf("f_load    %3f\n",_Float_value(Array_get(program,pc++)));continue;
            case d_load: printf("d_load    %3f\n",Array_get(program,pc++)->_Double.value);continue;
            case c_load: printf("i_load    %3c\n",_Char_value(Array_get(program,pc++)));continue;
            case s_load: printf("s_load    %s\n", Array_get(program,pc++)->String.value);continue;
            case il_load: printf("il_load    %d\n", _Integer_value(Array_get(program,pc++)));continue;
            case i_EQ:   printf("i_EQ\n"); continue; 
            case i_NE:   printf("i_NE\n"); continue; 
            case i_LT:   printf("i_LT\n"); continue; 
            case i_LE:   printf("i_LE\n"); continue; 
            case i_GE:   printf("i_GE\n"); continue; 
            case i_GT:   printf("i_GT\n"); continue; 
            case i_ADD:  printf("i_ADD\n");continue;
            case i_SUB:  printf("i_SUB\n");continue;
            case i_MUL:  printf("i_MUL\n");continue;
            case i_DIV:  printf("i_DIV\n");continue;
            case i_MOD:  printf("i_MOD\n");continue;
            case l_EQ:   printf("l_EQ\n");continue; 
            case l_NE:   printf("l_NE\n");continue; 
            case l_LT:   printf("l_LT\n");continue; 
            case l_LE:   printf("l_LE\n");continue; 
            case l_GE:   printf("l_GE\n");continue; 
            case l_GT:   printf("l_GT\n");continue; 
            case l_ADD:  printf("l_ADD\n");continue;
            case l_SUB:  printf("l_SUB\n");continue;
            case l_MUL:  printf("l_MUL\n");continue;
            case l_DIV:  printf("l_DIV\n");continue;
            case l_MOD:  printf("l_MOD\n");continue;
            case f_EQ:   printf("f_EQ\n");continue; 
            case f_NE:   printf("f_NE\n");continue; 
            case f_LT:   printf("f_LT\n");continue; 
            case f_LE:   printf("f_LE\n");continue; 
            case f_GE:   printf("f_GE\n");continue; 
            case f_GT:   printf("f_GT\n");continue; 
            case f_ADD:  printf("f_ADD\n");continue;
            case f_SUB:  printf("f_SUB\n");continue;
            case f_MUL:  printf("f_MUL\n");continue;
            case f_DIV:  printf("f_DIV\n");continue;
            case d_EQ:   printf("d_EQ\n");continue; 
            case d_NE:   printf("d_NE\n");continue; 
            case d_LT:   printf("d_LT\n");continue; 
            case d_LE:   printf("d_LE\n");continue; 
            case d_GE:   printf("d_GE\n");continue; 
            case d_GT:   printf("d_GT\n");continue; 
            case d_ADD:  printf("d_ADD\n");continue;
            case d_SUB:  printf("d_SUB\n");continue;
            case d_MUL:  printf("d_MUL\n");continue;
            case d_DIV:  printf("d_DIV\n");continue;
            case s_EQ:   printf("d_EQ\n");continue; 
            case s_NE:   printf("d_NE\n");continue; 
            case s_LT:   printf("d_LT\n");continue; 
            case s_LE:   printf("d_LE\n");continue; 
            case s_GE:   printf("d_GE\n");continue; 
            case s_GT:   printf("d_GT\n");continue; 
            case s_ADD:  printf("d_ADD\n");continue;
            case THREAD: printf("thread    %3d\n",_Integer_value(Array_get(program,pc++)));continue;
            case EOE:    printf("EOE\n");continue;

            case CALL:{
                printf("CALL      ");//T
                oop num_arg = Array_get(program,pc++);
                oop index = Array_get(program,pc++);
                printf("%3d  %3d\n",_Integer_value(num_arg),_Integer_value(index));
                continue;
            }
            case CALL_P:{
                printf("CALL_P     ");//T
                oop lib_num  = Array_get(program,pc++);
                oop func_num = Array_get(program,pc++);
                oop num_args = Array_get(program,pc++);
                printf("%3d  %3d  %3d\n",_Integer_value(lib_num),_Integer_value(func_num),_Integer_value(num_args));
                continue;
            }
            case CALL_E:{
                printf("CALL_E     ");//T
                oop lib_num  = Array_get(program,pc++);
                oop func_num = Array_get(program,pc++);
                oop num_args = Array_get(program,pc++);
                printf("%3d  %3d  %3d\n",_Integer_value(lib_num),_Integer_value(func_num),_Integer_value(num_args));
                continue;
            }
            case GET:{
                printf("Get       ");//T
                oop symbol = Array_get(program,pc++);
                printlnObject(symbol,1);//T
                continue;
            }
            case GET_L:{
                printf("Get_L     ");//T
                oop symbol = Array_get(program,pc++);
                printlnObject(symbol,1);//T
                continue;
            }
            case GET_G:{
                printf("GET_G     ");
                oop symbol = Array_get(program,pc++);
                printlnObject(symbol,1);
                continue;
            }
            case DEFINE:{
                printf("DEFINE    ");//T
                oop symbol = Array_get(program,pc++);
                printlnObject(symbol,1);//T
                continue;
            }
            case DEFINE_L:{
                printf("DEFINE_L    ");//T
                oop symbol = Array_get(program,pc++);
                printlnObject(symbol,1);//T
                continue;
            }
            case DEFINE_G:{
                printf("DEFINE_G  ");//T
                oop symbol = Array_get(program,pc++);
                printlnObject(symbol,1);//T
                continue;
            }  
            case DEFINE_List:{
                printf("DEFINE_List  ");//T
                oop symbol = Array_get(program,pc++);
                printlnObject(symbol,1);//T
                continue;
            }  
            case GLOBAL:{
                printf("GLOBAL\n");
                continue;
            }
            case GLOBAL_END:{
                printf("GLOBAL_END\n");
                continue;
            }
            case ENTRY:{
                printf("ENTRY     %3d\n",_Integer_value(Array_get(program,pc++)));
                continue;
            }
            case SETQ:{
                printf("SETQ\n");
                continue;
            }
            case RET:{
                printf("RET       ");
                printf("  X\n");
                continue;
            }
            case MSUB:{
                printf("MSUB      ");
                printlnObject(Array_get(program,pc++),1);
                continue;
            }
            case MPOP:{
                printf("MPOP\n");
                continue;
            }
            case MPICK:{
                printf("MPICK      ");
                int i = _Integer_value(Array_get(program,pc++));
                int j = _Integer_value(Array_get(program,pc++));
                printf("%3d %3d\n",i,j);
                continue;
            }
            case MSET:{
                printf("MSET      ");
                printf("%3d\n",_Integer_value(Array_get(program,pc++)));
                continue;
            }
            case JUMPF:{
                printf("jumpF     ");//T
                int offset = _Integer_value(Array_get(program,pc++)); 
                printf("%3d\n",offset);//T
                continue;
            }
            case JUMP:{
                printf("jump      ");
                int offset = _Integer_value(Array_get(program,pc++)); 
                printf("%3d\n",offset);
                continue;       
            }
            case i_PRINT:{
                printf("i PRINT\n");
                continue;
            }
            case l_PRINT:{
                printf("l PRINT\n");
                continue;
            }
            case f_PRINT:{
                printf("f PRINT\n");
                continue;
            }
            case d_PRINT:{
                printf("d PRINT\n");
                continue;
            }
            case c_PRINT:{
                printf("c PRINT\n");
                continue;
            }
            case s_PRINT:{
                printf("s PRINT\n");
                continue;
            }
            case HALT:{
                printf("HALT\n");
                return nil;
            }
        }
    }
}



/*
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                        vritual machine code
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
*/


// oop sub_execute(oop,oop,oop);
//Flagp main_execute(oop,oop);







// QUEUE
#define SUCCESS     1       /* 成功 */
#define FAILURE     0       /* 失敗 */
#define QUEUE_SIZE 5          /* 待ち行列に入るデータの最大数 */







// END QUEUE






oop _newThread(size_t size)
{
    oop node = newObject(Thread);
    node->Thread.flag       =  0;
    node->Thread.queue_head =  0;
    node->Thread.queue_num  =  0;
    node->Thread.pc         =  0;
    node->Thread.base       =  0;
    node->Thread.rbp        =  1;//1st rbp, 2nd.. event args,
    node->Thread.stack      = newArray(0);
    VD       vd = calloc(1,size);
    node->Thread.vd         = vd;
    return node;
}
#define newThread(TYPE)	_newThread(sizeof(struct TYPE))

oop _setThread(oop t,size_t size)
{
    t->Thread.flag       =  0;
    t->Thread.queue_head =  0;
    t->Thread.queue_num  =  0;
    t->Thread.pc         =  0;
    t->Thread.base       =  0;
    t->Thread.rbp        =  0;
    t->Thread.stack      = newArray(0);
    VD       vd = calloc(1,size);
    t->Thread.vd         = vd;
    return t;
}
#define setThread(T,TYPE)	_setThread(T,sizeof(struct TYPE))



void printThread(oop t){
    int i = getType(t->Thread.stack);
    printf("stack == %s\n",TYPENAME[i]);
    printf("pc     %d\n",t->Thread.pc);
    printf("rbp    %d\n",t->Thread.rbp);
    printf("q head %d\n",t->Thread.queue_head);
    printf("q num  %d\n",t->Thread.queue_num);
    printf("flag   %d\n",t->Thread.flag);
}



int enqueue(oop t,oop data)
{
    if (t->Thread.queue_num < QUEUE_SIZE) {
        t->Thread.queue[(t->Thread.queue_head + t->Thread.queue_num) % QUEUE_SIZE] = data;
        t->Thread.queue_num++;
        return SUCCESS;
    } else {
        return FAILURE;
    }
}

oop dequeue(oop t)
{
    if (t->Thread.queue_num > 0) {
        oop data = t->Thread.queue[t->Thread.queue_head];
        t->Thread.queue_head = (t->Thread.queue_head + 1) % QUEUE_SIZE;
        t->Thread.queue_num--;
        return data;
    } else {
        return 0;
    }
}

enum event_list{
    Loop,
    Timer,
};



// EVENT FUNCTION
oop eve_loop(oop t){
    if(t->Thread.flag == 0){
        oop data = newArray(2);
        Array_push(data,new_Basepoint(1));//1st rbp, 2nd.. event args, 
        Array_push(data,_newInteger(1));
        enqueue(t,data);
    }
    return t;
}

oop eve_timer(oop t){
    // printf("        timer\n");

    time_t current_time = time(NULL);
    if(current_time - t->Thread.vd->VarTI.v_t1 >= t->Thread.vd->VarTI.v_i2){
        t->Thread.vd->VarTI.v_t1 = current_time;
        t->Thread.vd->VarTI.v_i1  += t->Thread.vd->VarTI.v_i2;
        oop data = newArray(2);
        Array_push(data,new_Basepoint(1));//1st rbp, 2nd.. event args, 
        Array_push(data,_newInteger(t->Thread.vd->VarTI.v_i1));
        enqueue(t,data);
    }
    return t;
}

oop eve_keyget(oop t){
    char buf;
    struct termios old_flags, new_flags;
    fd_set fds;
    struct timeval tv;
    int ret;

    // 標準入力をノンブロッキングモードに設定
    int flags = fcntl(STDIN_FILENO, F_GETFL, 0);
    fcntl(STDIN_FILENO, F_SETFL, flags | O_NONBLOCK);

    // 現在の端末属性を取得
    tcgetattr(STDIN_FILENO, &old_flags);
    new_flags = old_flags;
    // ICANON(カノニカルモード)とECHO(エコー)を無効にする
    new_flags.c_lflag &= ~(ICANON | ECHO);
    tcsetattr(STDIN_FILENO, TCSANOW, &new_flags);

    // 標準入力からの読み取りを待たない
    FD_ZERO(&fds);
    FD_SET(STDIN_FILENO, &fds);

    // タイムアウトを設定（0秒）
    tv.tv_sec = 0;
    tv.tv_usec = 0;
    
    // 標準入力からの読み取りをチェック
    ret = select(STDIN_FILENO + 1, &fds, NULL, NULL, &tv);
    if (ret < 0) {
        perror("select");
        exit(EXIT_FAILURE);
    } else if (ret == 0) {
        // 標準入力からの読み取りが利用可能でない場合
        return 0;
    } else {
        // 標準入力からの読み取りが利用可能な場合、1バイト読み取る
        if (read(STDIN_FILENO, &buf, 1) < 0) {
            if (errno == EAGAIN || errno == EWOULDBLOCK) {
                // 読み取りが非同期にブロックされている場合
                return 0;
            } else {
                perror("read");
                exit(EXIT_FAILURE);
            }
        }
        // 読み取った文字を返す
        oop data = newArray(2);
        Array_push(data,new_Basepoint(1));//1st rbp, 2nd.. event args, 
        Array_push(data,_newInteger(buf));
        enqueue(t,data);
        return t;
    }
}

//STDLIB EVENT
oop Event_stdlib(int eve_num,oop stack){
    switch(eve_num){
        case LOOP_E:{
            oop t = newThread(Default);
            t->Thread.vd->Default.count = 0;
            t->Thread.func = &eve_loop;
            return t;
        }
        case TIMERSEC_E:{
            oop t = newThread(VarTI);
            t->Thread.vd->VarTI.v_t1 = time(NULL);
            t->Thread.vd->VarTI.v_i1  = 0;
            t->Thread.vd->VarTI.v_i2  = _Integer_value(Array_pop(stack));
            t->Thread.func = &eve_timer;
            return t;
        }
        case KEYGET_E:{
            oop t = newThread(Default);
            t->Thread.func = &eve_keyget;
            while(0!=t->Thread.func(t))dequeue(t);
            return t;
        }
        default:{
            fprintf(stderr,"this is not happen Event_stdlib eve[%d]\n",eve_num);
            exit(1);
        }
    }
    printf("Event_stdlib(): not happen..\n");
    return 0;
}


oop Event_userlib(int eve_num,oop stack){
    switch(eve_num){
        default:
            fprintf(stderr,"this is not happen Event_userlib\n");
    }
    exit(1);
}

// EVENT...
oop Event_Func(int lib_num,int eve_num,oop stack){
    switch(lib_num){
        case STDLIB:{
            return Event_stdlib(eve_num,stack);
        }
        case USERLIB:{
            return 0;
        }
        default:{
            printf("ERROR: Event lib[%d] eve[%d]\n",lib_num, eve_num);
            exit(1);
        }
    }
    printf("Event_Func(): not happen..\n");
    return 0;
}



char inst      = 0;
char char_value    = 0;
int  int_value      = 0;
long long int long_value = 0;
float float_value   = 0;
double double_value = 0;
char   string_value[256];

#define getData(D,PC,S) memcpy(&D,&memory[PC],S); PC+=S
#define getInst(PC)     memcpy(&inst,&memory[PC],SIZE_INST); PC+=SIZE_INST
#define getChar(PC)     memory[PC++]
#define getInt(PC)      memcpy(&int_value,&memory[PC],SIZE_INT);PC+=SIZE_INT 
#define getLong(PC)     memcpy(&long_value,&memory[PC],SIZE_LONG);PC+=SIZE_LONG
#define getFloat(PC)    memcpy(&float_value,&memory[PC],SIZE_FLOAT);PC+=SIZE_FLOAT
#define getDouble(PC)   memcpy(&double_value,&memory[PC],SIZE_DOUBLE);PC+=SIZE_DOUBLE



#define getString(PC)   ({ \
    int i = 0; \
    while(memory[PC]!='\0'){ \
        string_value[i++] = memory[PC++]; \
    } \
    string_value[i] = memory[PC++]; \
})

//-----------_----------__------______----________--__________


#include <unistd.h>//remove


void main_execute(){
    int test_impliment_limit = 0; //REMOVEME: TEST only 
    int pc = 0;
    int rbp = 0;
    oop stack = newArray(10); //動的にメモリを確保するようにしないとメモリが被ってしまうため、スタックのデータがかぶる。
    // GROBAL MEMORY
    oop GM    = newThread(Default);
    GM->Thread.stack = newArray(10);
    GM->Thread.rbp   = 0;
    
    for(;;){
        getInst(pc);
        switch(inst){
            case i_load:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
line();
#endif
                getInt(pc);
                Array_push(stack,_newInteger(int_value));
                continue;
            }

            case THREAD:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                getInt(pc);
                int num_thread = int_value;
                if(num_thread == 0)continue;
                int thread_pc = pc;
                oop t = newArray(num_thread);
                

            //init setting thread スレッドの初期設定
                printf("\n              setting\n\n");
                for(int thread_index=0; thread_index<num_thread;/*case CALL_E, thread_index++*/){
                    getInst(pc);
                    switch(inst){
                        case i_load:{// load pin number / load location of event task
#if TEST  
line();printf("THREAD => %s\n",INSTNAME[inst]);
#endif
                            getInt(pc);
                            Array_push(stack,_newInteger(int_value));
                            continue;
                        }
                        case CALL_E:{//now
#if TEST  
line();printf("THREAD => %s\n",INSTNAME[inst]);
#endif
                            getInt(pc);int lib_num = int_value;
                            getInt(pc);int eve_num = int_value;
                            getInt(pc);int pin_num = int_value;

                            Array_push(t,Event_Func(lib_num,eve_num,stack));                 // connect function of event / イベントの関数と紐付け
                            
                            int inst_loc = thread_pc + _Integer_value(Array_pop(stack));
                            t->Array.elements[thread_index]->Thread.pc   = inst_loc;
                            t->Array.elements[thread_index]->Thread.base = inst_loc;
                            
                            thread_index++;
                            continue;
                        }
                        default:{
                            printf("this is not happen, main main_execute case THREAD\n");
                            exit(1);
                        }
                    }
                }
                printf("\n              implement\n\n");
    // implement thread/Event concurrelty
                for(int is_active = 0,count = 5; is_active==0;){
                    count++;
                    for(int i =0;i<num_thread;i++){
                        t->Array.elements[i]->Thread.func(t->Array.elements[i]);             //implement function of event

                        if(t->Array.elements[i]->Thread.flag == 1){
                            FLAG flag = sub_execute(t->Array.elements[i],GM);
                            if(flag == F_TRANS){//TRANS
                                printf("        TRANS\n");
                                int pc_i = t->Array.elements[i]->Thread.pc++;//location of thread[i]'s pc
                                getInt(pc_i);//thread num<-pc_i
                                pc = int_value + pc_i;
                                // printf("pc-> %d\n",pc);
                                is_active = 1;
                                int gm_size = GM->Thread.stack->Array.size;
                                for(int i = gm_size;i>GM->Thread.rbp;i--){
                                    Array_pop(GM->Thread.stack);
                                }
                                break;
                            }
                            else if(flag == F_EOE){//EOE
                                t->Array.elements[i]->Thread.flag = 0;
                                t->Array.elements[i]->Thread.pc = t->Array.elements[i]->Thread.base;
                                if(test_impliment_limit>1000000){
                                    printf("\n\n");
                                    return;
                                }else test_impliment_limit++;
                            }
                        }
                        else if(t->Array.elements[i]->Thread.queue_num>0){
                                t->Array.elements[i]->Thread.flag = 1;
                                t->Array.elements[i]->Thread.stack = dequeue(t->Array.elements[i]);
                                // Array_push(t->Array.elements[i]->Thread.stack,new_Basepoint(1));//1st rbp, 2nd.. event args, 
                                // Array_push(t->Array.elements[i]->Thread.stack,dequeue(t->Array.elements[i]));//TODO: put args of event into t[i]->stack: timer(int sec)=> sec is arg
                        }
                    }
                    // if(count>5){
                    //     count = 0;
                    // }
                }
                free(t);
                continue;
            }
            case DEFINE_L:{
                getInt(pc);
                oop data  = Array_pop(stack);
                Array_put(GM->Thread.stack,GM->Thread.rbp + int_value, data);
                continue;
            }
            case GLOBAL:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                oop code = newThread(Default);
                code->Thread.pc = pc;
                for(;;){
                    FLAG flag = sub_execute(code,GM);
                    if(flag == F_EOE)break;
                }
                pc = code->Thread.pc;
                free(code);//IFERROR
                continue;
            }
            case ENTRY:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                getInt(pc);
                int s_pc = pc;//store corrent pc
                oop code = newThread(Default);
                code->Thread.pc = pc + int_value;
                Array_push(code->Thread.stack,new_Basepoint(0));
                for(;;){
                    FLAG flag = sub_execute(code,GM);
                    if(flag == F_EOE)break;
                }
                free(code);
                pc = s_pc;
                continue;                
            }
            case MSET:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                getInt(pc);GM->Thread.rbp = int_value;
                for(int i =0;i<int_value ;i++){
                    Array_push(GM->Thread.stack,nil);
                }
                continue;
            }
            case JUMP:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                getInt(pc); pc += int_value;
                continue;       
            }
            case HALT:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                return;
            }
            default:fprintf(stderr,"main_execute error %s\n",INSTNAME[inst]);
        }
    }
}

#define mpc    process->Thread.pc
#define mrbp   process->Thread.rbp
#define mstack process->Thread.stack



#define api()     _Integer_value(Array_pop(mstack))
#define apl()     Array_pop(mstack)->_Long.value
#define apf()     _Float_value(Array_pop(mstack))
#define apd()     Array_pop(mstack)->_Double.value
#define aps()     Array_pop(mstack)->String.value
#define apc()    _Char_value(Array_pop(mstack))


// ライブラリ関数
void stdlib_print(oop process,oop GM){
    getInt(mpc);int size_args = int_value;
    int value = api();
    printf("%d\n",value);
    return;
}

void stdlib_itoc(oop process,oop GM){
    getInt(mpc);int size_args = int_value;
    char value = (char)api();
    oop c = _newChar(value);
    Array_push(mstack,c);
    return; 
}

void stdlib_exit(oop process,oop GM){
    getInt(mpc);int size_args = int_value;
    int value = api();
    exit(value);
    return;
}

void stdlib_appendchar(oop process,oop GM){
    getInt(mpc);int size_args = int_value;
    char* str = aps();
    char c = apc();
    size_t length = strlen(str);
    char* newStr = (char*)malloc((length + 2) * sizeof(char)); // 新しい文字列のメモリを確保
    if (newStr != NULL){
        strcpy(newStr, str); // 元の文字列をコピー
        newStr[length] = c;  // 追加する文字をセット
        newStr[length + 1] = '\0'; // ヌル終端を追加
    }
    Array_push(mstack,newString(newStr));
    return;
}

void lib_stdlib(oop process,oop GM){
    getInt(mpc);int func_num = int_value;
    switch(func_num){
        case OUTPUT_P:{
            stdlib_print(process,GM);
            break;
        }
        case ITOC_P:{
            stdlib_itoc(process,GM);
            break;
        }
        case EXIT_P:{
            stdlib_exit(process,GM);
            break;
        }
        case APPENDCHAR_P:{
            stdlib_appendchar(process,GM);
            break;
        }
        default:
            break;
    }
}

oop Call_Primitive(oop process,oop GM){
    getInt(mpc);int lib_num = int_value;
    switch(lib_num){
        case STDLIB:{
            lib_stdlib(process,GM);
            break;
        }
        default:{
            printf("Call_Primitive %d\n",lib_num);
            exit(1);
        }
    }
    return nil;
}
////////////////////////////////////////////////




FLAG sub_execute(oop process,oop GM){
    for(;;){
        getInst(mpc);
        switch(inst){
            case TRANS:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                return F_TRANS;
            }
            case i_load:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                getInt(mpc);
                Array_push(mstack,_newInteger(int_value));
                continue;
            }
            case l_load:
            {
                getLong(mpc);
                Array_push(mstack,_newLong(long_value));
                continue;
            }
            case f_load:{
                getFloat(mpc);
                Array_push(mstack,_newFloat(float_value));
                continue;
            }
            case d_load:{
                getDouble(mpc);
                Array_push(mstack,_newDouble(double_value));
                continue;
            }
            case c_load:{
                char vlaue = getChar(mpc);
                Array_push(mstack,_newDouble(double_value));
                continue;    
            }
            case s_load:{
                getString(mpc);
                Array_push(mstack,newString(string_value));
                continue;
            }
            case il_load:{
                getInt(mpc);
                oop list = _newIntegerArray(_Integer_value(Array_pop(mstack)));
                for(int i=0;i<int_value;i++){
                    list->_IntegerArray.array[i] = Array_pop(mstack);
                }
                Array_put(mstack,int_value,list);
                continue;
            }
/* _Integer */
            case i_EQ:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                int r = api(),l = api();
                Array_push(mstack,newBoolean(l == r));
                continue;
            }
            case i_NE:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                int r = api(),l = api();
                Array_push(mstack,newBoolean(l != r));
                continue;
            }
            case i_LT:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                int r = api(),l = api();
                Array_push(mstack,newBoolean(l <  r));
                continue;
            }
            case i_LE:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                int r = api(),l = api();
                Array_push(mstack,newBoolean(l <= r));
                continue;
            }
            case i_GE:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                int r = api(),l = api();
                Array_push(mstack,newBoolean(l >= r));
                continue;
            }
            case i_GT:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                int r = api(),l = api();
                Array_push(mstack,newBoolean(l >  r));
                continue;
            }
            case i_AND:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                int r = api(),l = api();
                Array_push(mstack,newBoolean(l && r));
                continue;
            }
            case i_OR:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                int r = api(),l = api();
                Array_push(mstack,newBoolean(l || r));
                continue;
            }
            case i_ADD:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                int r = api(),l = api();
                Array_push(mstack,_newInteger(l + r));
                continue;
            }
            case i_SUB:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                int r = api(),l = api();
                Array_push(mstack,_newInteger(l - r));
                continue;
            }
            case i_MUL:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                int r = api(),l = api();
                Array_push(mstack,_newInteger(l * r));
                continue;
            }
            case i_DIV:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                int r = api(),l = api();
                Array_push(mstack,_newInteger(l / r));
                continue;
            }
            case i_MOD:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                int r = api(),l = api();
                Array_push(mstack,_newInteger(l % r));
                continue;
            }
/* Long */
            case l_EQ:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                long long int r = apl(),l = apl();
                if(l==r)Array_push(mstack,sys_true);
                else    Array_push(mstack,sys_false);
                continue;
            }
            case l_NE:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                long long int r = apl(),l = apl();
                if(l!=r)Array_push(mstack,sys_true);
                else    Array_push(mstack,sys_false);
                continue;
            }
            case l_LT: {
                long long int r = apl(),l = apl();
                if(l< r)Array_push(mstack,sys_true);
                else    Array_push(mstack,sys_false);
                continue;
            }
            case l_LE: {
                long long int r = apl(),l = apl();
                if(l<=r)Array_push(mstack,sys_true);
                else    Array_push(mstack,sys_false);
                continue;
            }
            case l_GE:{
                long long int r = apl(),l = apl();
                if(l>=r)Array_push(mstack,sys_true);
                else    Array_push(mstack,sys_false);
                continue;
            } 
            case l_GT:{
                long long int r = apl(),l = apl();
                if(l< r)Array_push(mstack,sys_true);
                else    Array_push(mstack,sys_false);
                continue;
            } 
            case l_ADD:{
                long long int r = apl(),l = apl();
                Array_push(mstack,_newLong(l+r));
                continue;
            } 
            case l_SUB:{
                long long int r = apl(),l = apl();
                Array_push(mstack,_newLong(l-r));
                continue;
            } 
            case l_MUL:{
                long long int r = apl(),l = apl();
                Array_push(mstack,_newLong(l*r));
                continue;
            } 
            case l_DIV:{
                long long int r = apl(),l = apl();
                Array_push(mstack,_newLong(l/r));
                continue;
            } 
            case l_MOD:{
                long long int r = apl(),l = apl();
                Array_push(mstack,_newLong(l%r));
                continue;
            } 
/* _Float */
            case f_EQ:{
                float r = apf(),l = apf();
                if(l==r)Array_push(mstack,sys_true);
                else    Array_push(mstack,sys_false);
                continue;
            }
            case f_NE:{
                float r = apf(),l = apf();
                if(l!=r)Array_push(mstack,sys_true);
                else    Array_push(mstack,sys_false);
                continue;
            }
            case f_LT:{
                float r = apf(),l = apf();
                if(l< r)Array_push(mstack,sys_true);
                else    Array_push(mstack,sys_false);
                continue;
            } 
            case f_LE: {
                float r = apf(),l = apf();
                if(l<=r)Array_push(mstack,sys_true);
                else    Array_push(mstack,sys_false);
                continue;
            }
            case f_GE: {
                float r = apf(),l = apf();
                if(l>=r)Array_push(mstack,sys_true);
                else    Array_push(mstack,sys_false);
                continue;
            }
            case f_GT: {
                float r = apf(),l = apf();
                if(l< r)Array_push(mstack,sys_true);
                else    Array_push(mstack,sys_false);
                continue;
            }
            case f_ADD:{
                float r = apf(),l = apf();
                Array_push(mstack,_newFloat(l+r));
                continue;
            } 
            case f_SUB:{
                float r = apf(),l = apf();
                Array_push(mstack,_newFloat(l-r));
                continue;
            } 
            case f_MUL:{
                float r = apf(),l = apf();
                Array_push(mstack,_newFloat(l*r));
                continue;
            } 
            case f_DIV:{
                float r = apf(),l = apf();
                Array_push(mstack,_newFloat(l/r));
                continue;
            } 
/* Double */
            case d_EQ:{
                double r = apd(),l = apd();
                if(l==r)Array_push(mstack,sys_true);
                else    Array_push(mstack,sys_false);
                continue;
            }
            case d_NE:{
                double r = apd(),l = apd();
                if(l!=r)Array_push(mstack,sys_true);
                else    Array_push(mstack,sys_false);
                continue;
            }
            case d_LT:{
                double r = apd(),l = apd();
                if(l< r)Array_push(mstack,sys_true);
                else    Array_push(mstack,sys_false);
                continue;
            } 
            case d_LE:{
                double r = apd(),l = apd();
                if(l<=r)Array_push(mstack,sys_true);
                else    Array_push(mstack,sys_false);
                continue;
            } 
            case d_GE:{
                double r = apd(),l = apd();
                if(l>=r)Array_push(mstack,sys_true);
                else    Array_push(mstack,sys_false);
                continue;
            }
            case d_GT:{
                double r = apd(),l = apd();
                if(l> r)Array_push(mstack,sys_true);
                else    Array_push(mstack,sys_false);
                continue;
            } 
            case d_ADD:{
                double r = apd(),l = apd();
                Array_push(mstack,_newDouble(l+r));
                continue;
            } 
            case d_SUB:{
                double r = apd(),l = apd();
                Array_push(mstack,_newDouble(l-r));
                continue;
            } 
            case d_MUL:{
                double r = apd(),l = apd();
                Array_push(mstack,_newDouble(l*r));
                continue;
            } 
            case d_DIV:{
                double r = apd(),l = apd();
                Array_push(mstack,_newDouble(l/r));
                continue;
            } 


            case s_EQ: {
                char* r = aps(),*l = aps();
                if(strcmp(l,r)==0)Array_push(mstack,sys_true);
                else Array_push(mstack,sys_false);
                continue;
            } 
            case s_NE: {
                char* r = aps(),*l = aps();
                if(strcmp(l,r)!=0)Array_push(mstack,sys_true);
                else Array_push(mstack,sys_false);
                continue;
            } 
            case s_LT: {
                char* r = aps(),*l = aps();
                if(strcmp(l,r)<0)Array_push(mstack,sys_true);
                else Array_push(mstack,sys_false);
                continue;
            } 
            case s_LE:{
                char* r = aps(),*l = aps();
                if(strcmp(l,r)<=0)Array_push(mstack,sys_true);
                else Array_push(mstack,sys_false);
                continue;
            } 
            case s_GE: {
                char* r = aps(),*l = aps();
                if(strcmp(l,r)>=0)Array_push(mstack,sys_true);
                else Array_push(mstack,sys_false);
                continue;
            } 
            case s_GT: {
                char* r = aps(),*l = aps();
                if(strcmp(l,r)>0)Array_push(mstack,sys_true);
                else Array_push(mstack,sys_false);
                continue;
            }
            case s_ADD:{
                oop r = Array_pop(mstack);
                oop l = Array_pop(mstack);
                oop new = newString(strcat(strdup(l->String.value),r->String.value));
                Array_push(mstack,new);
                continue;
            }





/* end calc */
            case CALL:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                getInt(mpc);
                Array_push(mstack,_newInteger(int_value));//number of args
                getInt(mpc);
                Array_push(mstack,_newInteger(mpc));//CHECKME: funtion index?
                mpc = mpc + int_value;
                return F_NONE;
            }
            case CALL_P:{
#if TEST
printf("CALL_P\n");
#endif
                Call_Primitive(process,GM);
                return F_NONE;
            }
            case GET:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                getInt(mpc);
                Array_push(mstack,Array_get(mstack,mrbp + int_value));//index
                continue;
            }
            case GET_L:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                getInt(mpc);
                // printf("    %s\n",TYPENAME[getType(mstack)]);
                Array_push(mstack,Array_get(GM->Thread.stack,GM->Thread.rbp + int_value));//index
                continue;
            }
            case GET_G:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                getInt(mpc);
                Array_push(mstack,Array_get(GM->Thread.stack,int_value));//index
                continue;
            }
            case DEFINE:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                getInt(mpc);
                oop data  = Array_pop(mstack);
                Array_put(mstack,mrbp + int_value, data);
                continue;
            }
            case DEFINE_L:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                getInt(mpc);
                oop data  = Array_pop(mstack);
                Array_put(GM->Thread.stack,GM->Thread.rbp + int_value, data);
                continue;
            }
            case DEFINE_G:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                getInt(mpc);
                oop data = Array_pop(mstack);
                Array_put(GM->Thread.stack,int_value,data);
                continue;
            }
            case DEFINE_List:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                getInt(mpc);
                int index = _Integer_value(Array_pop(mstack));
                oop data  = Array_pop(mstack);
                //FIXME: サイズの確認とかやってない
                GM->Thread.stack->Array.elements[int_value]->_IntegerArray.array[index] = data;
                continue;
            }
            case GLOBAL_END:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                return F_EOE;
            }
            case SETQ:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                continue;
            }
            case RET:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                oop value = Array_pop(mstack);//return value
                oop data = nil;
                while(getType(data = Array_pop(mstack)) != _BasePoint);
                mrbp = get(data,_BasePoint,adress);
                mpc = api();//next mpc 
                int num_arg = api();
                for(int i = 0;i<num_arg;i++)
                    Array_pop(mstack);
                Array_push(mstack,value);
                return F_NONE;
            }
            case JUMPF:{
#if TEST  
line();printf("%s [%d]\n",INSTNAME[inst],inst);
#endif
                getInt(mpc);//get offset
                oop cond = Array_pop(mstack);
                //FIXME: usign sys_false and sys_true
                if(cond == sys_false)mpc += int_value;//offset
                else if(cond == sys_true)return F_NONE;
                else if(_Integer_value(cond)==0)mpc += int_value;//offset
                return F_NONE;
            }
            case JUMP:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                getInt(mpc);     //get offset
                mpc += int_value;//get offset
                return F_NONE;//go next thread
            }
            case MSUB:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                //now
                mstack = Array_push(mstack, new_Basepoint(mrbp));//before mrpb
                mrbp = mstack->Array.size;            //current mrpb
                getInt(mpc);//memry
                int memory_size = int_value;
                for(int i=0;i<memory_size;i++){
                    Array_push(mstack,nil);//put nil into mstack for variable
                }
                continue;
            }
            case MPOP:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                for(;;){
                    oop data = Array_pop(mstack);
                    if(getType(data) == _BasePoint){
                        mrbp = data->_BasePoint.adress;
                        break;
                    }
                }
                continue;
            }
            case MPICK:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                getInt(mpc);
                int adress = int_value;
                getInt(mpc);
                int index  = int_value;
                oop data   = Array_get(mstack, mrbp - adress -1);
                Array_put(mstack,mrbp + index,data);
                continue;
            }
            case i_PRINT:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                printf("%d\n",_Integer_value(Array_pop(mstack)));
                continue;
            }
            case l_PRINT:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                printf("%lld\n",Array_pop(mstack)->_Long.value);
                continue;
            }
            case f_PRINT:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                printf("%f\n",_Float_value(Array_pop(mstack)));
                continue;
            }
            case d_PRINT:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                printf("%f\n",Array_pop(mstack)->_Double.value);
                continue;
            }
            case c_PRINT:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                printf("%c\n",_Char_value(Array_pop(mstack)));
                continue;
            }
            case s_PRINT:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                printf("%s\n",Array_pop(mstack)->String.value);
                continue;
            }
            case EOE:{
                // mpc  = mrbp;
                mpc -= 1;
                // exit(1);
                if(mstack->Array.size != 0){
                    fatal("IMPRIMENT ERROR: stack size is %d\n",mstack->Array.size);
                }
                return F_EOE;
            }
            case HALT:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                if(Array_size(mstack)==1){
                    printf("HALT-----------------------\n");
                    printlnObject(Array_pop(mstack),1);
                    return F_NONE;
                }
                printf("HALT with %d items on mstack\n",Array_size(mstack));
                int size = Array_size(mstack);
                for(int i = 0; i<size;i++)
                    printlnObject(Array_pop(mstack),1);
                return F_NONE;
            }
        }
        return F_NONE;
    } 
}




oop printByteCode(){
    int pc = 0;
    for(;;){
        printf("%3d ",pc);
        getInst(pc);
        switch(inst){
            case TRANS:  getInt(pc);printf("TRANS     %3d\n",int_value);continue;
            case i_load: getInt(pc);printf("i_load    %3d\n",int_value);continue;
            case l_load: getLong(pc);printf("l_load    %3lld\n",long_value);continue;
            case f_load: getFloat(pc);printf("f_load    %3f\n",float_value);continue;
            case d_load: getDouble(pc);printf("d_load    %3f\n",double_value);continue;
            case c_load: printf("c_load    %3c\n",getChar(pc));continue;
            case s_load: getString(pc);printf("s_load    %s\n",string_value);continue;
            case il_load: getInt(pc);printf("il_load    %d\n",int_value);continue;
            case i_EQ:   printf("i_EQ\n"); continue; 
            case i_NE:   printf("i_NE\n"); continue; 
            case i_LT:   printf("i_LT\n"); continue; 
            case i_LE:   printf("i_LE\n"); continue; 
            case i_GE:   printf("i_GE\n"); continue; 
            case i_GT:   printf("i_GT\n"); continue; 
            case i_ADD:  printf("i_ADD\n");continue;
            case i_SUB:  printf("i_SUB\n");continue;
            case i_MUL:  printf("i_MUL\n");continue;
            case i_DIV:  printf("i_DIV\n");continue;
            case i_MOD:  printf("i_MOD\n");continue;
            case l_EQ:   printf("l_EQ\n");continue; 
            case l_NE:   printf("l_NE\n");continue; 
            case l_LT:   printf("l_LT\n");continue; 
            case l_LE:   printf("l_LE\n");continue; 
            case l_GE:   printf("l_GE\n");continue; 
            case l_GT:   printf("l_GT\n");continue; 
            case l_ADD:  printf("l_ADD\n");continue;
            case l_SUB:  printf("l_SUB\n");continue;
            case l_MUL:  printf("l_MUL\n");continue;
            case l_DIV:  printf("l_DIV\n");continue;
            case l_MOD:  printf("l_MOD\n");continue;
            case f_EQ:   printf("f_EQ\n");continue; 
            case f_NE:   printf("f_NE\n");continue; 
            case f_LT:   printf("f_LT\n");continue; 
            case f_LE:   printf("f_LE\n");continue; 
            case f_GE:   printf("f_GE\n");continue; 
            case f_GT:   printf("f_GT\n");continue; 
            case f_ADD:  printf("f_ADD\n");continue;
            case f_SUB:  printf("f_SUB\n");continue;
            case f_MUL:  printf("f_MUL\n");continue;
            case f_DIV:  printf("f_DIV\n");continue;
            case d_EQ:   printf("d_EQ\n");continue; 
            case d_NE:   printf("d_NE\n");continue; 
            case d_LT:   printf("d_LT\n");continue; 
            case d_LE:   printf("d_LE\n");continue; 
            case d_GE:   printf("d_GE\n");continue; 
            case d_GT:   printf("d_GT\n");continue; 
            case d_ADD:  printf("d_ADD\n");continue;
            case d_SUB:  printf("d_SUB\n");continue;
            case d_MUL:  printf("d_MUL\n");continue;
            case d_DIV:  printf("d_DIV\n");continue;

            case s_EQ:   printf("d_EQ\n");continue; 
            case s_NE:   printf("d_NE\n");continue; 
            case s_LT:   printf("d_LT\n");continue; 
            case s_LE:   printf("d_LE\n");continue; 
            case s_GE:   printf("d_GE\n");continue; 
            case s_GT:   printf("d_GT\n");continue; 
            case s_ADD:  printf("d_ADD\n");continue;

            case THREAD: getInt(pc);printf("thread    %3d\n",int_value);continue;
            case EOE:    printf("EOE\n");continue;

            case CALL:{
                printf("CALL      ");
                getInt(pc);int num_arg = int_value;
                getInt(pc);int index = int_value;
                printf("%3d  %3d\n",num_arg,index);
                continue;
            }
            case CALL_P:{
                printf("CALL_P      ");
                getInt(pc);int lib_num = int_value;
                getInt(pc);int func_num = int_value;
                getInt(pc);int args_s = int_value;
                printf("%3d  %3d  %3d\n",lib_num,func_num,args_s);
                continue;
            }
            case CALL_E:{
                printf("CALL_E      ");
                getInt(pc);int lib_num = int_value;
                getInt(pc);int func_num = int_value;
                getInt(pc);int args_s = int_value;
                printf("%3d  %3d  %3d\n",lib_num,func_num,args_s);
                continue;
            }
            case GET:{
                printf("Get       ");//T
                getInt(pc);int symbol = int_value;
                printf("%3d\n",symbol);
                continue;
            }
            case GET_L:{
                printf("Get_L     ");//T
                getInt(pc);int symbol = int_value;
                printf("%3d\n",symbol);
                continue;
            }
            case GET_G:{
                printf("GET_G     ");
                getInt(pc);int symbol = int_value;
                printf("%3d\n",symbol);
                continue;
            }
            case DEFINE:{
                printf("DEFINE    ");//T
                getInt(pc);int symbol = int_value;
                printf("%3d\n",symbol);//T
                continue;
            }
            case DEFINE_L:{
                printf("DEFINE_L  ");//T
                getInt(pc);int symbol = int_value;
                printf("%3d\n",symbol);//T
                continue;
            }
            case DEFINE_G:{
                printf("DEFINE_List  ");//T
                getInt(pc);int symbol = int_value;
                printf("%3d\n",symbol);//T
                continue;
            }  
            case GLOBAL:{
                printf("GLOBAL\n");
                continue;
            }
            case GLOBAL_END:{
                printf("GLOBAL_END\n");
                continue;
            }
            case ENTRY:{
                printf("ENTRY     ");
                getInt(pc);int index = int_value;
                printf("%3d\n",index);//T
                continue;
            }
            case SETQ:{
                printf("SETQ\n");
                continue;
            }
            case RET:{
                printf("RET       ");
                printf("  X\n");
                continue;
            }
            case MSUB:{
                printf("MSUB      ");
                getInt(pc);printf("%3d\n",int_value);
                continue;
            }
            case MPOP:{
                printf("MPOP\n");
                continue;
            }
            case MPICK:{
                printf("MPICK     ");
                getInt(pc);int i = int_value;
                getInt(pc);int j = int_value;
                printf("%3d %3d\n",i,j);
                continue;
            }
            case MSET:{
                printf("MSET      ");
                getInt(pc);
                printf("%3d\n",int_value);
                continue;
            }
            case JUMPF:{
                printf("jumpF     ");//T
                getInt(pc);
                int offset = int_value; 
                printf("%3d\n",offset);//T
                continue;
            }
            case JUMP:{
                printf("jump      ");
                getInt(pc);
                int offset = int_value; 
                printf("%3d\n",offset);
                continue;       
            }
            case i_PRINT:{
                printf("i PRINT\n");
                continue;
            }
            case l_PRINT:{
                printf("l PRINT\n");
                continue;
            }
            case f_PRINT:{
                printf("f PRINT\n");
                continue;
            }
            case d_PRINT:{
                printf("d PRINT\n");
                continue;
            }
            case c_PRINT:{
                printf("c PRINT\n");
                continue;
            }
            case s_PRINT:{
                printf("s PRINT\n");
                continue;
            }
            case HALT:{
                printf("HALT\n");
                return nil;
            }
        }
    }
}
