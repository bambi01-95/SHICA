%{;
/*
TODO:  Do it later
FIXME: Known bugs
HACK:  It's not pretty, it's not smart.
XXX:     Proble
*/
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>
#include <stdarg.h>
#include <time.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/select.h>
#include <termios.h>

FILE* SOURCE_FILE;
#define getchar() fgetc(SOURCE_FILE)

#define TEST 1


#define user_error(COND,MSG,LINE) ({ \
    if(COND){ \
        if(TEST==1)printf("[VM LINE %d]",__LINE__); \
        fprintf(stderr,"line %d: %s\n",LINE,MSG); \
        exit(1); \
    } \
})

void fatal(char *msg, ...)
{
    va_list ap;
    va_start(ap, msg);
    fprintf(stderr, "\n");
    vfprintf(stderr, msg, ap);
    fprintf(stderr, "\n");
    va_end(ap);
    exit(1);
}

#define out(A) printf("line %4d: %s\n",__LINE__,A)
#define line() printf("         line %4d: ",__LINE__)
union Object;
typedef union Object Object;
typedef Object *oop;


typedef oop (*Func)(oop);

typedef union VarData VarData;
typedef VarData *VD;

oop nil   = 0;
oop sys_false = 0;
oop sys_true  = 0;
oop none  = 0;
oop entry_sym = 0;

enum Type {
    Undefined,
    Operator,
    Integer, 
    Float, 
    String,
    List_d1,
    Key,    
    Symbol,  
    Function, 
    Event,
    State, 

    Pair, 
    Assoc,
    Array,

    Binop, 
    Unyop,  

    GetVar, 
    SetVar,  
    SetVarG,
    SetVarL,
    SetArray,
    GetArray,
    Call,  
    Run,   

    Print, 
    If,       
    While, 
    For,
    Block,
    Continue,
    Break,
    Return,

    Primitive,
    EventFunc,

    _BasePoint,
    _Undefined,
    _Integer,
    _Long,
    _Float,
    _Double,
    _Char,
    _IntegerArray,
    Thread,
    END,   
};

char *TYPENAME[END+1] = {
"Undefined",
"Operator",
"Integer", 
"Float", 
"String",
    "List_d1",
"Key",    
"Symbol",  
"Function", 
"Event",
"State", 

"Pair", 
"Assoc",
"Array",

"Binop", 
"Unyop",  

"GetVar", 
"SetVar",  
"SetVarG",
"SetVarL",
    "SetArray",
    "GetArray",
"Call",  
"Run",   

"Print", 
"If",       
"While", 
"For",
"Block",
"Continue",
"Break",
"Return",

"Primitive",
"EventFunc",

"_BasePoint",
"_Undefined",
"_Integer",
"_Long",
"_Float",
"_Double",
"_Char",
"_IntegerArray",
"Thread",
"END",
};



enum binop { AND, OR, ADD, SUB, MUL, DIV, MOD, LT, LE, GE, GT, EQ, NE };
enum unyop { NEG, AINC, BINC, ADEC, BDEC};

struct Undefined { enum Type type; };
struct Operator  { enum Type type; char value;};    // for operator
struct Integer 	 { enum Type type;  char* number; int line; };
struct Float     { enum Type type;  char* number; int line;};
struct String    { enum Type type;  char *value; };
struct Key       { enum Type type;  char *pass; };
struct Symbol  	 { enum Type type;  char *name;  oop value; };
struct Function	 { enum Type type;  oop parameters, body;int position;enum Type kind;};
struct Event     { enum Type type; oop id, parameters, body; };
struct State     { enum Type type; oop *events; int size,index; };

struct Pair  	 { enum Type type;  oop a, b; };
struct Assoc     { enum Type type;  oop symbol; enum Type kind; int index; };
struct Array     { enum Type type;  oop *elements; int size,number; int capacity;};

struct Binop   	 { enum Type type;  enum binop op;  oop lhs, rhs;       int line;};
struct Unyop   	 { enum Type type;  enum unyop op;  oop rhs;            int line;};

struct GetVar  	 { enum Type type;  oop id;                             int line;};
struct SetVar  	 { enum Type type;  enum Type typeset; oop id; oop rhs; int line;};
struct SetVarG   { enum Type type;  enum Type typeset; oop id; oop rhs; int line;};
struct SetVarL   { enum Type type;  enum Type typeset; oop id; oop rhs; int line;};
struct Call 	 { enum Type type;  oop function, arguments;            int line;};
struct Run       { enum Type type; oop state; };

struct Print   	 { enum Type type;  oop argument; enum Type kind;};
struct If      	 { enum Type type;  oop condition, statement1, statement2; };
struct While   	 { enum Type type;  oop condition, statement; };
struct For       { enum Type type;  oop initstate, condition,  update, statement; };
struct Block   	 { enum Type type;  oop *statements;  int size; };
struct Continue  { enum Type type; };
struct Break     { enum Type type; };
struct Return    { enum Type type; oop value;};

struct END       { enum Type type; };

struct Primitive{    
    enum Type type;
    char  lib_num;
    char func_num;
    char* args_type_array;
    char  size_of_args_type_array;
    char  return_type;
};

struct EventFunc{
    enum Type type;
    char  lib_num;
    char  eve_num;
    char* args_type_array;
    char  size_of_args_type_array;
    char* pin_num;
    char  size_of_pin_num;
};

#define TAGINT	1			// tag bits value for Integer  ........1
#define TAGFLT	2			// tag bits value for Float    .......10
#define TAGCHA  3
#define TAGBITS 2			// how many bits to use for tag bits
#define TAGMASK ((1 << TAGBITS) - 1)	//.mask to extract just the tag bits

struct _BasePoint { enum Type type; int adress; };
struct _Undefined{ enum Type type; };
struct _Integer  { enum Type type; int _value; };
struct _Long     { enum Type type; long long int value; };
struct _Float    { enum Type type; float _value; };
struct _Double   { enum Type type; double value; };
struct _Char     { enum Type type; char _value; };

struct Default{
    unsigned int count;
};

struct VarI{
    int v_i1;
};

struct VarII{
    int v_i1;
    int v_i2;
};

struct VarF{
    float v_f1;
};

struct VarFF{
    float v_f1;
    float v_f2;
};

struct VarT{
    time_t v_t1;
};

struct VarTI{
    time_t v_t1;
    int    v_i1;
    int    v_i2;
};

union VarData{
    struct Default Default;
    struct VarI  VarI;
    struct VarII VarII;
    struct VarF  VarF; 
    struct VarFF VarFF;    
    struct VarT  VarT; 
    struct VarTI VarTI;
};



struct Thread{
    unsigned int pc,rbp,base;   
    char queue_head; 
    char queue_num; 
    char flag; 
    oop stack; 
    oop queue[5];  
    Func func;
    union VarData*  vd;
};

union Object {
    enum   Type     type;
    struct Operator Operator;
    struct Integer  Integer;
    struct Symbol   Symbol;
    struct String   String; 
    struct Key      Key;
    struct Float    Float;
    struct List_d1  { enum Type _type;enum Type Typeset; }List_d1;

    struct Pair     Pair;
    struct Function Function;
    struct Binop    Binop;
    struct Unyop    Unyop;
    struct GetVar   GetVar;
    struct SetVar   SetVar;
    struct SetVarG SetVarG;
    struct SetVarL SetVarL;
    //in progress
    struct GetArray	 { enum Type _type;enum Type typeset;  oop array, index; int line;}GetArray;
    struct SetArray	 { enum Type _type;enum Type typeset;  oop array, index, value; int line;}SetArray;

    struct Call     Call;
    struct Print    Print;
    struct If       If;
    struct While    While;
    struct For      For;
    struct Block    Block;

    struct Continue Continue;
    struct Break    Break;
    struct Return   Return;
    struct Assoc    Assoc;
    struct Run      Run;
    struct State    State;
    struct Event    Event;
    struct END      END;
    struct Array    Array;

    struct Primitive Primitive;
    struct EventFunc EventFunc;

    struct _BasePoint _BasePoint;
    struct _Undefined _Undefined;
    struct _Integer   _Integer  ;
    struct _Long      _Long     ;
    struct _Float     _Float    ;
    struct _Double    _Double   ;
    struct _Char      _Char     ;
    //in progress
    struct _IntegerArray {enum Type _type;oop* array; int size, capacity;}_IntegerArray;
    struct Thread     Thread;
};


int getType(oop o)
{
    if ((((intptr_t)o) & TAGMASK) == TAGINT) return _Integer;
    if ((((intptr_t)o) & TAGMASK) == TAGFLT) return _Float;
    if ((((intptr_t)o) & TAGMASK) == TAGFLT) return _Float;
    return o->type;
}





oop _check(oop node, enum Type type, char *file, int line)
{
    if (getType(node) != type) {
	fprintf(stderr, "\n%s:%d: expected type %d got type %d\n", file, line, type, getType(node));
		printf("%s but %s\n",TYPENAME[type],TYPENAME[getType(node)]);
    exit(1);
    }
    return node;
}

#define get(PTR, TYPE, FIELD)	(_check((PTR), TYPE, __FILE__, __LINE__)->TYPE.FIELD)

oop _newObject(size_t size, enum Type type)
{
    oop node = calloc(1, size);
    node->type = type;
    return node;
}

#define newObject(TYPE)	_newObject(sizeof(struct TYPE), TYPE)

/*---------------------------------------------*/
oop _newInteger(int value)
{
    return (oop)(((intptr_t)value << TAGBITS) | TAGINT);
}

oop _newCharInteger(char *number)
{
    int value = atoi(number);
    return (oop)(((intptr_t)value << TAGBITS) | TAGINT);
}

int _Integer_value(oop obj)
{
    assert(_Integer == getType(obj));
    return (intptr_t)obj >> TAGBITS;
}

oop _newLong(long long int value){
    oop node = newObject(_Long);
    node->_Long.value = value;
    return node;
}

oop _newCharLong(char* number){
    char *endptr;
    long long int value = strtoll(number,&endptr,10);
    return _newLong(value);
}

oop _newFloat(float value)
{
    union { double d;  intptr_t i; } u = { .d = (double)value };
    return (oop)(((intptr_t)u.i & ~TAGMASK) | TAGFLT);
}

oop _newCharFloat(char* number)
{
    double value = atof(number);
    union { double d;  intptr_t i; } u = { .d = value };
    return (oop)(((intptr_t)u.i & ~TAGMASK) | TAGFLT);
}

float _Float_value(oop obj)
{
    assert(_Float == getType(obj));
    union { intptr_t i;  double d; } u = { .i = (intptr_t)obj };
    return (float)u.d;
}

oop _newDouble(double value){
    oop node = newObject(_Double);
    node->_Double.value = value;
    return node;
}

oop _newCharDouble(char* number){
    char *endptr;
    double value = strtod(number, &endptr);
    return _newDouble(value);
}



/////////CHAR
// #define _newChar(A) (oop)(((intptr_t)A << TAGBITS) | TAGCHA)
oop _newChar(char value)
{
    return (oop)(((intptr_t)value << TAGBITS) | TAGCHA);
}

oop _newCharChar(char number)
{
    char value  = number;
    return (oop)(((intptr_t)value << TAGBITS) | TAGCHA);
}

oop _newStrChar(char* number)
{
    assert(strlen(number)==2);
    char value  = number[0];
    return (oop)(((intptr_t)value << TAGBITS) | TAGCHA);
}

#define _Char_value(A) (char)((intptr_t)A >> TAGBITS)
//FIXME: make segmentation error
// char _Char_value(oop obj)
// {
//     assert(_Char == getType(obj));
//     out("char value");
//     return (intptr_t)obj >> TAGBITS;
// }


// in progress
oop _newIntegerArray(int size){
    oop node = newObject(_IntegerArray);
    node->_IntegerArray.capacity = size;/*Free size*/
    node->_IntegerArray.size     = size;
    node->_IntegerArray.array    = calloc(size, sizeof(oop));
    return node;
}




oop newArray(int);



/*---------------------------------------------*/
// oop newOperator(char value){
//     oop node = newObject(Operator);
//     node->Operator.value = value;
//     return node;
// }


oop newInteger(char* number,int line)
{
    oop node = newObject(Integer);
    node->Integer.number = strdup(number);
    node->Integer.line   = line;
    return node;
}

oop newFloat(char* number, int line){
    oop node = newObject(Float);
    node->Float.number = strdup(number);
    node->Float.line = line;
    return node;
}

oop newString(char *value){
    oop node = newObject(String);
    node->String.value = strdup(value);
    return node;
}

oop newKey(char *pass){
    oop node = newObject(Key);
    // is it need here? pass length 8~12 or fix num?
    // in this time 8
    if(8!=strlen(pass)){
        fprintf(stderr,"Key length shoud be 8\n");
        exit(1);
    }
    node->Key.pass = strdup(pass);
    return node;
}

oop newSymbol(char *name)
{
    oop sym = newObject(Symbol);
    sym->Symbol.name  = strdup(name);
    sym->Symbol.value = sys_false;
    return sym;
}

oop *symbols = 0;
int nsymbols = 0;

oop intern(char *name)
{
    // binary search for existing symbol
    int lo = 0, hi = nsymbols - 1;
    while (lo <= hi) {
	int mid = (lo + hi) / 2;
	int cmp = strcmp(name, get(symbols[mid], Symbol,name));
	if      (cmp < 0) hi = mid - 1;
	else if (cmp > 0) lo = mid + 1;
	else    return symbols[mid];
    }
    symbols   = realloc(symbols,   sizeof(*symbols)   * (nsymbols + 1));
    memmove(symbols + lo + 1,
	    symbols + lo,
	    sizeof(*symbols) * (nsymbols++ - lo));
    return symbols[lo] = newSymbol(name);
}

oop newList_d1(enum Type t){
    oop node = newObject(List_d1);
    node->List_d1.Typeset = t;
    return node;
}

void printlnObject(oop node, int indent);
oop newPair(oop a, oop b)
{
    oop obj = newObject(Pair);
    obj->Pair.a = a;
    obj->Pair.b = b;
    return obj;
}

oop newFunction(oop parameters, oop body)
{
    oop node = newObject(Function);
    // * type need here *//
    node->Function.parameters = parameters;
    node->Function.body       = body;
    node->Function.position   = 0;
    node->Function.kind       = Undefined;
    return node;
}

oop newBinop(enum binop op, oop lhs, oop rhs,int line)
{
    oop node = newObject(Binop);
    node->Binop.op  = op;
    node->Binop.lhs = lhs;
    node->Binop.rhs = rhs;
    node->Binop.line = line;
    return node;
}

oop newUnyop(enum unyop op, oop rhs,int line)
{
    oop node = newObject(Unyop);
    node->Unyop.op  = op;
    node->Unyop.rhs = rhs;
    node->Unyop.line = line;
    return node;
}

oop newGetVar(oop id,int line)
{
    oop node = newObject(GetVar);
    node->GetVar.id = id;
    node->GetVar.line = line;
    return node;
}

oop newSetVar(oop typeset, oop id, oop rhs,int line)
{
    oop node = newObject(SetVar);
    node->SetVar.id  = id;
    node->SetVar.typeset = getType(typeset);
    node->SetVar.rhs = rhs;
    node->SetVar.line = line;
    return node;
}

oop newSetVarG(oop typeset, oop id, oop rhs,int line)
{
    oop node = newObject(SetVarG);
    node->SetVarG.id  = id;
    node->SetVarG.typeset = getType(typeset);
    node->SetVarG.rhs = rhs;
    node->SetVarG.line = line;
    return node;
}

oop newSetVarL(oop typeset, oop id, oop rhs,int line)
{
    oop node = newObject(SetVarL);
    node->SetVarL.id  = id;
    node->SetVarL.typeset = getType(typeset);
    node->SetVarL.rhs = rhs;
    node->SetVarL.line = line;
    return node;
}

//in progress
oop newSetArray(oop typeset,oop array, oop index, oop value,int line)
{
    oop node = newObject(SetArray);
    node->SetArray.typeset = getType(typeset);
    node->SetArray.array = array;
    node->SetArray.index = index;
    node->SetArray.value = value;
    node->SetArray.line  = line;
    return node;
}

oop newGetArray(oop array, oop index,int line)
{
    oop node = newObject(GetArray);
    node->GetArray.array = array;
    node->GetArray.index = index;
    node->SetArray.line  = line;
    return node;
}

oop newCall(oop arguments, oop function,int line)
{
    oop node = newObject(Call);
    node->Call.arguments = arguments;
    node->Call.function  = function;
    node->Call.line = line;
    return node;
}

oop newPrint(oop argument,oop kind)
{
    oop node = newObject(Print);
    node->Print.argument = argument;
    node->Print.kind     = kind->type;
    return node;
}

oop newIf(oop condition, oop s1, oop s2)
{
    oop node = newObject(If);
    node->If.condition = condition;
    node->If.statement1 = s1;
    node->If.statement2 = s2;
    return node;
}

oop newWhile(oop condition, oop s)
{
    oop node = newObject(While);
    node->While.condition = condition;
    node->While.statement = s;
    return node;
}

oop newFor(oop initstate,oop condition,oop updata,oop statement){
    oop node = newObject(For);
    node->For.initstate = initstate;
    node->For.condition = condition;
    node->For.update    = updata;
    node->For.statement = statement;
    return node;
}

oop newBlock(void)
{
    oop node = newObject(Block);
    node->Block.statements = 0;
    node->Block.size = 0;
    return node;
}

void Block_append(oop b, oop s)
{
    oop *ss = get(b, Block,statements);
    int  sz = get(b, Block,size);
    ss = realloc(ss, sizeof(oop) * (sz + 1));
    ss[sz++] = s;
    get(b, Block,statements) = ss;
    get(b, Block,size) = sz;
}
// leg 9
oop newContinue(){
    return newObject(Continue);
}
oop newBreak(){
    return newObject(Break);
}
oop newReturn(oop value){
    oop node =  newObject(Return);
    node->Return.value = value;
    return node;
}

oop newRun(oop s){
    oop node = newObject(Run);
    node->Run.state = s;
    return node;
}

oop newState(void)
{
    oop node = newObject(State);
    node->State.events = 0;
    node->State.size   = 0;
    return node;
}

oop newEvent(oop id,oop params,oop body){
    oop node = newObject(Event);
    node->Event.id = id;
    node->Event.parameters = params;
    node->Event.body   = body;
    return node;
}

void State_append(oop s, oop e)
{
    oop *ss = get(s, State,events);
    int  sz = get(s, State,size);
    ss = realloc(ss, sizeof(oop) * (sz + 1));
    ss[sz++] = e;
    get(s, State,events) = ss;
    get(s, State,size)   = sz;
}

oop newEND(void){
    oop node = newObject(END);
    return node;
}

oop new_Basepoint(int adress){
    oop node = newObject(_BasePoint);
    node->_BasePoint.adress = adress;
    return node;
}

oop newAssoc(oop symbol,enum Type kind,int index){
    oop node = newObject(Assoc);
    node->Assoc.symbol = symbol;
    node->Assoc.kind   = kind;
    node->Assoc.index  = index;
    return node;
}


oop newArray(int capacity){
    oop obj = newObject(Array);
    obj->Array.size = 0;
    obj->Array.number = 0;
    obj->Array.capacity = capacity;
    obj->Array.elements = calloc(capacity, sizeof(oop));
    return obj;
}

int Array_size(oop obj){
    assert(getType(obj)==Array);
    return obj->Array.size;
}

int Array_number(oop obj){
    assert(getType(obj)==Array);
    return obj->Array.number;
}

oop Array_put(oop obj,unsigned int index,oop element)
{
    assert(getType(obj)==Array);
    if(index >obj->Array.capacity){
        obj->Array.elements= realloc(obj->Array.elements,(index+1)*sizeof(oop));
        obj->Array.capacity=index + 1;
    }
    while(obj->Array.size<(index+1)){
        obj->Array.elements[obj->Array.size++]=nil;
        obj->Array.number++;
    }
    return obj->Array.elements[index]=element;
}

oop Array_get(oop obj, unsigned int index){
    assert(getType(obj)==Array);
    if(index < obj->Array.size)
		return obj->Array.elements[index];
	return nil;
};

oop Array_push(oop obj,oop element){
    assert(getType(obj)==Array);
    if(obj->Array.size >= obj->Array.capacity){
		obj->Array.elements = realloc(obj->Array.elements,(obj->Array.size + 1) * sizeof(oop));
		obj->Array.capacity += 1;
    }
    obj->Array.number++;
    obj->Array.elements[obj->Array.size++] = element;
    return obj;
};

oop Array_pop(oop obj){
    assert(getType(obj)==Array);
	if(obj->Array.size <= 0){
		fprintf(stderr,"Array is empty [array_pop]\n");
		exit(1);
	}
    oop element = obj->Array.elements[--obj->Array.size];
    obj->Array.elements[obj->Array.size] = nil;
    return element;
};


// ライブラリ用のプログラミングコード
oop _newPrimitive(oop name,char lib_num,char func_num,char* args_type_array,char size_of_args_type_array,char return_type){
    oop prim = newObject(Primitive);
    prim->Primitive.lib_num   = lib_num;
    prim->Primitive.func_num  = func_num;
    prim->Primitive.return_type = return_type;
    prim->Primitive.args_type_array = args_type_array;
    prim->Primitive.size_of_args_type_array  = size_of_args_type_array;
    name->Symbol.value = prim;
    return prim;
}

#define newPrimitive(name, lib_num, func_num, return_type, size_of_args_type_array,  ...) ({ \
    static char name##__[size_of_args_type_array] = {__VA_ARGS__}; \
    _newPrimitive(intern(#name), lib_num, func_num,name##__, size_of_args_type_array , return_type);\
})




// ---------　イベント用の関数　---------------

#define list(...)  {__VA_ARGS__}

oop _newEventFunc(oop name,char lib_num,char eve_num,char* args_type_array,char size_of_args_type_array,char * pin_num,char  size_of_pin_num){
    oop prim = newObject(EventFunc);
    prim->EventFunc.lib_num   = lib_num;
    prim->EventFunc.eve_num  = eve_num;
    prim->EventFunc.args_type_array = args_type_array;
    prim->EventFunc.size_of_args_type_array  = size_of_args_type_array;
    prim->EventFunc.pin_num = pin_num;
    prim->EventFunc.size_of_pin_num = size_of_pin_num;
    name->Symbol.value = prim;
    return prim;
}



#define newEventFunc(name, lib_num, eve_num, size_of_args_type_array, args_type_array,size_of_pins,pins) ({ \
    static char name##__[size_of_args_type_array] = args_type_array; \
    static char name##__p[size_of_pins] =  pins ; \
    if(name##__[0]==Undefined){ \
        _newEventFunc(intern(#name), lib_num, eve_num,0,0,0,0);\
    } \
    else if(name##__p[0] == Undefined) _newEventFunc(intern(#name), lib_num, eve_num, name##__,size_of_args_type_array,0, 0 );\
    else _newEventFunc(intern(#name), lib_num, eve_num, name##__,size_of_args_type_array, name##__p, size_of_pins); \
})


// ----------- 関数の定義: Event function definition.----------------

typedef enum {
    STDLIB,
    USERLIB,
} LIB;

enum STDLIB_E{
    LOOP_E,
    TIMERSEC_E,
    KEYGET_E,
};

enum STDLIB_P{
    OUTPUT_P,
    ITOC_P,
    APPENDCHAR_P,
    EXIT_P,
};


void setting_stdlib(){
    //Primitive Function
    /*  (name, lib_num, func_num, return_type, size_of_args_type_array,  args_type )  */
    newPrimitive(output, STDLIB,OUTPUT_P,Undefined ,1,_Integer);
    newPrimitive(itoc  ,STDLIB, ITOC_P  ,_Char     ,1,_Integer);
    newPrimitive(exit,  STDLIB, EXIT_P  ,Undefined ,1,_Integer);
    newPrimitive(appendchar,  STDLIB, APPENDCHAR_P  , String ,2,_Char,String);
    //Event Function
                /*関数名,   libnum, funcnum, num_args, args_type, num_of_pin,　pin_value */
/*
    call_e lib func pin
    event(int k) 
*/
    newEventFunc(loop,     STDLIB, LOOP_E    ,1,list(Undefined),1,list(Undefined));
    newEventFunc(timer_sec,STDLIB, TIMERSEC_E,1,list(_Integer),1,list(Operator)); /*FIXME: Operater should be 1*/
    newEventFunc(keyget,   STDLIB, KEYGET_E  ,1,list(_Integer),1,list(Undefined));
    return;
}




void printlnObject(oop node, int indent)
{
    printf("%*s", indent*2, "");
    switch (getType(node)) {
	case Undefined:	printf("nil\n");				break;
	case Integer:	printf("%s\n", get(node, Integer,number));	break;
	case Symbol :	printf("%s\n", get(node, Symbol,name));		break;
    case Float :    printf("%s\n",get(node,   Float,number));     break;
    case String :   printf("%s\n", get(node, String, value));   break;// c5
    case Key:       printf("%s\n", get(node, Key,    pass));    break;
	case Pair: {
	    printf("Pair\n");
	    printlnObject(get(node, Pair,a), indent+1);
	    printlnObject(get(node, Pair,b), indent+1);
	    break;
	}
	case Function: {
	    printf("function()\n");
	    printlnObject(get(node, Function,parameters), indent+2);
	    printlnObject(get(node, Function,body), indent+1);
	    break;
	}
	case Binop: {
	    switch (get(node, Binop,op)) {
		case NE:  printf("NE\n"); break;
		case EQ:  printf("EQ\n"); break;
		case LT:  printf("LT\n"); break;
		case LE:  printf("LE\n"); break;
		case GE:  printf("GE\n"); break;
		case GT:  printf("GT\n"); break;
		case ADD: printf("ADD\n"); break;
		case SUB: printf("SUB\n"); break;
		case MUL: printf("MUL\n"); break;
		case DIV: printf("DIV\n"); break;
		case MOD: printf("MOD\n"); break;
		default:  assert(!"this cannot happen binop");
	    }
	    printlnObject(get(node, Binop,lhs), indent+1);
	    printlnObject(get(node, Binop,rhs), indent+1);
	    break;
	}
	case Unyop: {
	    switch (get(node, Unyop,op)) {
		case NEG: printf("NEG\n"); break;
		default:  assert(!"this cannot happen unyop");
	    }
	    printlnObject(get(node, Unyop,rhs), indent+1);
	    break;
	}
	case GetVar: {
	    printf("GetVar %s\n", get(get(node, GetVar,id), Symbol,name));
	    break;
	}
	case SetVar: {
	    printf("SetVar %s\n", get(get(node, SetVar,id), Symbol,name));
	    printlnObject(get(node, SetVar,rhs), indent+1);
	    break;
	}
	case Call: {
	    printf("Call\n");
	    printlnObject(get(node, Call,function), indent+1);
	    printlnObject(get(node, Call,arguments), indent+1);
	    break;
	}
	case Print: {
	    printf("Print\n");
	    printlnObject(get(node, Print,argument), indent+1);
	    break;
	}
	case If: {
	    printf("If\n");
	    printlnObject(get(node, If,condition), indent+1);
	    printlnObject(get(node, If,statement1), indent+1);
	    printlnObject(get(node, If,statement2), indent+1);
	    break;
	}
	case While: {
	    printf("While\n");
	    printlnObject(get(node, While,condition), indent+1);
	    printlnObject(get(node, While,statement), indent+1);
	    break;
	}
	case Block: {
	    printf("Block...\n");
	    break;
	}
    case Event:{
        printf("Event\n");
        break;
    }
    case State:{
        printf("State\n");
        break;
    }
    case Run:{
        printf("Run\n");
        break;
    }
    case Continue:{
        printf("Continue\n");
        break;
    }
    case Break:{
        printf("Break\n");
        break;
    }
    case Return:{
        printf("Return\n");
        break;
    }
    case END:{
        printf("END\n");
        break;
    }
    case Array:{
        int size = node->Array.size;
        printf("Array\n");
        for(int i = 0;i<size;i++){
            printlnObject(node->Array.elements[i],indent+1);
        }
        break;
    }
    case Assoc:{
        printf("type %2d, index %3d",node->Assoc.kind,node->Assoc.index);
        printlnObject(node->Assoc.symbol,indent);
        break;
    }
    case _Integer:printf("%d\n",_Integer_value(node));break;
    case _Long:   printf("%lld\n",get(node,_Long,value));break;
    case _Float:  printf("%f\n",_Float_value(node));break;
    case _Double: printf("%lf\n",get(node,_Double,value));break;
	default:	printf("%s\n",TYPENAME[node->type]);assert(!"this cannot happen print");			break;
    }
}







#define YYSTYPE oop

YYSTYPE result;

int newline = 1;

%}


start	= bln d:define 	{ result = d }

define  = t:STATE i:id s:state                { $$ = newSetVar(t,i,s,newline)  }
        | d:bracket 	{ result = d }
        | t:TYPE   i:id p:params s:stmtbl     { $$ = newSetVar(t,i,newFunction(p,s),newline) } 
        | t:TYPE   i:id ASSIGN x:exp		  { $$ = newSetVarG(t, i, x,newline);}
        | RUN      i:id                       { $$ = newRun(newGetVar(i,newline)) }
        | !.                                  { $$ = newEND() }
	    | < (!eol &. .)* >                    { fatal("line %d syntax error: [%s]",newline, yytext); }

state   = LBRACE s:mkState
	  (
	    bln !RBRACE
	    e:event                     { State_append(s, e) }
	  )+
	  bln RBRACE			{ $$ = s }

mkState =                                   { $$ = newState() }

event   = i:id p:params b:blocks             { $$ = newEvent(i,p,b) }
        | t:TYPE  i:id  ASSIGN  x:exp       { $$ = newSetVar(t, i, x,newline);}
        | t:TYPE  i:id b:bracket ASSIGN x:list NLINE { $$ = newSetArray(t,i,b,x,newline); }

stmt	= PRINT LPAR t:TYPE COMMA x:exp RPAR NLINE      { $$ =  newPrint(x,t); }
	    | IF LPAR c:exp RPAR s:stmtbl
	      bln ELSE t:stmtbl            	        { $$ = newIf(c, s, t) }
	    | IF    LPAR c:exp RPAR s:stmtbl	{ $$ = newIf(c, s, sys_false) }
	    | WHILE LPAR c:exp RPAR s:stmtbl	{ $$ = newWhile(c, s) } 
        | FOR LPAR (i:expr | i:mkNil) SEMI (e:exp | e:mkNil) SEMI (u:expr|u:mkNil) RPAR s:stmtbl { $$ = newFor(i,e,u,s) }
        | CONTINUE NLINE                    { $$ = newContinue() }
        | BREAK    NLINE                    {  $$ = newBreak() }
        | RETURN - e:exp                      { $$ = newReturn(e) }
        | STATE i:id  NLINE                  { $$ = newRun(i) }
	    | x:expr  NLINE                      { $$ = x  }
	    | !.                                { $$ = nil } 
	    | < (!eol &. .)* >                  { fatal("line %d syntax error: [%s]",newline, yytext); }

stmtbl = block 
       | stmt

blocks  = b:mkBlock (bx:block  {Block_append(b, bx)} )+ {$$ = b}

block   =  LBRACE b:mkBlock 
	  (
	    bln !RBRACE
	    s:stmt                      { Block_append(b, s) }
	  )+
	  bln RBRACE			{ $$ = b }

mkBlock =                               { $$ = newBlock() }

expr	= assign 

assign  = (t:TYPE | t:mkNil) i:id (ASSIGN x:exp	    { $$ = newSetVar(t, i, x,newline);}
                                  |ADDEQU x:exp     { $$ = newSetVar(t, i, newBinop(ADD,x,newGetVar(i,newline),newline),newline)} 
                                  |SUBEQU x:exp     { $$ = newSetVar(t, i, newBinop(SUB,x,newGetVar(i,newline),newline),newline)} 
                                  |MULEQU x:exp     { $$ = newSetVar(t, i, newBinop(MUL,x,newGetVar(i,newline),newline),newline)} 
                                  |DIVEQU x:exp     { $$ = newSetVar(t, i, newBinop(DIV,x,newGetVar(i,newline),newline),newline)} 
                            )
        | (t:TYPE | t:mkNil) i:id b:bracket ASSIGN (x:list | x:exp) { $$ = newSetArray(t, i,b, x,newline);}
        | func
        
#// brackets  = (s:mkBlock 
#//                 (b:bracket { Block_append(s, b) })*
#//             )+ {printf("bk\n");$$ = s}
bracket   =  LSQP  e:exp RSQP { printf("[]\n");$$ = e }

#// lists = 


#//in progress
list  = LBRACE b:mkBlock bln
	  ( s:exp		{ Block_append(b, s) }
	    (bln COMMA bln s:exp		{ Block_append(b, s) }
	    )*
	  )+
 	  bln RBRACE			{ $$ = b }

	    
exp     = logadd
   


params	= LPAR p:mkNil
	  ( t:TYPE i:id			    { p = newPair(newPair(t,i), p) }
	    ( COMMA t:TYPE i:id		{ p = newPair(newPair(t,i), p) }
	    )*
	  )?
 	  RPAR				{ $$ = p }

mkNil	= 				{ $$ = nil }

logadd  = lhs:logmul ( LOGOR rhs:logmul { lhs = newBinop(OR,lhs,rhs,newline) })* { $$ = lhs }

logmul  = lhs:eqop (LOGAND rhs:eqop { lhs = newBinop(AND,lhs,rhs,newline) })* { $$ = lhs }


eqop    = lhs:ineq ( EQUAL rhs:ineq	{ lhs = newBinop(EQ, lhs, rhs,newline) }
	  	   | NOTEQ rhs:ineq	{ lhs = newBinop(NE, lhs, rhs,newline) }
	  	  )*			{ $$ = lhs }

ineq    = lhs:add ( GREATER rhs:add	{ lhs = newBinop(GT, lhs, rhs,newline) }
	          | GREATEQ rhs:add	{ lhs = newBinop(GE, lhs, rhs,newline) }
	          | LESSEQ  rhs:add	{ lhs = newBinop(LE, lhs, rhs,newline) }
	          | LESS    rhs:add	{ lhs = newBinop(LT, lhs, rhs,newline) }
	  	  )*			{ $$ = lhs }


add	= lhs:mul ( PLURS   rhs:mul	{ lhs = newBinop(ADD, lhs, rhs,newline) }
	  	  | MINUS  rhs:mul	{ lhs = newBinop(SUB, lhs, rhs,newline) }
	  	  )*			{ $$ = lhs }


mul	= lhs:prefix ( STAR  rhs:prefix	{ lhs = newBinop(MUL, lhs, rhs,newline) }
	  	     | SLASH rhs:prefix	{ lhs = newBinop(DIV, lhs, rhs,newline) }
	  	     | PCENT rhs:prefix	{ lhs = newBinop(MOD, lhs, rhs,newline) }
	  	     )*			{ $$ = lhs }

prefix	= MINUS x:value		{ $$ = newUnyop(NEG, x,newline) }
        | INCRE i:id     { $$ = newUnyop(BINC, newGetVar(i,newline),newline) }
        | DECRE i:id     { $$ = newUnyop(BDEC, newGetVar(i,newline),newline) }
        | postfix

postfix = i:id INCRE - { $$ = newUnyop(AINC, newGetVar(i,newline),newline) }
        | i:id DECRE - { $$ = newUnyop(ADEC, newGetVar(i,newline),newline) }
        | func
        | value 


func    = i:id a:args		{ $$ = newCall(a, i, newline); }          

args	= LPAR a:mkNil
	  ( i:exp			{ a = newPair(i, a) }
	    ( COMMA i:exp		{ a = newPair(i, a) }
	    )*
	  )?
 	  RPAR				{ $$ = a }

value	= LPAR lhs:add   RPAR		{ $$ = lhs }
        | QUOTE  character    QUOTE -  
        | DQUOTE string DQUOTE  -
        | float_  
	    | integer         
	    | i:id				{ $$ = newGetVar(i,newline) }


float_	= < ( [0-9]+            expnt
	    | [0-9]+ '.' [0-9]* expnt?
	    | [0-9]* '.' [0-9]+ expnt?
	    ) > -			{ $$ = newFloat(yytext,newline) }

expnt	= 'e' [-+]? [0-9]+

string  = < (!"\"" .)* >  -        { $$ = newString(yytext) }
character = alpha                  { $$ = _newStrChar(yytext)}
integer	= < [0-9]+ > - 		       { $$ = newInteger(yytext,newline) }
id	= < alpha alnum* > -	       { $$ = intern(yytext);  }


alpha	= [a-zA-Z_]
alnum	= [a-zA-Z_0-9] | '_'

-	= space*
space	= [ \t]
	    |  '//' (![\n\r] .)*


bln	= blank*
blank	= [ \t\r]
        | NLINE 
	    | '//' (![\n\r] .)* 

NLINE   = "\n"  { ++newline }


eol	= [\r\n]

TYPE    = "int" -    { $$ = newObject(_Integer)}
        | "long"-    { $$ = newObject(_Long)   }
        | "dou" -    { $$ = newObject(_Double) }
        | "flo" -    { $$ = newObject(_Float)  }
        | "cha" -    { $$ = newObject(_Char)   }
        | "str" -    { $$ = newObject(String)  }
        | "key" -    { $$ = newObject(Key)     }

ASSIGN	= "=" !"="  -
ADDEQU  = "+="      -
SUBEQU  = "-="      -
MULEQU  = "*="      -
DIVEQU  = "/="      -

LOGAND     = "&&"      -

LOGOR      = "||"      -

EQUAL   = "=="	    -
NOTEQ   = "!="      -

LESS    = "<" ![=<] -
LESSEQ  = "<="      -
GREATEQ = ">="      -
GREATER = ">" ![=>] -

PLURS	= "+" 	    -
MINUS	= "-" 	    -

STAR	= "*" 	    -
SLASH	= "/" 	    -
PCENT	= "%" 	    -

INCRE   = "++"      
DECRE   = "--"
LPAR	= "(" 	    -
RPAR	= ")" 	    -
LSQP    = "["       -
RSQP    = "]"       -
COMMA	= ","       -
SEMI    = ";"       -
LBRACE  = "{" 	    - 
RBRACE  = "}" 	    - 
QUOTE   = "\'"      
DQUOTE  = "\""      

#//PLING	= "!" !"="  -

STATE    = "state"    !alnum - { $$ = newObject(State) }
PRINT    = "print"    !alnum -
IF       = "if"       !alnum -
ELSE     = "else"     !alnum -
WHILE    = "while"    !alnum -
FOR      = "for"      !alnum -
RUN      = "run"      !alnum -
CONTINUE = "continue"
BREAK    = "break"
RETURN   = "return"
%%;

// https://programming-place.net/ppp/contents/c/appendix/operation.html
oop newBoolean(int flag) { return flag ? sys_true : sys_false; }
/*     0    1           2       3       4      5    6       7   8*/
enum instrac{
HALT,
i_load,/* value */
l_load,/* value */
f_load,/* value */
d_load,/* value */
c_load,/* value */
s_load,/* value */
k_load,/* value */
//in progress
il_load,/* vnt adress */
ll_load,/* vnt adress */
fl_load,/* vnt adress */
dl_load,/* vnt adress */

i_EQ,
i_NE,
i_LT,
i_LE,
i_GE,
i_GT,
i_AND,
i_OR,
i_ADD,
i_SUB,
i_MUL,
i_DIV,
i_MOD,
l_EQ,
l_NE,
l_LT,
l_LE,
l_GE,
l_GT,
l_ADD,
l_SUB,
l_MUL,
l_DIV,
l_MOD,
f_EQ,
f_NE,
f_LT,
f_LE,
f_GE,
f_GT,
f_ADD,
f_SUB,
f_MUL,
f_DIV,
d_EQ,
d_NE,
d_LT,
d_LE,
d_GE,
d_GT,
d_ADD,
d_SUB,
d_MUL,
d_DIV,

s_EQ,
s_NE,
s_LT,
s_LE,
s_GE,
s_GT,
s_AND,
s_OR,
s_ADD,
s_SUB,
s_MUL,
s_DIV,
s_MOD,


EOE,   /* end of event function*/
TRANS, /*transition: state change*/
THREAD,/* make thread for event */
SET_EVENT,
GLOBAL,
GLOBAL_END,
ENTRY,
/*don't change order start*/
GET,
GET_L,
GET_G,
DEFINE,
DEFINE_L, /* pos */
DEFINE_G, /* pos */
DEFINE_List,    /* vnt index */ //in progress
DEFINE_List_L,  /* vnt index */
DEFINE_List_G,  /* vnt index */
/*don't change order end*/
CALL,
CALL_P,
CALL_E,
SETQ,
RET,
MSUB,
MPOP,
MPICK,
MSET,//global value size settting
JUMP,
JUMPF,
i_PRINT,
l_PRINT,
f_PRINT,
d_PRINT,
c_PRINT,
s_PRINT,
};

char* INSTNAME[s_PRINT + 1] = {
"HALT",
"i_load",/* value */
"l_load",/* value */
"f_load",/* value */
"d_load",/* value */
"c_load",/* value */
"s_load",/* value */
"k_load",/* value */
//in progress
"il_load",/* vnt adress */
"ll_load",/* vnt adress */
"fl_load",/* vnt adress */
"dl_load",/* vnt adress */

"i_EQ",
"i_NE",
"i_LT",
"i_LE",
"i_GE",
"i_GT",
"i_AND",
"i_OR",
"i_ADD",
"i_SUB",
"i_MUL",
"i_DIV",
"i_MOD",
"l_EQ",
"l_NE",
"l_LT",
"l_LE",
"l_GE",
"l_GT",
"l_ADD",
"l_SUB",
"l_MUL",
"l_DIV",
"l_MOD",
"f_EQ",
"f_NE",
"f_LT",
"f_LE",
"f_GE",
"f_GT",
"f_ADD",
"f_SUB",
"f_MUL",
"f_DIV",
"d_EQ",
"d_NE",
"d_LT",
"d_LE",
"d_GE",
"d_GT",
"d_ADD",
"d_SUB",
"d_MUL",
"d_DIV",

"s_EQ",
"s_NE",
"s_LT",
"s_LE",
"s_GE",
"s_GT",
"s_AND",
"s_OR",
"s_ADD",
"s_SUB",
"s_MUL",
"s_DIV",
"s_MOD",

"EOE",   /* end of event function*/
"TRANS", /*transition: state change*/
"THREAD",/* make thread for event */
"SET_EVENT",
"GLOBAL",
"GLOBAL_END",
"ENTRY",
/*don't change order start*/
"GET",
"GET_L",
"GET_G",
"DEFINE",
"DEFINE_L", /* pos */
"DEFINE_G", /* pos */
"DEFINE_List",    /* vnt index */ //in progress
"DEFINE_List_L",  /* vnt index */
"DEFINE_List_G",  /* vnt index */
/*don't change order end*/
"CALL",
"CALL_P",
"CALL_E",
"SETQ",
"RET",
"MSUB",
"MPOP",
"MPICK",
"MSET",//global value size settting
"JUMP",
"JUMPF",
"i_PRINT",
"l_PRINT",
"f_PRINT",
"d_PRINT",
"c_PRINT",
"s_PRINT",
};






enum instrac Binop_oprand(enum Type type,enum binop binop,int line){
    switch(type){
        case _Integer:{
            switch(binop){
                case AND: return i_AND;
                case OR: return i_OR;
                case EQ: return i_EQ;
                case NE: return i_NE;
                case LT: return i_LT;
                case LE: return i_LE;
                case GE: return i_GE;               
                case GT: return i_GT;
                case ADD:return i_ADD;
                case SUB:return i_SUB;
                case MUL:return i_MUL;
                case DIV:return i_DIV;
                case MOD:return i_MOD;
                default: printf("this cannot happen in Binop_oprand Integer\n");
            }
            break;
        }
        case _Long:{
            switch(binop){
                case AND: fatal("line %d oprand error: logic and cannot apply Long type\n",line);
                case OR:  fatal("line %d oprand error: logic or cannot apply Long type\n",line);
                case EQ: return l_EQ; 
                case NE: return l_NE; 
                case LT: return l_LT; 
                case LE: return l_LE; 
                case GE: return l_GE;                  
                case GT: return l_GT; 
                case ADD:return l_ADD; 
                case SUB:return l_SUB; 
                case MUL:return l_MUL; 
                case DIV:return l_DIV; 
                case MOD:return l_MOD; 
                default: printf("this cannot happen Binop_oprand Long\n");
            }
            break;
        }
        case _Float:{
            switch(binop){
                case AND: fatal("line %d oprand error: logic and cannot apply Float type\n",line);
                case OR:  fatal("line %d oprand error: logic or cannot apply Float type\n",line);
                case EQ:  return f_EQ;
                case NE:  return f_NE;
                case LT:  return f_LT;
                case LE:  return f_LE;
                case GE:  return f_GE;                
                case GT:  return f_GT;
                case ADD: return f_ADD;
                case SUB: return f_SUB;
                case MUL: return f_MUL;
                case DIV: return f_DIV;
                case MOD: fatal("line %d oprand error: MOD cannot apply Float type\n",line);
                default: printf("this cannot happen Binop_oprand Float\n");
            }
            break;
        }
        case _Double:{
            switch(binop){
                case AND: fatal("line %d oprand error: logic and cannot apply Double type\n",line);
                case OR:  fatal("line %d oprand error: logic or cannot apply Double type\n",line);
                case EQ: return d_EQ; 
                case NE: return d_NE; 
                case LT: return d_LT; 
                case LE: return d_LE; 
                case GE: return d_GE;                  
                case GT: return d_GT; 
                case ADD:return d_ADD;
                case SUB:return d_SUB;
                case MUL:return d_MUL;
                case DIV:return d_DIV;
                case MOD: fatal("line %d oprand error: MOD cannot apply Double type\n",line);
                default: printf("this cannot happen Binop_oprand Double\n");
            }
            break;
        }
        case String:{            //now
            switch(binop){
                case AND: fatal("line %d oprand error: logic and cannot apply String type\n",line);
                case OR:  fatal("line %d oprand error: logic or cannot apply String type\n",line);
                case EQ: return s_EQ; 
                case NE: return s_NE; 
                case LT: return s_LT; 
                case LE: return s_LE; 
                case GE: return s_GE;                  
                case GT: return s_GT; 
                case ADD:return s_ADD;
                case SUB:fatal("line %d oprand error: logic or cannot apply String type\n",line);
                case MUL:fatal("line %d oprand error: logic or cannot apply String type\n",line);
                case DIV:fatal("line %d oprand error: logic or cannot apply String type\n",line);
                case MOD: fatal("line %d oprand error: MOD cannot apply Double type\n",line);
                default: printf("this cannot happen Binop_oprand Double\n");
            }
            break;
        }
        case _Char:{
            fprintf(stderr,"not yet\n");
            exit(1);
        }
        default:{
            fprintf(stderr,"%s has not been applied to calculations\n",TYPENAME[type]);
            exit(1);
        }
    }
    fprintf(stderr,"%s has not been applied MOD\n",TYPENAME[type]);
    exit(1);
    return 0;
}


/*
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                        compile code
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
*/

// break stack
int *b_stack = 0;
int   b_size = 0;
int   b_max  = 0;

void b_push(int i){
    // minus number is mark
    if(i>0 && b_size==0){
        fprintf(stderr,"break is defined outside loop\n");
        exit(1);
    }
    if(b_size >= b_max){
        b_stack = realloc(b_stack,sizeof(*b_stack) *( b_size + 1));
        b_max++;
    }
    b_stack[b_size++] = i;
}

int b_pop(){
    if(b_size==0){
        fprintf(stderr,"break out of stack\n");
        exit(1);
    }
    return b_stack[--b_size];
}

// continue stack
int *c_stack = 0;
int  c_size  = 0;
int  c_max   = 0;

void c_push(int i){
    // minus number is mark
    if(i>0 && c_size==0){
        fprintf(stderr,"continue is defined outside loop\n");
        exit(1);
    }
    if(c_size>=c_max){
        c_stack = realloc(c_stack,sizeof(*c_stack) *( c_size + 1));
    }
    c_stack[c_size++] = i;
}
int c_pop(){
    if(c_size==0){
        fprintf(stderr,"continue out of stack\n");
        exit(1);
    }
    return c_stack[--c_size];
}


//find key in the alist (variable name table).
oop assoc(oop key, oop alist)
{
    if (getType(alist) == Array) {
        int size = alist->Array.size;
        for(int i=0; i<size; i++){
            oop head = alist->Array.elements[i];
            if(head == nil)continue;
            if(head->Assoc.symbol == key) return head;
        }
    }
    return nil;
}

//remove assoc form end to size of vnt (variable name table)
oop kill_assoc(oop vnt,int end){
    assert(getType(vnt) == Array);
    int size = vnt->Array.size;
    for(int i=size-1; i==end;i--){
        vnt->Array.elements[i] = nil;
    }
    return nil;
}


void manage(oop program,enum Type type){
    int size  = 0;
    switch(type){
        case _Integer:
        case _Float:  program->Array.number += 3;break;
        case _Long:
        case _Double: program->Array.number += 7;break;
        default:
            fatal("manage error: unsupported type\n");
    }
    return;
}
/* array put - setnum*/
#define INTSIZE 4 
#define OPESIZE 1

oop compile(oop,oop,oop,enum Type);
#define emit(X)         Array_push(program,X)
#define emitI(A)        emit(_newInteger(A))
#define emitII(OP,A)    emitI(OP); emitI(A); manage(program,_Integer)
#define emitOII(OP,A,B) emitI(OP); emitI(A); manage(program,_Integer); emitI(B); manage(program,_Integer); 
#define emitOIII(OP,A,B,C) emitI(OP); emitI(A); manage(program,_Integer); emitI(B); manage(program,_Integer); emitI(C); manage(program,_Integer); 
#define emitIO(OP,A,T)  emitI(OP); emit(A);  manage(program,T);
#define emitIS(OP,A,S)  emitI(OP); emit(A);  program->Array.number+=S 

#define compO(O)    compile(program,O,vnt,Undefined)
#define compOT(O,T) compile(program,O,vnt,T)
#define compPara(O,L)    compileParams(program,O,vnt,L)

#define compStatement(A,T)({ \
    if(isEntry==0){ \
        size  = vnt->Array.size; \
        compOT(A,T);/* if */ \
        kill_assoc(vnt,size); \
    }else{ \
        size  = Local_VNT->Array.size; \
        compOT(A,T);/* if */ \
        kill_assoc(Local_VNT,size);/*kill*/ \
    } \
})
oop state_Pair = 0; //state (id index)
oop Global_VNT = 0; //Gloval variable name table
oop Local_VNT  = 0; //STATE Local variable name table
int isEntry    = 0; //if defining entry() event, it is 1, otherwise 0.



void compileParams(oop program,oop params,oop vnt,int line){
    int index = 0;
    while(getType(params) == Pair){
        oop para = params->Pair.a;
        if(assoc(para->Pair.b,vnt)!=nil)
            fatal("line %d type error: cannot apply same symbol in parameter\n",line);
        if(assoc(para->Pair.b,Global_VNT)!=nil)
            fatal("line %d variable error: %s parameter in Global variable\n",line,get(para->Pair.b,Symbol,name));
        /* LOCAL VNT */           
        oop ass  = newAssoc(para->Pair.b,getType(para->Pair.a),vnt->Array.size);
        Array_push(vnt,ass);
        /* +3: [stack]
        arg_num　
        ret_pc_num　
        rbp　
        */
        //†††
        emitOII(MPICK, index + 3, ass->Assoc.index);//rbp - (2:return adress & arg num)
        params = params->Pair.b;
        index++;
    }
}



int compArgs(oop program,oop params,oop args,oop vnt){
    if(params->type == Pair && args->type == Pair){
        int size = compArgs(program,params->Pair.b,args->Pair.b,vnt);
        oop para = params->Pair.a; 
        compOT(args->Pair.a,para->Pair.a->type);
        return size + 1;
    }
    if(params->type == Pair)fatal("argument error: too few argument");
    if(args->type == Pair)fatal("argument error: too many argument");
    return 0;
}



//Returns the leftmost type in the tree. (condition)
int child_type(oop exp,oop vnt){
    switch (getType(exp)) {
	case Integer:return Integer;
    case Float:return   Float;
	case Binop: {
        int l = child_type(get(exp,Binop,lhs),vnt);
        switch(l){
            case _Integer:
            case _Long:
            case _Float:
            case _Char:
            case String:
            case _Double:{
                return l;
            }
            default:break;
        }

        int r = child_type(get(exp,Binop,rhs),vnt);
        switch(l){
            case _Integer:
            case _Long:
            case _Float:
            case _Char:
            case String:
            case _Double:{
                return l;
            }
            default:break;
        }
        return l;
	}
	case GetVar:{
        oop sym = get(exp,GetVar,id);
        oop ass = assoc(sym,Global_VNT);
        if(ass==nil)ass = assoc(sym,Local_VNT);
        if(ass==nil)ass = assoc(sym,vnt);
        if(ass == nil){
            fatal("line %d variable error: Undefine variable, %s\n",exp->GetVar.line,sym->Symbol.name);
        }
        return ass->Assoc.kind;
    }

	case Call:{
        oop id = exp->Call.function;
        oop function = get(id,Symbol,value);
	    switch (getType(function)) {
            case Function:{
                return  get(function,Function,kind);
            }
            case Primitive:{
                return get(function,Primitive,return_type);
            }
            default:fatal("line %d HACK: this cannot happen call\n",exp->Call.line);
	    }
	    break;
    }
	default:{
        fatal("line %d HACK: this cannot happen chiled type");
    }
    }
    return Undefined;
}





struct Variable{
    int index;
    int variable_num;
    /*
    0:normal varialble
    1:STT local variable
    2:global varialbe
    */
};

struct Variable* newVariable(int i,int t){
    struct Variable *var = calloc(1,sizeof(struct Variable));
    var->variable_num = t;
    var->index = i;
    return var;
}

/* Find variable from global, local, normal variable name table.
    and then return global/local/vnt, and index where it is stored */
struct Variable* set_id_index(oop id,oop vnt){
    oop ass = assoc(id,Global_VNT); 
    if( ass                        !=nil)return newVariable(get(ass,Assoc,index),2);
    if((ass = assoc(id, Local_VNT))!=nil)return newVariable(get(ass,Assoc,index),1);
    if((ass = assoc(id,vnt))       !=nil)return newVariable(get(ass,Assoc,index),0);
    if(ass == nil)fatal("variable error: Undefined variable, %s",get(id,Symbol,name)); 
    return 0;
}


/// @brief 
/// @param program 
/// @param exp 
/// @param vnt 
/// @param  
/// @return 
oop compile(oop program,oop exp, oop vnt,enum Type type) //add enum Type type
{

    switch (getType(exp)) {
	case Undefined:
	case Integer:{
        switch(type){
            case _Integer:emitIO(i_load, _newCharInteger(get(exp,Integer,number)),_Integer);break;
            case _Long:   emitIO(l_load, _newCharLong(get(exp,Integer,number))   ,_Long);   break;
            case _Char:   emitIO(c_load, _newStrChar(get(exp,Integer,number))   ,_Char);   break;
            default:{
                fprintf(stderr,"line %d type error: %s but %s, ",exp->Integer.line ,TYPENAME[type],TYPENAME[getType(exp)]);
                printlnObject(exp,0);
                exit(1);
            }
        }
        break;
    }
    case Float:{
        switch(type){
            case _Float: emitIO(f_load,_newCharFloat(get(exp,Float,number)) ,_Float);break;
            case _Double:emitIO(d_load,_newCharDouble(get(exp,Float,number)),_Double);break;
            default:{
                fprintf(stderr,"line %d type error: %s but %s, ",exp->Float.line, TYPENAME[type],TYPENAME[getType(exp)]);
                printlnObject(exp,0);
                exit(1);
            }
        }
        break;
    }
    case String:{
        switch(type){
            case String:{
                int str_size = strlen(get(exp,String,value)) ;
                if(str_size > 255)fatal("line x type error: over 255 charactor \n");
                emitIS(s_load,exp,str_size);
                break;
            }
            default:{
                fatal("line x type error: %s but %s",TYPENAME[type],TYPENAME[getType(exp)]);
            }
        }
        break;
    } 
    case _Char:{
        switch(type){
            case _Char:   emitIO(c_load, exp   ,_Char);   break;
            default:{
                fatal("line x type error: %s but %s",TYPENAME[type],TYPENAME[getType(exp)]);
                printlnObject(exp,0);
                exit(1);
            }
        }
    } 
    case Key:{
        fprintf(stderr,"key and string does not allowed now\n");
        exit(1);
        break;
    }
	case Symbol:    break;
	case Pair:	    break;
	case Function:	break;
	case Binop: {
	    compOT(get(exp, Binop,lhs),type);
	    compOT(get(exp, Binop,rhs),type);
        emitI(Binop_oprand(type,get(exp,Binop,op),exp->Binop.line));
        break;
	}
	case Unyop:{
        compOT(get(exp, Unyop,rhs), type);
	    switch (get(exp, Unyop,op)){
            case NEG:{
                switch(type){
                    case _Integer: emitII(i_load,-1)           ;emitI(i_MUL);break;
                    case _Long:    emitIO(l_load,_newLong(-1)  ,_Long)  ;emitI(l_MUL);break;
                    case _Float:   emitIO(f_load,_newFloat(-1) ,_Float) ;emitI(f_MUL);break;
                    case _Double:  emitIO(d_load,_newDouble(-1),_Double);emitI(d_MUL);break;
                    default:fatal("line %d type error: %s type cannnot apply convert negative value\n",exp->Unyop.line,TYPENAME[type]);
                }
                break;
            }
            case BINC:{
                oop id = get(get(exp,Unyop,rhs),GetVar,id); 
                struct Variable *var =  set_id_index(id,vnt);
                switch(type){
                    case _Integer: emitII(i_load,1)          ;emitI(i_ADD);break;
                    case _Long:    emitIO(l_load,_newLong(1),_Long);emitI(l_ADD);break;
                    default: fatal("line %d type error: %s type cannot apply prefix increment, %s\n",exp->Unyop.line,TYPENAME[type],get(id,Symbol,name));
                }
                emitII(DEFINE+var->variable_num,var->index);emitII(GET+var->variable_num,var->index);
                break;
            }
            
            case BDEC:{
                oop id = get(get(exp,Unyop,rhs),GetVar,id); 
                struct Variable *var = set_id_index(id,vnt);
                switch(type){
                    case _Integer: emitII(i_load,1)          ;emitI(i_SUB);break;
                    case _Long:    emitIO(l_load,_newLong(1),_Long);emitI(l_SUB);break;
                    default: fatal("line %d type error: %s type cannot apply prefix decrement, %s\n",exp->Unyop.line,TYPENAME[type],get(id,Symbol,name));
                }
                emitII(DEFINE+var->variable_num,var->index);emitII(GET+var->variable_num,var->index);
                break;
            }
            case AINC:{
                oop id = get(get(exp,Unyop,rhs),GetVar,id); 
                struct Variable * var = set_id_index(id,vnt);
                emitII(GET+var->variable_num,var->index);
                switch(type){
                    case _Integer: emitII(i_load,         1) ;emitI(i_ADD);break;
                    case _Long:    emitIO(l_load,_newLong(1),_Long) ;emitI(l_ADD);break;
                    default: fatal("line %d type error: %s type cannot apply postfix increment, %s\n",exp->Unyop.line,TYPENAME[type],get(id,Symbol,name));
                }
                emitII(DEFINE+var->variable_num,var->index);
                break;
            }
            case ADEC:{
                oop id = get(get(exp,Unyop,rhs),GetVar,id); 
                struct Variable * var = set_id_index(id,vnt);
                emitII(GET+var->variable_num,var->index);
                switch(type){
                    case _Integer: emitII(i_load,         1) ;emitI(i_SUB);break;
                    case _Long:    emitIO(l_load,_newLong(1),_Long);emitI(l_SUB);break;
                    default: fatal("line %d type error: %s type cannot apply postfix decrement, %s\n",exp->Unyop.line,TYPENAME[type],get(id,Symbol,name));
                }
                emitII(DEFINE+var->variable_num,var->index);
                break;
            }
		    default:	assert(!"this cannot happen YNOP");
	    }
	    break;
    }

	case SetVar:{
        //int a = 10 or int add(int a,int b){return a + b} or state default{ event ... }
        int t     = get(exp,SetVar,typeset); //setting type of symbol
        oop id    = get(exp,SetVar,id);      //get symbol
        oop value = get(exp,SetVar,rhs);     //get value, = 10 or (int a,int b){return a + b}
        switch(getType(get(id,Symbol,value))){
            case Undefined:
            case _Integer:
            case _Float:
            case _Long:
            case _Double:break;
            case Function:{
                fatal("line %d definition error: function %s is already defined\n",exp->SetVar.line,get(id,Symbol,name));
                break;
            }
            case State:{
                fatal("line %d definition error: state %s is already defined\n",exp->SetVar.line,get(id,Symbol,name));
                break;
            }
            default:fatal("HACK SetVar");
        }
        switch(getType(value)){
            case Function:{
                get(value,Function,kind) = t;
                get(id,Symbol,value) = value;
                emitII(JUMP,0);             //First, when the code is loaded, the function is ignored (JUMP).
                vnt = newArray(0);          //Create symbol name table
                int jump = program->Array.number;
                int jump_i = program->Array.size;
                //CALL num: num is this number
                get(value,Function,position) = program->Array.number;
            emitII(MSUB,0);                 //rbp for variable
            int msub_loc = program->Array.size;
                oop para = get(value,Function,parameters);
                compPara(para,exp->SetVar.line);
                // vnt = args! check them!
                compOT(get(value,Function,body),t);
            int vnt_size = vnt->Array.size;
            Array_put(program,msub_loc  - 1, _newInteger(vnt_size));//change MSUB num
                int end  = program->Array.number;
                Array_put(program,jump_i - 1, _newInteger(end-jump));//change jump num
                break;
            }
            
            case State:{//†††
                int size = get(value,State,size);
                oop *events = get(value,State,events);
                int event_index[size];
                int Entry_bool = 0;

                // compile event
                int stt_val_c = 0;//for entry()
                for(int i=0;i<size; i++){
                    switch(getType(events[i])){
                        case SetArray:
                        case SetVar:{
                        //FIXME: 
                    /*
                        state s1{
                            e1{
                                ...
                            }
                            int a = 10;
                        }
                    */
                        isEntry = 1;
                        stt_val_c++;
                        compO(events[i]);
                        isEntry = 0;
                        break;
                        }
                        case Event:{
                            event_index[i] = program->Array.number;//where
                            if(get(events[i],Event,id)==entry_sym){
                                if(i-stt_val_c==0){
                                    Entry_bool = 1;
                                    isEntry = 1;
                                    compO(events[i]);
                                    isEntry = 0;
                                }
                                else{
                                    fprintf(stderr,"entry event should be defined first...\n");
                                    exit(1);
                                }
                            }
                            else {compO(events[i]);}
                            break;
                        }
                        default:fatal("line %d not apper\n",__LINE__);
                    }
                }
                
                // 状態遷移の位置
                int stt_loc = program->Array.number;
                value->State.index = stt_loc;


                if(Entry_bool==1){
                    emitII(ENTRY,event_index[stt_val_c] - (stt_loc));
                }
                emitII(THREAD,size - Entry_bool - stt_val_c);
                stt_loc = program->Array.number;

                                /*SIZE OP + SIZE INT */ //now
                // int d = stt_loc + (1 + INTSIZE)*size;
                for(int i=size;i>Entry_bool+stt_val_c;i--){
                                            // +5 => JUMP(1) num(4) => (size 5)
                    
                    oop eve1 = get(events[i-1],Event,id);
                    oop eve2 = get(eve1,Symbol,value);
                    if(getType(eve2)!=EventFunc){
                        fprintf(stderr,"this event is not define\n");
                        exit(1);
                    }
                    emitII(i_load,event_index[i-1] - stt_loc +(1 + INTSIZE));//d => stt_loc
                    for(int i=0;i<eve2->EventFunc.size_of_pin_num;i++){//gress, pin load
                        emitII(i_load,eve2->EventFunc.pin_num[i]);
                    }
                    emitOIII(CALL_E, eve2->EventFunc.lib_num, eve2->EventFunc.eve_num, eve2->EventFunc.size_of_pin_num)//now
                }

                get(id,Symbol,value) = value;
                Local_VNT = newArray(0);
                break;
            }

            default:{
                if(isEntry==0){
                    oop ass = assoc(id,Global_VNT);
                    if(ass!=nil){
                        if(t!=Undefined)fatal("line %d variable error: %s is defined in Global variable\n",exp->SetVar.line,get(id,Symbol,name));
                        compOT(value,ass->Assoc.kind);
                        emitII(DEFINE_G,ass->Assoc.index); 
                    }
                    else if((ass = assoc(id, Local_VNT))!=nil){
                        if(t!=Undefined)fatal("line %d variable error: %s is defined in Local variable\n",exp->SetVar.line,get(id,Symbol,name));
                        compOT(value,ass->Assoc.kind);
                        emitII(DEFINE_L,ass->Assoc.index); 
                    }
                    else{
                        ass = assoc(id,vnt);
                        if(ass == nil){
                            if(t==Undefined)//it is first time defining this symbol, indicate type.
                                fatal("line %d variable error: Undefined variable %s\n",exp->SetVar.line,get(exp, SetVar,id)->Symbol.name);
                            //define new symbol with type
                            ass = newAssoc(get(exp, SetVar,id),t,vnt->Array.size);
                            Array_push(vnt, ass);
                        }
                        else if(t!=Undefined){
                            fatal("line %d variable error:    %s\n",exp->SetVar.line,get(exp, SetVar,id)->Symbol.name);
                        }
                        compOT(value,ass->Assoc.kind);
                        emitII(DEFINE,ass->Assoc.index); 
                    }
                }else{// in the entry(){...}
                    oop ass = assoc(id,Global_VNT);
                    if(ass!=nil){
                        if(t!=Undefined)fatal("line %d variable error: %s is defined in Global variable\n",exp->SetVar.line,get(id,Symbol,name));
                        compOT(value,ass->Assoc.kind);
                        emitII(DEFINE_G,ass->Assoc.index); 
                    }
                    else{
                        ass = assoc(id, Local_VNT);
                        if(ass == nil){
                            if(t==Undefined)//it is first time defining this symbol, indicate type.
                                fatal("line %d variable error: Undefined variable %s\n",exp->SetVar.line,get(exp, SetVar,id)->Symbol.name);
                            //define new symbol with type
                            ass = newAssoc(get(exp, SetVar,id),t,Local_VNT->Array.size);
                            Array_push(Local_VNT, ass);
                        }
                        else if(t!=Undefined){
                            fatal("line %d variable error:    %s\n",exp->SetVar.line,get(exp, SetVar,id)->Symbol.name);
                        }
                        compOT(value,ass->Assoc.kind);
                        emitII(DEFINE_L,ass->Assoc.index); 
                    }
                }

            }
        }
	    break;
    }

    case SetVarG:{
        emitI(GLOBAL);
        int t     = get(exp,SetVarG,typeset); //setting type of symbol
        oop id    = get(exp,SetVarG,id);      //get symbol
        oop value = get(exp,SetVarG,rhs);     //get value, = 10 or (int a,int b){return a + b}
        oop ass = assoc(get(exp, SetVarG,id),Global_VNT);
        if(ass == nil){
            if(t==Undefined){//it is first time defining this symbol, indicate type.
                fatal("line %d variable error: Undefined variable %s\n",exp->SetVarG.line,get(exp, SetVarG,id)->Symbol.name);
            }
            //define new symbol with type
            ass = newAssoc(get(exp, SetVarG,id),t,Global_VNT->Array.size);
            Array_push(Global_VNT, ass);
        }
        t = ass->Assoc.kind;
        compOT(value,t);
        emitII(DEFINE_G,ass->Assoc.index);   
        emitI(GLOBAL_END);      
        break;
    }

	case GetVar:{
        oop id = get(exp,GetVar,id);
        oop ass = assoc(id,Global_VNT);
        if(ass!=nil){
            if(ass->Assoc.kind != type)//The requested type and symbol do not match
                fatal("line %d type error: requared [%s] type but [%s] type, global variable %s\n",exp->GetVar.line,TYPENAME[type],TYPENAME[ass->Assoc.kind],id->Symbol.name);
            emitII(GET_G,ass->Assoc.index);
        }
        else if((ass=assoc(id,Local_VNT))!=nil){
            if(ass->Assoc.kind!=type)
                fatal("line %d type error: requared %s type but %s type, local variable %s",exp->GetVar.line,TYPENAME[type],TYPENAME[ass->Assoc.kind],id->Symbol.name);
            emitII(GET_L,ass->Assoc.index);
        }
        else if((ass = assoc(id,vnt))!=nil){
            if(ass->Assoc.kind!=type)
                fatal("line %d type error: requared %s type but %s type, nomal variable %s",exp->GetVar.line,TYPENAME[type],TYPENAME[ass->Assoc.kind],id->Symbol.name);
            emitII(GET,ass->Assoc.index);
        }
        else{     //sym is not define
                fatal("line %d variable error: Undefine variable, %s\n",exp->GetVar.line,id->Symbol.name);
        }
        break;
    }
    // in progress
    case SetArray:{
        int t =      get(exp,SetArray,typeset);
        oop id =     get(exp,SetArray,array);
        oop values = get(exp,SetArray,value);
        oop index =  get(exp,SetArray,index);
        oop ass   = nil;
        printf("gt %2d\n",getType(Global_VNT));
        printf("lt %2d\n",getType(Local_VNT));
        printf("t  %2d\n",getType(vnt));
        if((ass = assoc(id,Global_VNT))==nil){
            if((ass = assoc(id,Local_VNT))==nil){
                if((ass = assoc(id,vnt))==nil){
                    if(t!=Undefined){
                        //in progress
                        user_error(getType(values)!=Block,"definitnion error: list\n",get(exp,SetArray,line));
                        oop value = newList_d1(_IntegerArray);
                        get(id,Symbol,value) = value;
                        ass = newAssoc(id,t,vnt->Array.size);
                        Array_push(vnt, ass);
                        int size = get(values,Block,size);
                        for(int i=0;i<size;i++){
                            compOT(values->Block.statements[i],t);
                        }
                        compOT(index,_Integer);
                        emitII(il_load,ass->Assoc.index);
                        return exp;
                    }else{
                        user_error(1,"definition error: Undefined variable\n",get(exp,SetArray,line));
                    }
                }
            }
        }
        //　要素の変更
        if(t==Undefined){
            user_error(getType(values)==Block,"definition error: not allow muti values",get(exp,SetArray,line));
            switch(get(ass,Assoc,kind)){
                case _Integer:{
                    compOT(values,ass->Assoc.kind);
                    compOT(index,ass->Assoc.kind);
                    emitII(DEFINE_List,ass->Assoc.index);
                    break;
                }
                case _Long:
                case _Double:
                case _Float:
                default:{
                    fprintf(stderr,"line %d: type error: not match\n",get(exp,SetArray,line));
                    exit(1);
                }
            }
        }else{
            fprintf(stderr,"line %d definition error: defined variable\n",get(exp,SetArray,line));
            exit(1);
        }
        break;
    }
    case GetArray:{
        int t =     get(exp,SetArray,typeset);
        oop id =    get(exp,SetArray,array);
        oop value = get(exp,SetArray,value);
        oop index = get(exp,SetArray,index);
    }

	case Call:{
        oop id = exp->Call.function;
        oop function = get(id,Symbol,value);
	    switch (getType(function)){
            case Function:{
                int t = get(function,Function,kind);
                if(type!=Undefined && type!=t){
                    fatal("line %d type error: %s type but %s type, function %s\n",exp->Call.line,TYPENAME[type],TYPENAME[t],id->Symbol.name);
                }
                oop args   = get(exp,Call,arguments);
                oop params = get(function, Function,parameters);
                int num = compArgs(program,params,args,vnt);//leg11
                int i = program->Array.number;
                            /*number of args*/ /*function location*/
                emitOII(CALL,num, get(function,Function,position) - i -(OPESIZE + INTSIZE*2));
                break;
            }
            case Primitive:{
                char t       = get(function,Primitive,return_type);
                if(type!=Undefined && type!=t){
                    fatal("line %d type error: %s type but %s type, function %s\n",exp->Call.line,TYPENAME[type],TYPENAME[t],id->Symbol.name);
                }
                char* para_t = get(function,Primitive,args_type_array);
                char para_s  = get(function,Primitive,size_of_args_type_array);
                oop   args   = get(exp,Call,arguments);
                for(int i=0; i<para_s ;i++){
                    if(args == nil){
                        fprintf(stderr,"error: PRIMITVE\n");
                        exit(1);
                    }
                    compOT(args->Pair.a, para_t[i]);
                    args = args->Pair.b;
                }
                emitOIII(CALL_P,get(function,Primitive, lib_num),get(function,Primitive,func_num),para_s);
                break;
            }
            case EventFunc:{
                // set pin or trigger conditino value.
                // in this here, not compile anything.
                if(isEntry!=1){
                    fprintf(stderr,"Definition Error: Event functions cannot be initialized except by the setup event function\n ");
                    exit(1);
                }
                oop args = get(exp,Call,arguments);
                char size = get(function,EventFunc,size_of_pin_num);
                for(int i=0; i< size;i++){//#
                    assert(getType(args->Pair.a)==Integer);
                    function->EventFunc.pin_num[i] =  atoi(args->Pair.a->Integer.number);
                    args = args->Pair.b;
                }
                break;
            }
            default:printlnObject(function,2);fatal("line %d HACK: this cannot happen CALL %s\n",exp->Call.line,TYPENAME[getType(function)]);
	    }
        
	    break;
    }

	case Print:{
        compOT(get(exp, Print,argument),get(exp,Print,kind));
        //TODO: make four type of print
        int k_type = get(exp,Print,kind);
        switch(k_type){
            case _Integer:emitI(i_PRINT);break;
            case _Long   :emitI(l_PRINT);break;
            case _Float  :emitI(f_PRINT);break;
            case _Double :emitI(d_PRINT);break;
            case String  :emitI(s_PRINT);break;
            case _Char   :emitI(c_PRINT);break;
        }
        break;
    }

	case If:{// ENTRY...
        int c_type = child_type(get(exp, If,condition),vnt);
        switch(c_type){
            case Integer: c_type = _Integer;break;
            case Float:   c_type = _Float;  break;
            default:break;
        }
        compOT(get(exp, If,condition),c_type);
        emitII(JUMPF,0);//->done or else
        int jump1 = program->Array.number;
        int jump1_i = program->Array.size;
        int size =0;
        compStatement(get(exp,If,statement1),type);
        // size  = vnt->Array.size;//kill
        // compOT(get(exp, If,statement1),type);/* if */
        // kill_assoc(vnt,size);//kill
        oop stmt2 = get(exp,If,statement2);
        //else
        if(stmt2 != sys_false){
            emitII(JUMP,0);//->done
            int jump2 = program->Array.number;
            int jump2_i = program->Array.size;
            
            int p_else = jump2; /* else */

            compStatement(stmt2,type);
            // size = vnt->Array.size;//kill
            // compOT(stmt2,type);
            // kill_assoc(vnt,size);//kill


            int p_done = program->Array.number;/* done */
            Array_put(program, jump1_i- 1, _newInteger(p_else - jump1));/* jumpf -> else */
            Array_put(program, jump2_i- 1, _newInteger(p_done - jump2));/* jump  -> done */
        }
        else{// not else
            Array_put(program, jump1_i- 1, _newInteger(program->Array.number - jump1));/* jumpf -> else */
        }
        break;
    }

	case While:{
        b_push(-1);//MEMO: negative value is mark for break
        c_push(-1);//MEMO: negative value is mark for continue
        int L1 = program->Array.number;/*cond*/
        int size = 0;
        compStatement(get(exp,While,condition),_Integer);
        // size = vnt->Array.size;//kill
        // compOT(get(exp, While,condition),_Integer);
        // kill_assoc(vnt,size);

        emitII(JUMPF,0);
        int L2 = program->Array.number;
        int L2_i = program->Array.size;
        

        compStatement(get(exp,While,statement),type);
        // size = vnt->Array.size;//kill
        // compOT(get(exp, While,statement),type);//err
        // kill_assoc(vnt,size);
        


        emitII(JUMP, 0);
        int L4 = program->Array.number;/*done*/
        int L4_i = program->Array.size;/*done*/
        Array_put(program,L2_i - 1,_newInteger(L4-L2));/* jumpf -> done */
        Array_put(program,L4_i - 1,_newInteger(L1-L4)); /* jump  -> cond */

        for(;;){
            int i = c_pop();
            if(i<0)break;
            Array_put(program,c_pop() - 1,_newInteger(L1 - i));
        }
        for(;;){
            int i = b_pop();
            if(i<0)break;
            Array_put(program,b_pop() - 1,_newInteger(L4 - i));
        }
        break;
    }

    case For:{//for(initstate,condition,updata){ statement }
        b_push(-1);//MEMO: negative value is mark for break
        c_push(-1);//MEMO: negative value is mark for continue
        int size = 0;
        if(isEntry==0) size  = vnt->Array.size; 
        else           size  = Local_VNT->Array.size; 
        
        if(get(exp,For,initstate)!=nil)
            compO(get(exp,For,initstate));//for(int i = 0,...)
        
        emitII(JUMP,0);//jump update
        int L1   = program->Array.number;
        int L1_s = program->Array.size;
        if(get(exp,For,update)!=nil)
            compOT(get(exp,For,update),Undefined);
        int L2 = program->Array.number;
        int L2_s = program->Array.size;
        if(get(exp,For,condition)!=nil)
            compOT(get(exp,For,condition),_Integer);
        else{emitII(i_load,1);}
        emitII(JUMPF,0);
        int jumpf = program->Array.number;
        int jumpf_s = program->Array.size;

        compOT(get(exp,For,statement),type);
        emitII(JUMP,0);
        int done    = program->Array.number;
        int done_s  = program->Array.size;

        if(isEntry==0)  kill_assoc(vnt,size); 
        else            kill_assoc(Local_VNT,size);
        
    Array_put(program,L1_s -1,_newInteger(L2 - L1));/* jump first update */
    Array_put(program,done_s -1,_newInteger(L1 - done));/*done -> update */
    Array_put(program,jumpf_s-1,_newInteger(done - jumpf)); /* jumf  -> done */
    kill_assoc(vnt,size);//kill env

        for(;;){
            int i = c_pop();
            if(i<0)break;
            Array_put(program,c_pop() - 1,_newInteger(L1 - i));
        }
        for(;;){
            int i = b_pop();
            if(i<0)break;
            Array_put(program,b_pop() - 1,_newInteger(done - i));
        }
        break;
        break;
    }
    case Break:{
        emitII(JUMP,0);
        b_push(program->Array.size);
        b_push(program->Array.number);
        break;
    }
    case Continue:{
        emitII(JUMP,0);
        c_push(program->Array.size);
        c_push(program->Array.number);
        break;
    }
    case Return:{
        compOT(get(exp,Return,value),type);
        emitI(RET);
        break;
    }
	case Block:{
        oop *statements = get(exp, Block,statements);
	    int  size       = get(exp, Block,size);
	    for (int i = 0;  i < size;  ++i){
            compOT(statements[i],type);
        }    
	    break;
    }
    case Event:{
        emitII(JUMP,0);
    int jump_i = program->Array.size;
    int jump = program->Array.number;

        oop id    = get(exp, Event, id);
        oop para  = get(exp, Event, parameters);
        oop block = get(exp, Event, body);
        vnt = newArray(0);
        int m_loc = program->Array.size;

        if(id!=entry_sym){//isEntry: assign should be define STT local
            oop eve   = get(id,Symbol, value);
            int args_s =  eve->EventFunc.size_of_args_type_array;
            char *args =  eve->EventFunc.args_type_array;
    //now: check parameter: e,g,. timer(int n) <= int n
            for(int i=0;i<args_s;i++){
                if(para==nil){fprintf(stderr,"event fuction args tatinai error\n");exit(1);}
                oop a = get(para,Pair,a);
                if(args[i]!=getType(a->Pair.a)){fprintf(stderr,"event fuction args[%s]!=para[%s] error\n",TYPENAME[args[i]],TYPENAME[getType(a->Pair.a)]);exit(1);}
                if(assoc(a->Pair.b,vnt)!=nil)
                    fatal("type error: cannot apply same symbol in parameter\n");
                if(assoc(a->Pair.b,Global_VNT)!=nil)
                    fatal("variable error: %s parameter in Global variable\n",get(para->Pair.b,Symbol,name));
                /* LOCAL VNT */           
                oop ass  = newAssoc(a->Pair.b,args[i],vnt->Array.size);
                Array_push(vnt,ass);
                para = para->Pair.b;
            }
        }
        compO(block);
    int m_size = vnt->Array.size;
    Array_put(program,m_loc -1, _newInteger(m_size));
        vnt = nil;
        isEntry = 0;//entry() 
        emitI(MPOP);
        emitI(EOE);
    Array_put(program,jump_i -1,_newInteger(program->Array.number - jump));// jump event 
        break;
    }

    case State:{
        printf("state\n");
        exit(0);
    }
    case Run:{
        oop id = get(exp,Run,state);
        emitII(TRANS,0);
        int L = program->Array.number;
        int L_i = program->Array.size;

        state_Pair = newPair(newPair(id,newPair(_newInteger(L_i),_newInteger(L))),state_Pair);
        break;
    }
    case END:{
        while(state_Pair->type == Pair){
            oop node = state_Pair->Pair.a;
            oop id = node->Pair.a;//state that is called
            int to_index = id->Symbol.value->State.index;//†††
            oop index = node->Pair.b;//index that state call
            int from_index_i = _Integer_value(index->Pair.a);
            int from_index = _Integer_value(index->Pair.b);
            //†††
            Array_put(program,from_index_i - 1,_newInteger(to_index - from_index));
            state_Pair = state_Pair->Pair.b;
        }
        return sys_false;
    }
	default:{
        printf("%s\n",TYPENAME[exp->type]);
        assert(!"this cannot happen compile");
    }
    
    }
    return exp;
}


/*
    begin memory
*/

void _error(char *msg, char *file, int line)
{
    fprintf(stderr, "\n%s(%d) ", file, line);
    perror(msg);
    exit(1);
}

#define error(X) _error(X, __FILE__, __LINE__)
typedef unsigned char byte;

byte   *memory  = 0;  // memory is a huge array of bytes
size_t  memsize = 0;  // this is the current size of data stored in memory
size_t  memcap  = 0;  // this is the maximum dize of data that memory can hold

void _genByte(byte b)  // append one byte the the memory
{
    if  (memsize >= memcap) { // memory is full, extend it
        memcap = memcap ? memcap * 2 : 1024;   // 1k, 2k, 4k, 8k, 16k, ...
        memory = realloc(memory, memcap);
    }
    assert(memsize < memcap);
    memory[memsize++] = b;
}

void memoryClear(void) // clear the contents of memory
{
    free(memory);
    memory  = 0;
    memsize = 0;
    memcap  = 0;
}

#define genByte(A,B) ({\
    for(int i=0;i<B;i++){\
        _genByte(A[i]);\
    }\
})

const unsigned int SIZE_INST   = sizeof(unsigned char);
const unsigned int SIZE_INT    = sizeof(int);            //size of int
const unsigned int SIZE_LONG   = sizeof(long long int);  //size of long long int
const unsigned int SIZE_FLOAT  = sizeof(float);          //size of float
const unsigned int SIZE_DOUBLE = sizeof(double);         //size of double

#define genData(S,D) ({ \
    unsigned char buffer[S]; \
    memcpy(buffer, &D, S); \
    genByte(buffer,S); \
})

void genOp(int data){
    _genByte((byte)data);
}

#define genChar(A) _genByte((byte)A)

void genInt(int data){
    genData(SIZE_INT,data);
}

void genLong(long long int data){
    genData(SIZE_LONG,data);
}

void genFloat(float data){
    genData(SIZE_FLOAT,data);
}

void genDouble(double data){
    genData(SIZE_DOUBLE,data);
}

void genString(char *data){
    genByte(data,strlen(data));
    _genByte('\0');
}


void memoryWrite(char *path) // write memory to a file
{
    FILE *fp = fopen(path, "w");
    if (!fp) error(path);
    if (memsize != fwrite(memory, 1, memsize, fp)) // write memory to file
	error(path);
    fclose(fp);
}

/* READ */



void memoryRead(char *path) // read memory from an external file
{
    struct stat buf;
    if (stat(path, &buf)) error(path); // get file information including size

    FILE *fp = fopen(path, "r");
    if (!fp) error(path);

    memsize = memcap = buf.st_size; // set memory size same as file size
    memory = malloc(memsize);       // allocate just the right amount of memory
    if (!memory) error("malloc");

    if (memsize != fread(memory, 1, memsize, fp)) // read memory from file
	error(path);
    fclose(fp);
}


/*
    end memory
*/


oop CodeWrite(oop program){
    int pc = 0;
    oop stack = newArray(10);
    for(;;){
#if TEST
        // printf("%3d\n",pc);
#endif
        oop inst = Array_get(program,pc++);
        if(getType(inst)!=_Integer){
            printf("[%s] ",TYPENAME[getType(inst)]);
            printlnObject(inst,0);
        }
        int op = _Integer_value(inst);
        genOp(op);
        switch(op){
            case TRANS: genInt(_Integer_value(Array_get(program,pc++)));continue;
            case i_load:genInt(_Integer_value(Array_get(program,pc++)));continue;
            case l_load:genLong(Array_get(program,pc++)->_Long.value);continue;
            case f_load: genFloat(_Float_value(Array_get(program,pc++)));continue;
            case d_load: genDouble(Array_get(program,pc++)->_Double.value);continue;
            case c_load: genChar(_Char_value(Array_get(program,pc++)));continue;
            case s_load: genString(Array_get(program,pc++)->String.value);continue;
            case il_load:genInt(_Integer_value(Array_get(program,pc++)));continue;
            case i_EQ:   continue; 
            case i_NE:   continue; 
            case i_LT:   continue; 
            case i_LE:   continue; 
            case i_GE:   continue; 
            case i_GT:   continue; 
            case i_ADD:  continue;
            case i_SUB:  continue;
            case i_MUL:  continue;
            case i_DIV:  continue;
            case i_MOD:  continue;
            case l_EQ:   continue; 
            case l_NE:   continue; 
            case l_LT:   continue; 
            case l_LE:   continue; 
            case l_GE:   continue; 
            case l_GT:   continue; 
            case l_ADD:  continue;
            case l_SUB:  continue;
            case l_MUL:  continue;
            case l_DIV:  continue;
            case l_MOD:  continue;
            case f_EQ:   continue; 
            case f_NE:   continue; 
            case f_LT:   continue; 
            case f_LE:   continue; 
            case f_GE:   continue; 
            case f_GT:   continue; 
            case f_ADD:  continue;
            case f_SUB:  continue;
            case f_MUL:  continue;
            case f_DIV:  continue;
            case d_EQ:   continue; 
            case d_NE:   continue; 
            case d_LT:   continue; 
            case d_LE:   continue; 
            case d_GE:   continue; 
            case d_GT:   continue; 
            case d_ADD:  continue;
            case d_SUB:  continue;
            case d_MUL:  continue;
            case d_DIV:  continue;

            case s_EQ:   continue; 
            case s_NE:   continue; 
            case s_LT:   continue; 
            case s_LE:   continue; 
            case s_GE:   continue; 
            case s_GT:   continue; 
            case s_ADD:  continue;

            case THREAD: genInt(_Integer_value(Array_get(program,pc++)));continue;
            case EOE:    continue;
            case CALL:{
                genInt(_Integer_value(Array_get(program,pc++)));
                genInt(_Integer_value(Array_get(program,pc++)));
                continue;
            }
            case CALL_P:{
                genInt(_Integer_value(Array_get(program,pc++)));
                genInt(_Integer_value(Array_get(program,pc++)));
                genInt(_Integer_value(Array_get(program,pc++)));
                continue;
            }
            case CALL_E:{
                genInt(_Integer_value(Array_get(program,pc++)));
                genInt(_Integer_value(Array_get(program,pc++)));
                genInt(_Integer_value(Array_get(program,pc++)));
                continue;         
            }
            case GET:{
                genInt(_Integer_value(Array_get(program,pc++)));
                continue;
            }
            case GET_L:{
                genInt(_Integer_value(Array_get(program,pc++)));
                continue;
            }
            case GET_G:{
                genInt(_Integer_value(Array_get(program,pc++)));
                continue;
            }
            case DEFINE:{
                genInt(_Integer_value(Array_get(program,pc++)));
                continue;
            }
            case DEFINE_L:{
                genInt(_Integer_value(Array_get(program,pc++)));
                continue;
            }
            case DEFINE_G:{
                genInt(_Integer_value(Array_get(program,pc++)));
                continue;
            }  
            case DEFINE_List:{
                genInt(_Integer_value(Array_get(program,pc++)));
                continue;
            }  
            case ENTRY:{
                genInt(_Integer_value(Array_get(program,pc++)));
                continue;
            }
            case GLOBAL:{
                continue;
            }
            case GLOBAL_END:{
                continue;
            }
            case SETQ:{
                continue;
            }
            case RET:{
                continue;
            }
            case MSUB:{
                genInt(_Integer_value(Array_get(program,pc++)));
                continue;
            }
            case MPOP:{
                continue;
            }
            case MPICK:{
                genInt(_Integer_value(Array_get(program,pc++)));
                genInt(_Integer_value(Array_get(program,pc++)));
                continue;
            }
            case MSET:{
                genInt(_Integer_value(Array_get(program,pc++)));
                continue;
            }
            case JUMPF:{
                genInt(_Integer_value(Array_get(program,pc++))); 
                continue;
            }
            case JUMP:{
                genInt(_Integer_value(Array_get(program,pc++))); 
                continue;       
            }
            case i_PRINT:{
                continue;
            }
            case l_PRINT:{
                continue;
            }
            case f_PRINT:{
                continue;
            }
            case d_PRINT:{
                continue;
            }
            case c_PRINT:{
                continue;
            }
            case s_PRINT:{
                continue;
            }
            case HALT:{
                return nil;
            }
        }
    }
}



















/*
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                    main code
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
*/

int has_txt_extension(const char *filename) {
    const char *ext = strrchr(filename, '.');  // ファイル名中の最後の'.'を探す
    if (ext != NULL && strcmp(ext, ".txt") == 0) {
        return 1;  // .txt拡張子がある場合は1を返す
    }
    return 0;      // それ以外の場合は0を返す
}



typedef enum {Default, VarI, VarII, VarF, VarFF, VarT, VarTI} VAR;

typedef enum {F_NONE, F_EOE, F_TRANS, F_ERROR} FLAG;
FLAG sub_execute(oop,oop);
void main_execute();
oop printCode(oop);
oop printByteCode();

#define ARRAY_DEF(name, size, ...) ({oop name##__ = intern("sss");})


int main(int argc, char const *argv[])
{
    // コマンドライン引数の確認
    if (argc == 2){

    // ファイル名の拡張子をチェック
    if (!has_txt_extension(argv[1])) {
        fprintf(stderr, "エラー: ファイルは .txt 拡張子でなければなりません\n");
        return 1;
    }

    // ファイルを読み込みモードで開く
    SOURCE_FILE = fopen(argv[1], "r");
    if (SOURCE_FILE == NULL) {
        perror("ファイルを開けませんでした");
        return 1;
    }

    setting_stdlib();
    nil   = newObject(Undefined);
    sys_false = _newInteger(0);
    sys_true  = _newInteger(1);
    none  = _newInteger(2);
    entry_sym = intern("entry");
    ARRAY_DEF(heke,1,2);
    newSymbol("exit");
    state_Pair = nil;
    oop program = newArray(0);
    Local_VNT   = newArray(0);
    Global_VNT  = newArray(0);
    
    printf("    compile     %d%s\n",argc,argv[0]);
    printf("\n \x1b[31m parsing ******************\x1b[0m\n\n");
    emitII(MSET,0);
    while (yyparse()) {
        // printlnObject(result, 0);
        if(sys_false == compile(program,result,nil,Undefined))break;
    }
    emitI(HALT);
    Array_put(program,1,_newInteger(Global_VNT->Array.size));
#if TEST
    printf("Successful\n");
    printf("\n \x1b[31m print code *********************\x1b[0m\n\n");
    printCode(program);
#endif
    printf("\n \x1b[31m write code *********************\x1b[0m\n\n");
    CodeWrite(program);
    memoryWrite("code.stt");
#if TEST
    printf("\n \x1b[31m print byte code after memory write ******************\x1b[0m\n\n");
    printByteCode();
#endif
    
#if TEST
    printf("\n \x1b[31m print byre code *********************\x1b[0m\n\n");
    printf("memory_size %zu\n",memsize);
#endif
    free(program);
    free(symbols);
    memoryClear();
}else if(argc == 1){
    printf("    execute     %d %s\n",argc,argv[0]);

    printf("\n \x1b[31m read code ******************\x1b[0m\n\n");
    struct timeval startTime, endTime;  // 構造体宣言
    clock_t startClock, endClock;       // clock_t型変数宣言
    
    gettimeofday(&startTime, NULL);     // 開始時刻取得
    startClock = clock();               // 開始時刻のcpu時間取得

    memoryRead("code.stt");
#if TEST
    printf("memory_size %zu\n",memsize);
#endif
    printf("\n \x1b[31m print byte code after memory read ******************\x1b[0m\n\n");
    printByteCode();
    printf("\n \x1b[31m main_execute code ******************\x1b[0m\n\n");
    main_execute();
    printf("\n \x1b[31m**************************\x1b[0m\n"); 
    gettimeofday(&endTime, NULL);       // 開始時刻取得
    endClock = clock();                 // 開始時刻のcpu時間取得
    
    time_t diffsec = difftime(endTime.tv_sec, startTime.tv_sec);    // 秒数の差分を計算
    suseconds_t diffsub = endTime.tv_usec - startTime.tv_usec;      // マイクロ秒部分の差分を計算
    //以下の処理は不要(15/10/28)
    //if (diffsub < 0) {                                              // マイクロ秒が負になったとき
    //    diffsec -= 1;                                               // 秒部分を繰り下げ
    //    diffsub = 1000000 + diffsub;                                // 1秒との差
    //}
    double realsec = diffsec+diffsub*1e-6;                          // 実時間を計算
    double cpusec = (endClock - startClock)/(double)CLOCKS_PER_SEC; // cpu時間を計算
    printf("%f\n",realsec);
    printf("%f\n",cpusec);
    double percent = 100.0*cpusec/realsec;                          // 使用率を100分率で計算
    printf("CPU使用率%f %%\n", percent);                            // 表示
    }else{
        fprintf(stderr, "使用方法: %s <ファイル名>\n", argv[0]);
        return 1;
    }
    return 0;
}

/*
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                        print  code
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
*/


oop printCode(oop program){
    int pc = 0;
    oop stack = newArray(10);
    for(;;){
        printf("%3d ",pc);
        oop inst = Array_get(program,pc++);
        if(getType(inst)!=_Integer){
            printf("[%s] ",TYPENAME[getType(inst)]);
            printlnObject(inst,0);
        }
        switch(_Integer_value(inst)){
            case TRANS:  printf("TRANS     %3d\n",_Integer_value(Array_get(program,pc++)));continue;
            case i_load: printf("i_load    %3d\n",_Integer_value(Array_get(program,pc++)));continue;
            case l_load: printf("l_load    %3lld\n",Array_get(program,pc++)->_Long.value);continue;
            case f_load: printf("f_load    %3f\n",_Float_value(Array_get(program,pc++)));continue;
            case d_load: printf("d_load    %3f\n",Array_get(program,pc++)->_Double.value);continue;
            case c_load: printf("i_load    %3c\n",_Char_value(Array_get(program,pc++)));continue;
            case s_load: printf("s_load    %s\n", Array_get(program,pc++)->String.value);continue;
            case il_load: printf("il_load    %d\n", _Integer_value(Array_get(program,pc++)));continue;
            case i_EQ:   printf("i_EQ\n"); continue; 
            case i_NE:   printf("i_NE\n"); continue; 
            case i_LT:   printf("i_LT\n"); continue; 
            case i_LE:   printf("i_LE\n"); continue; 
            case i_GE:   printf("i_GE\n"); continue; 
            case i_GT:   printf("i_GT\n"); continue; 
            case i_ADD:  printf("i_ADD\n");continue;
            case i_SUB:  printf("i_SUB\n");continue;
            case i_MUL:  printf("i_MUL\n");continue;
            case i_DIV:  printf("i_DIV\n");continue;
            case i_MOD:  printf("i_MOD\n");continue;
            case l_EQ:   printf("l_EQ\n");continue; 
            case l_NE:   printf("l_NE\n");continue; 
            case l_LT:   printf("l_LT\n");continue; 
            case l_LE:   printf("l_LE\n");continue; 
            case l_GE:   printf("l_GE\n");continue; 
            case l_GT:   printf("l_GT\n");continue; 
            case l_ADD:  printf("l_ADD\n");continue;
            case l_SUB:  printf("l_SUB\n");continue;
            case l_MUL:  printf("l_MUL\n");continue;
            case l_DIV:  printf("l_DIV\n");continue;
            case l_MOD:  printf("l_MOD\n");continue;
            case f_EQ:   printf("f_EQ\n");continue; 
            case f_NE:   printf("f_NE\n");continue; 
            case f_LT:   printf("f_LT\n");continue; 
            case f_LE:   printf("f_LE\n");continue; 
            case f_GE:   printf("f_GE\n");continue; 
            case f_GT:   printf("f_GT\n");continue; 
            case f_ADD:  printf("f_ADD\n");continue;
            case f_SUB:  printf("f_SUB\n");continue;
            case f_MUL:  printf("f_MUL\n");continue;
            case f_DIV:  printf("f_DIV\n");continue;
            case d_EQ:   printf("d_EQ\n");continue; 
            case d_NE:   printf("d_NE\n");continue; 
            case d_LT:   printf("d_LT\n");continue; 
            case d_LE:   printf("d_LE\n");continue; 
            case d_GE:   printf("d_GE\n");continue; 
            case d_GT:   printf("d_GT\n");continue; 
            case d_ADD:  printf("d_ADD\n");continue;
            case d_SUB:  printf("d_SUB\n");continue;
            case d_MUL:  printf("d_MUL\n");continue;
            case d_DIV:  printf("d_DIV\n");continue;
            case s_EQ:   printf("d_EQ\n");continue; 
            case s_NE:   printf("d_NE\n");continue; 
            case s_LT:   printf("d_LT\n");continue; 
            case s_LE:   printf("d_LE\n");continue; 
            case s_GE:   printf("d_GE\n");continue; 
            case s_GT:   printf("d_GT\n");continue; 
            case s_ADD:  printf("d_ADD\n");continue;
            case THREAD: printf("thread    %3d\n",_Integer_value(Array_get(program,pc++)));continue;
            case EOE:    printf("EOE\n");continue;

            case CALL:{
                printf("CALL      ");//T
                oop num_arg = Array_get(program,pc++);
                oop index = Array_get(program,pc++);
                printf("%3d  %3d\n",_Integer_value(num_arg),_Integer_value(index));
                continue;
            }
            case CALL_P:{
                printf("CALL_P     ");//T
                oop lib_num  = Array_get(program,pc++);
                oop func_num = Array_get(program,pc++);
                oop num_args = Array_get(program,pc++);
                printf("%3d  %3d  %3d\n",_Integer_value(lib_num),_Integer_value(func_num),_Integer_value(num_args));
                continue;
            }
            case CALL_E:{
                printf("CALL_E     ");//T
                oop lib_num  = Array_get(program,pc++);
                oop func_num = Array_get(program,pc++);
                oop num_args = Array_get(program,pc++);
                printf("%3d  %3d  %3d\n",_Integer_value(lib_num),_Integer_value(func_num),_Integer_value(num_args));
                continue;
            }
            case GET:{
                printf("Get       ");//T
                oop symbol = Array_get(program,pc++);
                printlnObject(symbol,1);//T
                continue;
            }
            case GET_L:{
                printf("Get_L     ");//T
                oop symbol = Array_get(program,pc++);
                printlnObject(symbol,1);//T
                continue;
            }
            case GET_G:{
                printf("GET_G     ");
                oop symbol = Array_get(program,pc++);
                printlnObject(symbol,1);
                continue;
            }
            case DEFINE:{
                printf("DEFINE    ");//T
                oop symbol = Array_get(program,pc++);
                printlnObject(symbol,1);//T
                continue;
            }
            case DEFINE_L:{
                printf("DEFINE_L    ");//T
                oop symbol = Array_get(program,pc++);
                printlnObject(symbol,1);//T
                continue;
            }
            case DEFINE_G:{
                printf("DEFINE_G  ");//T
                oop symbol = Array_get(program,pc++);
                printlnObject(symbol,1);//T
                continue;
            }  
            case DEFINE_List:{
                printf("DEFINE_List  ");//T
                oop symbol = Array_get(program,pc++);
                printlnObject(symbol,1);//T
                continue;
            }  
            case GLOBAL:{
                printf("GLOBAL\n");
                continue;
            }
            case GLOBAL_END:{
                printf("GLOBAL_END\n");
                continue;
            }
            case ENTRY:{
                printf("ENTRY     %3d\n",_Integer_value(Array_get(program,pc++)));
                continue;
            }
            case SETQ:{
                printf("SETQ\n");
                continue;
            }
            case RET:{
                printf("RET       ");
                printf("  X\n");
                continue;
            }
            case MSUB:{
                printf("MSUB      ");
                printlnObject(Array_get(program,pc++),1);
                continue;
            }
            case MPOP:{
                printf("MPOP\n");
                continue;
            }
            case MPICK:{
                printf("MPICK      ");
                int i = _Integer_value(Array_get(program,pc++));
                int j = _Integer_value(Array_get(program,pc++));
                printf("%3d %3d\n",i,j);
                continue;
            }
            case MSET:{
                printf("MSET      ");
                printf("%3d\n",_Integer_value(Array_get(program,pc++)));
                continue;
            }
            case JUMPF:{
                printf("jumpF     ");//T
                int offset = _Integer_value(Array_get(program,pc++)); 
                printf("%3d\n",offset);//T
                continue;
            }
            case JUMP:{
                printf("jump      ");
                int offset = _Integer_value(Array_get(program,pc++)); 
                printf("%3d\n",offset);
                continue;       
            }
            case i_PRINT:{
                printf("i PRINT\n");
                continue;
            }
            case l_PRINT:{
                printf("l PRINT\n");
                continue;
            }
            case f_PRINT:{
                printf("f PRINT\n");
                continue;
            }
            case d_PRINT:{
                printf("d PRINT\n");
                continue;
            }
            case c_PRINT:{
                printf("c PRINT\n");
                continue;
            }
            case s_PRINT:{
                printf("s PRINT\n");
                continue;
            }
            case HALT:{
                printf("HALT\n");
                return nil;
            }
        }
    }
}



/*
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                        vritual machine code
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
*/


// oop sub_execute(oop,oop,oop);
//Flagp main_execute(oop,oop);







// QUEUE
#define SUCCESS     1       /* 成功 */
#define FAILURE     0       /* 失敗 */
#define QUEUE_SIZE 5          /* 待ち行列に入るデータの最大数 */







// END QUEUE






oop _newThread(size_t size)
{
    oop node = newObject(Thread);
    node->Thread.flag       =  0;
    node->Thread.queue_head =  0;
    node->Thread.queue_num  =  0;
    node->Thread.pc         =  0;
    node->Thread.base       =  0;
    node->Thread.rbp        =  1;//1st rbp, 2nd.. event args,
    node->Thread.stack      = newArray(0);
    VD       vd = calloc(1,size);
    node->Thread.vd         = vd;
    return node;
}
#define newThread(TYPE)	_newThread(sizeof(struct TYPE))

oop _setThread(oop t,size_t size)
{
    t->Thread.flag       =  0;
    t->Thread.queue_head =  0;
    t->Thread.queue_num  =  0;
    t->Thread.pc         =  0;
    t->Thread.base       =  0;
    t->Thread.rbp        =  0;
    t->Thread.stack      = newArray(0);
    VD       vd = calloc(1,size);
    t->Thread.vd         = vd;
    return t;
}
#define setThread(T,TYPE)	_setThread(T,sizeof(struct TYPE))



void printThread(oop t){
    int i = getType(t->Thread.stack);
    printf("stack == %s\n",TYPENAME[i]);
    printf("pc     %d\n",t->Thread.pc);
    printf("rbp    %d\n",t->Thread.rbp);
    printf("q head %d\n",t->Thread.queue_head);
    printf("q num  %d\n",t->Thread.queue_num);
    printf("flag   %d\n",t->Thread.flag);
}



int enqueue(oop t,oop data)
{
    if (t->Thread.queue_num < QUEUE_SIZE) {
        t->Thread.queue[(t->Thread.queue_head + t->Thread.queue_num) % QUEUE_SIZE] = data;
        t->Thread.queue_num++;
        return SUCCESS;
    } else {
        return FAILURE;
    }
}

oop dequeue(oop t)
{
    if (t->Thread.queue_num > 0) {
        oop data = t->Thread.queue[t->Thread.queue_head];
        t->Thread.queue_head = (t->Thread.queue_head + 1) % QUEUE_SIZE;
        t->Thread.queue_num--;
        return data;
    } else {
        return 0;
    }
}

enum event_list{
    Loop,
    Timer,
};



// EVENT FUNCTION
oop eve_loop(oop t){
    if(t->Thread.flag == 0){
        oop data = newArray(2);
        Array_push(data,new_Basepoint(1));//1st rbp, 2nd.. event args, 
        Array_push(data,_newInteger(1));
        enqueue(t,data);
    }
    return t;
}

oop eve_timer(oop t){
    // printf("        timer\n");

    time_t current_time = time(NULL);
    if(current_time - t->Thread.vd->VarTI.v_t1 >= t->Thread.vd->VarTI.v_i2){
        t->Thread.vd->VarTI.v_t1 = current_time;
        t->Thread.vd->VarTI.v_i1  += t->Thread.vd->VarTI.v_i2;
        oop data = newArray(2);
        Array_push(data,new_Basepoint(1));//1st rbp, 2nd.. event args, 
        Array_push(data,_newInteger(t->Thread.vd->VarTI.v_i1));
        enqueue(t,data);
    }
    return t;
}

oop eve_keyget(oop t){
    char buf;
    struct termios old_flags, new_flags;
    fd_set fds;
    struct timeval tv;
    int ret;

    // 標準入力をノンブロッキングモードに設定
    int flags = fcntl(STDIN_FILENO, F_GETFL, 0);
    fcntl(STDIN_FILENO, F_SETFL, flags | O_NONBLOCK);

    // 現在の端末属性を取得
    tcgetattr(STDIN_FILENO, &old_flags);
    new_flags = old_flags;
    // ICANON(カノニカルモード)とECHO(エコー)を無効にする
    new_flags.c_lflag &= ~(ICANON | ECHO);
    tcsetattr(STDIN_FILENO, TCSANOW, &new_flags);

    // 標準入力からの読み取りを待たない
    FD_ZERO(&fds);
    FD_SET(STDIN_FILENO, &fds);

    // タイムアウトを設定（0秒）
    tv.tv_sec = 0;
    tv.tv_usec = 0;
    
    // 標準入力からの読み取りをチェック
    ret = select(STDIN_FILENO + 1, &fds, NULL, NULL, &tv);
    if (ret < 0) {
        perror("select");
        exit(EXIT_FAILURE);
    } else if (ret == 0) {
        // 標準入力からの読み取りが利用可能でない場合
        return 0;
    } else {
        // 標準入力からの読み取りが利用可能な場合、1バイト読み取る
        if (read(STDIN_FILENO, &buf, 1) < 0) {
            if (errno == EAGAIN || errno == EWOULDBLOCK) {
                // 読み取りが非同期にブロックされている場合
                return 0;
            } else {
                perror("read");
                exit(EXIT_FAILURE);
            }
        }
        // 読み取った文字を返す
        oop data = newArray(2);
        Array_push(data,new_Basepoint(1));//1st rbp, 2nd.. event args, 
        Array_push(data,_newInteger(buf));
        enqueue(t,data);
        return t;
    }
}

//STDLIB EVENT
oop Event_stdlib(int eve_num,oop stack){
    switch(eve_num){
        case LOOP_E:{
            oop t = newThread(Default);
            t->Thread.vd->Default.count = 0;
            t->Thread.func = &eve_loop;
            return t;
        }
        case TIMERSEC_E:{
            oop t = newThread(VarTI);
            t->Thread.vd->VarTI.v_t1 = time(NULL);
            t->Thread.vd->VarTI.v_i1  = 0;
            t->Thread.vd->VarTI.v_i2  = _Integer_value(Array_pop(stack));
            t->Thread.func = &eve_timer;
            return t;
        }
        case KEYGET_E:{
            oop t = newThread(Default);
            t->Thread.func = &eve_keyget;
            while(0!=t->Thread.func(t))dequeue(t);
            return t;
        }
        default:{
            fprintf(stderr,"this is not happen Event_stdlib eve[%d]\n",eve_num);
            exit(1);
        }
    }
    printf("Event_stdlib(): not happen..\n");
    return 0;
}


oop Event_userlib(int eve_num,oop stack){
    switch(eve_num){
        default:
            fprintf(stderr,"this is not happen Event_userlib\n");
    }
    exit(1);
}

// EVENT...
oop Event_Func(int lib_num,int eve_num,oop stack){
    switch(lib_num){
        case STDLIB:{
            return Event_stdlib(eve_num,stack);
        }
        case USERLIB:{
            return 0;
        }
        default:{
            printf("ERROR: Event lib[%d] eve[%d]\n",lib_num, eve_num);
            exit(1);
        }
    }
    printf("Event_Func(): not happen..\n");
    return 0;
}



char inst      = 0;
char char_value    = 0;
int  int_value      = 0;
long long int long_value = 0;
float float_value   = 0;
double double_value = 0;
char   string_value[256];

#define getData(D,PC,S) memcpy(&D,&memory[PC],S); PC+=S
#define getInst(PC)     memcpy(&inst,&memory[PC],SIZE_INST); PC+=SIZE_INST
#define getChar(PC)     memory[PC++]
#define getInt(PC)      memcpy(&int_value,&memory[PC],SIZE_INT);PC+=SIZE_INT 
#define getLong(PC)     memcpy(&long_value,&memory[PC],SIZE_LONG);PC+=SIZE_LONG
#define getFloat(PC)    memcpy(&float_value,&memory[PC],SIZE_FLOAT);PC+=SIZE_FLOAT
#define getDouble(PC)   memcpy(&double_value,&memory[PC],SIZE_DOUBLE);PC+=SIZE_DOUBLE



#define getString(PC)   ({ \
    int i = 0; \
    while(memory[PC]!='\0'){ \
        string_value[i++] = memory[PC++]; \
    } \
    string_value[i] = memory[PC++]; \
})

//-----------_----------__------______----________--__________


#include <unistd.h>//remove


void main_execute(){
    int test_impliment_limit = 0; //REMOVEME: TEST only 
    int pc = 0;
    int rbp = 0;
    oop stack = newArray(10); //動的にメモリを確保するようにしないとメモリが被ってしまうため、スタックのデータがかぶる。
    // GROBAL MEMORY
    oop GM    = newThread(Default);
    GM->Thread.stack = newArray(10);
    GM->Thread.rbp   = 0;
    
    for(;;){
        getInst(pc);
        switch(inst){
            case i_load:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
line();
#endif
                getInt(pc);
                Array_push(stack,_newInteger(int_value));
                continue;
            }

            case THREAD:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                getInt(pc);
                int num_thread = int_value;
                if(num_thread == 0)continue;
                int thread_pc = pc;
                oop t = newArray(num_thread);
                

            //init setting thread スレッドの初期設定
                printf("\n              setting\n\n");
                for(int thread_index=0; thread_index<num_thread;/*case CALL_E, thread_index++*/){
                    getInst(pc);
                    switch(inst){
                        case i_load:{// load pin number / load location of event task
#if TEST  
line();printf("THREAD => %s\n",INSTNAME[inst]);
#endif
                            getInt(pc);
                            Array_push(stack,_newInteger(int_value));
                            continue;
                        }
                        case CALL_E:{//now
#if TEST  
line();printf("THREAD => %s\n",INSTNAME[inst]);
#endif
                            getInt(pc);int lib_num = int_value;
                            getInt(pc);int eve_num = int_value;
                            getInt(pc);int pin_num = int_value;

                            Array_push(t,Event_Func(lib_num,eve_num,stack));                 // connect function of event / イベントの関数と紐付け
                            
                            int inst_loc = thread_pc + _Integer_value(Array_pop(stack));
                            t->Array.elements[thread_index]->Thread.pc   = inst_loc;
                            t->Array.elements[thread_index]->Thread.base = inst_loc;
                            
                            thread_index++;
                            continue;
                        }
                        default:{
                            printf("this is not happen, main main_execute case THREAD\n");
                            exit(1);
                        }
                    }
                }
                printf("\n              implement\n\n");
    // implement thread/Event concurrelty
                for(int is_active = 0,count = 5; is_active==0;){
                    count++;
                    for(int i =0;i<num_thread;i++){
                        t->Array.elements[i]->Thread.func(t->Array.elements[i]);             //implement function of event

                        if(t->Array.elements[i]->Thread.flag == 1){
                            FLAG flag = sub_execute(t->Array.elements[i],GM);
                            if(flag == F_TRANS){//TRANS
                                printf("        TRANS\n");
                                int pc_i = t->Array.elements[i]->Thread.pc++;//location of thread[i]'s pc
                                getInt(pc_i);//thread num<-pc_i
                                pc = int_value + pc_i;
                                // printf("pc-> %d\n",pc);
                                is_active = 1;
                                int gm_size = GM->Thread.stack->Array.size;
                                for(int i = gm_size;i>GM->Thread.rbp;i--){
                                    Array_pop(GM->Thread.stack);
                                }
                                break;
                            }
                            else if(flag == F_EOE){//EOE
                                t->Array.elements[i]->Thread.flag = 0;
                                t->Array.elements[i]->Thread.pc = t->Array.elements[i]->Thread.base;
                                if(test_impliment_limit>1000000){
                                    printf("\n\n");
                                    return;
                                }else test_impliment_limit++;
                            }
                        }
                        else if(t->Array.elements[i]->Thread.queue_num>0){
                                t->Array.elements[i]->Thread.flag = 1;
                                t->Array.elements[i]->Thread.stack = dequeue(t->Array.elements[i]);
                                // Array_push(t->Array.elements[i]->Thread.stack,new_Basepoint(1));//1st rbp, 2nd.. event args, 
                                // Array_push(t->Array.elements[i]->Thread.stack,dequeue(t->Array.elements[i]));//TODO: put args of event into t[i]->stack: timer(int sec)=> sec is arg
                        }
                    }
                    // if(count>5){
                    //     count = 0;
                    // }
                }
                free(t);
                continue;
            }
            case DEFINE_L:{
                getInt(pc);
                oop data  = Array_pop(stack);
                Array_put(GM->Thread.stack,GM->Thread.rbp + int_value, data);
                continue;
            }
            case GLOBAL:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                oop code = newThread(Default);
                code->Thread.pc = pc;
                for(;;){
                    FLAG flag = sub_execute(code,GM);
                    if(flag == F_EOE)break;
                }
                pc = code->Thread.pc;
                free(code);//IFERROR
                continue;
            }
            case ENTRY:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                getInt(pc);
                int s_pc = pc;//store corrent pc
                oop code = newThread(Default);
                code->Thread.pc = pc + int_value;
                Array_push(code->Thread.stack,new_Basepoint(0));
                for(;;){
                    FLAG flag = sub_execute(code,GM);
                    if(flag == F_EOE)break;
                }
                free(code);
                pc = s_pc;
                continue;                
            }
            case MSET:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                getInt(pc);GM->Thread.rbp = int_value;
                for(int i =0;i<int_value ;i++){
                    Array_push(GM->Thread.stack,nil);
                }
                continue;
            }
            case JUMP:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                getInt(pc); pc += int_value;
                continue;       
            }
            case HALT:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                return;
            }
            default:fprintf(stderr,"main_execute error %s\n",INSTNAME[inst]);
        }
    }
}

#define mpc    process->Thread.pc
#define mrbp   process->Thread.rbp
#define mstack process->Thread.stack



#define api()     _Integer_value(Array_pop(mstack))
#define apl()     Array_pop(mstack)->_Long.value
#define apf()     _Float_value(Array_pop(mstack))
#define apd()     Array_pop(mstack)->_Double.value
#define aps()     Array_pop(mstack)->String.value
#define apc()    _Char_value(Array_pop(mstack))


// ライブラリ関数
void stdlib_print(oop process,oop GM){
    getInt(mpc);int size_args = int_value;
    int value = api();
    printf("%d\n",value);
    return;
}

void stdlib_itoc(oop process,oop GM){
    getInt(mpc);int size_args = int_value;
    char value = (char)api();
    oop c = _newChar(value);
    Array_push(mstack,c);
    return; 
}

void stdlib_exit(oop process,oop GM){
    getInt(mpc);int size_args = int_value;
    int value = api();
    exit(value);
    return;
}

void stdlib_appendchar(oop process,oop GM){
    getInt(mpc);int size_args = int_value;
    char* str = aps();
    char c = apc();
    size_t length = strlen(str);
    char* newStr = (char*)malloc((length + 2) * sizeof(char)); // 新しい文字列のメモリを確保
    if (newStr != NULL){
        strcpy(newStr, str); // 元の文字列をコピー
        newStr[length] = c;  // 追加する文字をセット
        newStr[length + 1] = '\0'; // ヌル終端を追加
    }
    Array_push(mstack,newString(newStr));
    return;
}

void lib_stdlib(oop process,oop GM){
    getInt(mpc);int func_num = int_value;
    switch(func_num){
        case OUTPUT_P:{
            stdlib_print(process,GM);
            break;
        }
        case ITOC_P:{
            stdlib_itoc(process,GM);
            break;
        }
        case EXIT_P:{
            stdlib_exit(process,GM);
            break;
        }
        case APPENDCHAR_P:{
            stdlib_appendchar(process,GM);
            break;
        }
        default:
            break;
    }
}

oop Call_Primitive(oop process,oop GM){
    getInt(mpc);int lib_num = int_value;
    switch(lib_num){
        case STDLIB:{
            lib_stdlib(process,GM);
            break;
        }
        default:{
            printf("Call_Primitive %d\n",lib_num);
            exit(1);
        }
    }
    return nil;
}
////////////////////////////////////////////////




FLAG sub_execute(oop process,oop GM){
    for(;;){
        getInst(mpc);
        switch(inst){
            case TRANS:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                return F_TRANS;
            }
            case i_load:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                getInt(mpc);
                Array_push(mstack,_newInteger(int_value));
                continue;
            }
            case l_load:
            {
                getLong(mpc);
                Array_push(mstack,_newLong(long_value));
                continue;
            }
            case f_load:{
                getFloat(mpc);
                Array_push(mstack,_newFloat(float_value));
                continue;
            }
            case d_load:{
                getDouble(mpc);
                Array_push(mstack,_newDouble(double_value));
                continue;
            }
            case c_load:{
                char vlaue = getChar(mpc);
                Array_push(mstack,_newDouble(double_value));
                continue;    
            }
            case s_load:{
                getString(mpc);
                Array_push(mstack,newString(string_value));
                continue;
            }
            case il_load:{
                getInt(mpc);
                oop list = _newIntegerArray(_Integer_value(Array_pop(mstack)));
                for(int i=0;i<int_value;i++){
                    list->_IntegerArray.array[i] = Array_pop(mstack);
                }
                Array_put(mstack,int_value,list);
                continue;
            }
/* _Integer */
            case i_EQ:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                int r = api(),l = api();
                Array_push(mstack,newBoolean(l == r));
                continue;
            }
            case i_NE:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                int r = api(),l = api();
                Array_push(mstack,newBoolean(l != r));
                continue;
            }
            case i_LT:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                int r = api(),l = api();
                Array_push(mstack,newBoolean(l <  r));
                continue;
            }
            case i_LE:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                int r = api(),l = api();
                Array_push(mstack,newBoolean(l <= r));
                continue;
            }
            case i_GE:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                int r = api(),l = api();
                Array_push(mstack,newBoolean(l >= r));
                continue;
            }
            case i_GT:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                int r = api(),l = api();
                Array_push(mstack,newBoolean(l >  r));
                continue;
            }
            case i_AND:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                int r = api(),l = api();
                Array_push(mstack,newBoolean(l && r));
                continue;
            }
            case i_OR:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                int r = api(),l = api();
                Array_push(mstack,newBoolean(l || r));
                continue;
            }
            case i_ADD:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                int r = api(),l = api();
                Array_push(mstack,_newInteger(l + r));
                continue;
            }
            case i_SUB:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                int r = api(),l = api();
                Array_push(mstack,_newInteger(l - r));
                continue;
            }
            case i_MUL:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                int r = api(),l = api();
                Array_push(mstack,_newInteger(l * r));
                continue;
            }
            case i_DIV:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                int r = api(),l = api();
                Array_push(mstack,_newInteger(l / r));
                continue;
            }
            case i_MOD:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                int r = api(),l = api();
                Array_push(mstack,_newInteger(l % r));
                continue;
            }
/* Long */
            case l_EQ:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                long long int r = apl(),l = apl();
                if(l==r)Array_push(mstack,sys_true);
                else    Array_push(mstack,sys_false);
                continue;
            }
            case l_NE:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                long long int r = apl(),l = apl();
                if(l!=r)Array_push(mstack,sys_true);
                else    Array_push(mstack,sys_false);
                continue;
            }
            case l_LT: {
                long long int r = apl(),l = apl();
                if(l< r)Array_push(mstack,sys_true);
                else    Array_push(mstack,sys_false);
                continue;
            }
            case l_LE: {
                long long int r = apl(),l = apl();
                if(l<=r)Array_push(mstack,sys_true);
                else    Array_push(mstack,sys_false);
                continue;
            }
            case l_GE:{
                long long int r = apl(),l = apl();
                if(l>=r)Array_push(mstack,sys_true);
                else    Array_push(mstack,sys_false);
                continue;
            } 
            case l_GT:{
                long long int r = apl(),l = apl();
                if(l< r)Array_push(mstack,sys_true);
                else    Array_push(mstack,sys_false);
                continue;
            } 
            case l_ADD:{
                long long int r = apl(),l = apl();
                Array_push(mstack,_newLong(l+r));
                continue;
            } 
            case l_SUB:{
                long long int r = apl(),l = apl();
                Array_push(mstack,_newLong(l-r));
                continue;
            } 
            case l_MUL:{
                long long int r = apl(),l = apl();
                Array_push(mstack,_newLong(l*r));
                continue;
            } 
            case l_DIV:{
                long long int r = apl(),l = apl();
                Array_push(mstack,_newLong(l/r));
                continue;
            } 
            case l_MOD:{
                long long int r = apl(),l = apl();
                Array_push(mstack,_newLong(l%r));
                continue;
            } 
/* _Float */
            case f_EQ:{
                float r = apf(),l = apf();
                if(l==r)Array_push(mstack,sys_true);
                else    Array_push(mstack,sys_false);
                continue;
            }
            case f_NE:{
                float r = apf(),l = apf();
                if(l!=r)Array_push(mstack,sys_true);
                else    Array_push(mstack,sys_false);
                continue;
            }
            case f_LT:{
                float r = apf(),l = apf();
                if(l< r)Array_push(mstack,sys_true);
                else    Array_push(mstack,sys_false);
                continue;
            } 
            case f_LE: {
                float r = apf(),l = apf();
                if(l<=r)Array_push(mstack,sys_true);
                else    Array_push(mstack,sys_false);
                continue;
            }
            case f_GE: {
                float r = apf(),l = apf();
                if(l>=r)Array_push(mstack,sys_true);
                else    Array_push(mstack,sys_false);
                continue;
            }
            case f_GT: {
                float r = apf(),l = apf();
                if(l< r)Array_push(mstack,sys_true);
                else    Array_push(mstack,sys_false);
                continue;
            }
            case f_ADD:{
                float r = apf(),l = apf();
                Array_push(mstack,_newFloat(l+r));
                continue;
            } 
            case f_SUB:{
                float r = apf(),l = apf();
                Array_push(mstack,_newFloat(l-r));
                continue;
            } 
            case f_MUL:{
                float r = apf(),l = apf();
                Array_push(mstack,_newFloat(l*r));
                continue;
            } 
            case f_DIV:{
                float r = apf(),l = apf();
                Array_push(mstack,_newFloat(l/r));
                continue;
            } 
/* Double */
            case d_EQ:{
                double r = apd(),l = apd();
                if(l==r)Array_push(mstack,sys_true);
                else    Array_push(mstack,sys_false);
                continue;
            }
            case d_NE:{
                double r = apd(),l = apd();
                if(l!=r)Array_push(mstack,sys_true);
                else    Array_push(mstack,sys_false);
                continue;
            }
            case d_LT:{
                double r = apd(),l = apd();
                if(l< r)Array_push(mstack,sys_true);
                else    Array_push(mstack,sys_false);
                continue;
            } 
            case d_LE:{
                double r = apd(),l = apd();
                if(l<=r)Array_push(mstack,sys_true);
                else    Array_push(mstack,sys_false);
                continue;
            } 
            case d_GE:{
                double r = apd(),l = apd();
                if(l>=r)Array_push(mstack,sys_true);
                else    Array_push(mstack,sys_false);
                continue;
            }
            case d_GT:{
                double r = apd(),l = apd();
                if(l> r)Array_push(mstack,sys_true);
                else    Array_push(mstack,sys_false);
                continue;
            } 
            case d_ADD:{
                double r = apd(),l = apd();
                Array_push(mstack,_newDouble(l+r));
                continue;
            } 
            case d_SUB:{
                double r = apd(),l = apd();
                Array_push(mstack,_newDouble(l-r));
                continue;
            } 
            case d_MUL:{
                double r = apd(),l = apd();
                Array_push(mstack,_newDouble(l*r));
                continue;
            } 
            case d_DIV:{
                double r = apd(),l = apd();
                Array_push(mstack,_newDouble(l/r));
                continue;
            } 


            case s_EQ: {
                char* r = aps(),*l = aps();
                if(strcmp(l,r)==0)Array_push(mstack,sys_true);
                else Array_push(mstack,sys_false);
                continue;
            } 
            case s_NE: {
                char* r = aps(),*l = aps();
                if(strcmp(l,r)!=0)Array_push(mstack,sys_true);
                else Array_push(mstack,sys_false);
                continue;
            } 
            case s_LT: {
                char* r = aps(),*l = aps();
                if(strcmp(l,r)<0)Array_push(mstack,sys_true);
                else Array_push(mstack,sys_false);
                continue;
            } 
            case s_LE:{
                char* r = aps(),*l = aps();
                if(strcmp(l,r)<=0)Array_push(mstack,sys_true);
                else Array_push(mstack,sys_false);
                continue;
            } 
            case s_GE: {
                char* r = aps(),*l = aps();
                if(strcmp(l,r)>=0)Array_push(mstack,sys_true);
                else Array_push(mstack,sys_false);
                continue;
            } 
            case s_GT: {
                char* r = aps(),*l = aps();
                if(strcmp(l,r)>0)Array_push(mstack,sys_true);
                else Array_push(mstack,sys_false);
                continue;
            }
            case s_ADD:{
                oop r = Array_pop(mstack);
                oop l = Array_pop(mstack);
                oop new = newString(strcat(strdup(l->String.value),r->String.value));
                Array_push(mstack,new);
                continue;
            }





/* end calc */
            case CALL:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                getInt(mpc);
                Array_push(mstack,_newInteger(int_value));//number of args
                getInt(mpc);
                Array_push(mstack,_newInteger(mpc));//CHECKME: funtion index?
                mpc = mpc + int_value;
                return F_NONE;
            }
            case CALL_P:{
#if TEST
printf("CALL_P\n");
#endif
                Call_Primitive(process,GM);
                return F_NONE;
            }
            case GET:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                getInt(mpc);
                Array_push(mstack,Array_get(mstack,mrbp + int_value));//index
                continue;
            }
            case GET_L:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                getInt(mpc);
                // printf("    %s\n",TYPENAME[getType(mstack)]);
                Array_push(mstack,Array_get(GM->Thread.stack,GM->Thread.rbp + int_value));//index
                continue;
            }
            case GET_G:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                getInt(mpc);
                Array_push(mstack,Array_get(GM->Thread.stack,int_value));//index
                continue;
            }
            case DEFINE:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                getInt(mpc);
                oop data  = Array_pop(mstack);
                Array_put(mstack,mrbp + int_value, data);
                continue;
            }
            case DEFINE_L:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                getInt(mpc);
                oop data  = Array_pop(mstack);
                Array_put(GM->Thread.stack,GM->Thread.rbp + int_value, data);
                continue;
            }
            case DEFINE_G:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                getInt(mpc);
                oop data = Array_pop(mstack);
                Array_put(GM->Thread.stack,int_value,data);
                continue;
            }
            case DEFINE_List:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                getInt(mpc);
                int index = _Integer_value(Array_pop(mstack));
                oop data  = Array_pop(mstack);
                //FIXME: サイズの確認とかやってない
                GM->Thread.stack->Array.elements[int_value]->_IntegerArray.array[index] = data;
                continue;
            }
            case GLOBAL_END:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                return F_EOE;
            }
            case SETQ:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                continue;
            }
            case RET:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                oop value = Array_pop(mstack);//return value
                oop data = nil;
                while(getType(data = Array_pop(mstack)) != _BasePoint);
                mrbp = get(data,_BasePoint,adress);
                mpc = api();//next mpc 
                int num_arg = api();
                for(int i = 0;i<num_arg;i++)
                    Array_pop(mstack);
                Array_push(mstack,value);
                return F_NONE;
            }
            case JUMPF:{
#if TEST  
line();printf("%s [%d]\n",INSTNAME[inst],inst);
#endif
                getInt(mpc);//get offset
                oop cond = Array_pop(mstack);
                //FIXME: usign sys_false and sys_true
                if(cond == sys_false)mpc += int_value;//offset
                else if(cond == sys_true)return F_NONE;
                else if(_Integer_value(cond)==0)mpc += int_value;//offset
                return F_NONE;
            }
            case JUMP:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                getInt(mpc);     //get offset
                mpc += int_value;//get offset
                return F_NONE;//go next thread
            }
            case MSUB:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                //now
                mstack = Array_push(mstack, new_Basepoint(mrbp));//before mrpb
                mrbp = mstack->Array.size;            //current mrpb
                getInt(mpc);//memry
                int memory_size = int_value;
                for(int i=0;i<memory_size;i++){
                    Array_push(mstack,nil);//put nil into mstack for variable
                }
                continue;
            }
            case MPOP:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                for(;;){
                    oop data = Array_pop(mstack);
                    if(getType(data) == _BasePoint){
                        mrbp = data->_BasePoint.adress;
                        break;
                    }
                }
                continue;
            }
            case MPICK:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                getInt(mpc);
                int adress = int_value;
                getInt(mpc);
                int index  = int_value;
                oop data   = Array_get(mstack, mrbp - adress -1);
                Array_put(mstack,mrbp + index,data);
                continue;
            }
            case i_PRINT:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                printf("%d\n",_Integer_value(Array_pop(mstack)));
                continue;
            }
            case l_PRINT:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                printf("%lld\n",Array_pop(mstack)->_Long.value);
                continue;
            }
            case f_PRINT:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                printf("%f\n",_Float_value(Array_pop(mstack)));
                continue;
            }
            case d_PRINT:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                printf("%f\n",Array_pop(mstack)->_Double.value);
                continue;
            }
            case c_PRINT:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                printf("%c\n",_Char_value(Array_pop(mstack)));
                continue;
            }
            case s_PRINT:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                printf("%s\n",Array_pop(mstack)->String.value);
                continue;
            }
            case EOE:{
                // mpc  = mrbp;
                mpc -= 1;
                // exit(1);
                if(mstack->Array.size != 0){
                    fatal("IMPRIMENT ERROR: stack size is %d\n",mstack->Array.size);
                }
                return F_EOE;
            }
            case HALT:{
#if TEST  
line();printf("%s\n",INSTNAME[inst]);
#endif
                if(Array_size(mstack)==1){
                    printf("HALT-----------------------\n");
                    printlnObject(Array_pop(mstack),1);
                    return F_NONE;
                }
                printf("HALT with %d items on mstack\n",Array_size(mstack));
                int size = Array_size(mstack);
                for(int i = 0; i<size;i++)
                    printlnObject(Array_pop(mstack),1);
                return F_NONE;
            }
        }
        return F_NONE;
    } 
}




oop printByteCode(){
    int pc = 0;
    for(;;){
        printf("%3d ",pc);
        getInst(pc);
        switch(inst){
            case TRANS:  getInt(pc);printf("TRANS     %3d\n",int_value);continue;
            case i_load: getInt(pc);printf("i_load    %3d\n",int_value);continue;
            case l_load: getLong(pc);printf("l_load    %3lld\n",long_value);continue;
            case f_load: getFloat(pc);printf("f_load    %3f\n",float_value);continue;
            case d_load: getDouble(pc);printf("d_load    %3f\n",double_value);continue;
            case c_load: printf("c_load    %3c\n",getChar(pc));continue;
            case s_load: getString(pc);printf("s_load    %s\n",string_value);continue;
            case il_load: getInt(pc);printf("il_load    %d\n",int_value);continue;
            case i_EQ:   printf("i_EQ\n"); continue; 
            case i_NE:   printf("i_NE\n"); continue; 
            case i_LT:   printf("i_LT\n"); continue; 
            case i_LE:   printf("i_LE\n"); continue; 
            case i_GE:   printf("i_GE\n"); continue; 
            case i_GT:   printf("i_GT\n"); continue; 
            case i_ADD:  printf("i_ADD\n");continue;
            case i_SUB:  printf("i_SUB\n");continue;
            case i_MUL:  printf("i_MUL\n");continue;
            case i_DIV:  printf("i_DIV\n");continue;
            case i_MOD:  printf("i_MOD\n");continue;
            case l_EQ:   printf("l_EQ\n");continue; 
            case l_NE:   printf("l_NE\n");continue; 
            case l_LT:   printf("l_LT\n");continue; 
            case l_LE:   printf("l_LE\n");continue; 
            case l_GE:   printf("l_GE\n");continue; 
            case l_GT:   printf("l_GT\n");continue; 
            case l_ADD:  printf("l_ADD\n");continue;
            case l_SUB:  printf("l_SUB\n");continue;
            case l_MUL:  printf("l_MUL\n");continue;
            case l_DIV:  printf("l_DIV\n");continue;
            case l_MOD:  printf("l_MOD\n");continue;
            case f_EQ:   printf("f_EQ\n");continue; 
            case f_NE:   printf("f_NE\n");continue; 
            case f_LT:   printf("f_LT\n");continue; 
            case f_LE:   printf("f_LE\n");continue; 
            case f_GE:   printf("f_GE\n");continue; 
            case f_GT:   printf("f_GT\n");continue; 
            case f_ADD:  printf("f_ADD\n");continue;
            case f_SUB:  printf("f_SUB\n");continue;
            case f_MUL:  printf("f_MUL\n");continue;
            case f_DIV:  printf("f_DIV\n");continue;
            case d_EQ:   printf("d_EQ\n");continue; 
            case d_NE:   printf("d_NE\n");continue; 
            case d_LT:   printf("d_LT\n");continue; 
            case d_LE:   printf("d_LE\n");continue; 
            case d_GE:   printf("d_GE\n");continue; 
            case d_GT:   printf("d_GT\n");continue; 
            case d_ADD:  printf("d_ADD\n");continue;
            case d_SUB:  printf("d_SUB\n");continue;
            case d_MUL:  printf("d_MUL\n");continue;
            case d_DIV:  printf("d_DIV\n");continue;

            case s_EQ:   printf("d_EQ\n");continue; 
            case s_NE:   printf("d_NE\n");continue; 
            case s_LT:   printf("d_LT\n");continue; 
            case s_LE:   printf("d_LE\n");continue; 
            case s_GE:   printf("d_GE\n");continue; 
            case s_GT:   printf("d_GT\n");continue; 
            case s_ADD:  printf("d_ADD\n");continue;

            case THREAD: getInt(pc);printf("thread    %3d\n",int_value);continue;
            case EOE:    printf("EOE\n");continue;

            case CALL:{
                printf("CALL      ");
                getInt(pc);int num_arg = int_value;
                getInt(pc);int index = int_value;
                printf("%3d  %3d\n",num_arg,index);
                continue;
            }
            case CALL_P:{
                printf("CALL_P      ");
                getInt(pc);int lib_num = int_value;
                getInt(pc);int func_num = int_value;
                getInt(pc);int args_s = int_value;
                printf("%3d  %3d  %3d\n",lib_num,func_num,args_s);
                continue;
            }
            case CALL_E:{
                printf("CALL_E      ");
                getInt(pc);int lib_num = int_value;
                getInt(pc);int func_num = int_value;
                getInt(pc);int args_s = int_value;
                printf("%3d  %3d  %3d\n",lib_num,func_num,args_s);
                continue;
            }
            case GET:{
                printf("Get       ");//T
                getInt(pc);int symbol = int_value;
                printf("%3d\n",symbol);
                continue;
            }
            case GET_L:{
                printf("Get_L     ");//T
                getInt(pc);int symbol = int_value;
                printf("%3d\n",symbol);
                continue;
            }
            case GET_G:{
                printf("GET_G     ");
                getInt(pc);int symbol = int_value;
                printf("%3d\n",symbol);
                continue;
            }
            case DEFINE:{
                printf("DEFINE    ");//T
                getInt(pc);int symbol = int_value;
                printf("%3d\n",symbol);//T
                continue;
            }
            case DEFINE_L:{
                printf("DEFINE_L  ");//T
                getInt(pc);int symbol = int_value;
                printf("%3d\n",symbol);//T
                continue;
            }
            case DEFINE_G:{
                printf("DEFINE_List  ");//T
                getInt(pc);int symbol = int_value;
                printf("%3d\n",symbol);//T
                continue;
            }  
            case GLOBAL:{
                printf("GLOBAL\n");
                continue;
            }
            case GLOBAL_END:{
                printf("GLOBAL_END\n");
                continue;
            }
            case ENTRY:{
                printf("ENTRY     ");
                getInt(pc);int index = int_value;
                printf("%3d\n",index);//T
                continue;
            }
            case SETQ:{
                printf("SETQ\n");
                continue;
            }
            case RET:{
                printf("RET       ");
                printf("  X\n");
                continue;
            }
            case MSUB:{
                printf("MSUB      ");
                getInt(pc);printf("%3d\n",int_value);
                continue;
            }
            case MPOP:{
                printf("MPOP\n");
                continue;
            }
            case MPICK:{
                printf("MPICK     ");
                getInt(pc);int i = int_value;
                getInt(pc);int j = int_value;
                printf("%3d %3d\n",i,j);
                continue;
            }
            case MSET:{
                printf("MSET      ");
                getInt(pc);
                printf("%3d\n",int_value);
                continue;
            }
            case JUMPF:{
                printf("jumpF     ");//T
                getInt(pc);
                int offset = int_value; 
                printf("%3d\n",offset);//T
                continue;
            }
            case JUMP:{
                printf("jump      ");
                getInt(pc);
                int offset = int_value; 
                printf("%3d\n",offset);
                continue;       
            }
            case i_PRINT:{
                printf("i PRINT\n");
                continue;
            }
            case l_PRINT:{
                printf("l PRINT\n");
                continue;
            }
            case f_PRINT:{
                printf("f PRINT\n");
                continue;
            }
            case d_PRINT:{
                printf("d PRINT\n");
                continue;
            }
            case c_PRINT:{
                printf("c PRINT\n");
                continue;
            }
            case s_PRINT:{
                printf("s PRINT\n");
                continue;
            }
            case HALT:{
                printf("HALT\n");
                return nil;
            }
        }
    }
}